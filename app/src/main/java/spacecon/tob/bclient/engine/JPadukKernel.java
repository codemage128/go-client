package spacecon.tob.bclient.engine;

import java.util.Random;

/**
 * Created by HongGukSong on 9/19/2017.
 */

public class JPadukKernel {
    // by KWJ : 2007-04-30
    private int m_dwLimitTime;
    private long m_dwTimeStart;

    static boolean bDebug = false;
    JPadukEngine m_Engine = new JPadukEngine();
    public JPadukKernel() {
//        random.setSeed(6554);
        random.setSeed(System.currentTimeMillis());
    }
    /*
        public void Kernel_init(short nBoardSize, short nColor ) {
            InitConstData();
            ClassCreat();

            m_Engine.m_nStoneCounter = 1;
            m_Engine.m_nGameStatus = IS_GAME;
            m_Engine.m_nIniStoneCount = 0;

            InitGame(nBoardSize, (short) (nColor + 1), m_Engine.m_nIniStoneCount);
            //InitGame(nBoardSize, nColor);

            if (nColor != 1) {
                m_Engine.m_nTurn = IS_BLACK;
                m_Engine.m_nMan = IS_WHITE;
            } else {
                m_Engine.m_nTurn = IS_WHITE;
                m_Engine.m_nMan = IS_BLACK;
            }
            setInitStones(m_Engine.m_nIniStoneCount);
        }
    */
//H.Joon-2007/03/06>>
    public void Kernel_Init( short nBoardSize, short nColor )
    {
        m_dwLimitTime = 5; // byKWJ : 2007-04-30
        //by Jong 2004/8/17

        if( nColor == 0 )
            nColor = IS_WHITE;
        else
            nColor = IS_BLACK;

        InitConstData();
        ClassCreat();

        m_Engine.m_nStoneCounter = 1;
        m_Engine.m_nGameStatus = IS_GAME;
        m_Engine.m_nIniStoneCount = IniStone0;

        InitGame( nBoardSize, nColor );

        if( nColor  != 1 )
        {
            m_Engine.m_nTurn = IS_BLACK;
            m_Engine.m_nMan = IS_WHITE;
        }
        else
        {
            m_Engine.m_nTurn = IS_WHITE;
            m_Engine.m_nMan = IS_BLACK;
        }
        m_Engine.m_bFirstMove = false;
    }
//<<
/*
    public short Kernel_PlaceStone(short x, short y, byte nStoneColor) {
        short wPoint;
        m_Engine.m_nBoardX = (short) (x - 1);
        m_Engine.m_nBoardY = (short) (y - 1);

        wPoint = (short) ( (m_Engine.m_nBoardX << 8) | (m_Engine.m_nBoardY));

        if ( (nStoneColor & 1) == 0)
            return PlaceStone(wPoint, IS_BLACK);
        else
            return PlaceStone(wPoint, IS_WHITE);
    }
*/

    public short Kernel_PlaceStone(short wPos, short nStoneColor) {
        short wPoint;
        m_Engine.m_nBoardX = (short)((LOBYTE(wPos) & 0xff) - 1);
        m_Engine.m_nBoardY = (short)((HIBYTE(wPos) & 0xff) - 1);

        wPoint =  (short)((m_Engine.m_nBoardX << 8) | m_Engine.m_nBoardY);
        if (wPos == M_PASS)
            wPoint = M_PASS;

        if ( (nStoneColor & 1) == 0)
          return PlaceStone(wPoint, IS_BLACK);
        else
            return PlaceStone(wPoint, IS_WHITE);
    }

    public short[] getLastGibo() {
        short[] pStones = new short[m_Engine.m_nDeadStoneCount + 1];
        pStones[0] = m_Engine.m_nBoardPos;
        System.arraycopy(m_Engine.m_nDeadStonePosBuf, 0, pStones, 1, m_Engine.m_nDeadStoneCount);
        return pStones;
    }

    public void restoreLastGibo(short[] coms, short[] mans, short oldPos) {

        m_Engine.m_nBoardPos = oldPos;

        m_Engine.m_byBoard[coms[0]] = 0;
        m_Engine.m_byBoard[mans[0]] = 0;

        int count = coms.length - 1;
        for (int i = 1; i <= count; i++)
            UnDelStone(coms[i], m_Engine.m_nTurn);

        count = mans.length - 1;
        for (int i = 1; i <= count; i++)
            UnDelStone(mans[i], m_Engine.m_nMan);
    }

    void UnDelStone(short wPoint, short nStoneColor) {
        m_Engine.m_nBoardPos = wPoint; //GetBoardPos(pEngine, wPoint);

        m_Engine.m_byStrNum = 0;

        SetStone2( (byte) nStoneColor);

        m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] =
                m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = 0;
        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] = 0;
        CountUnDelStones(nStoneColor);

        SetBit0_1();

        MarkInArea();
        ExpressTempArea();
        SaveTempArea();

    }

    void CountUnDelStones(short nStoneColor) {
        //pEngine->m_nStoneCounter ++;
        if (nStoneColor == IS_WHITE)
            m_Engine.m_nWhiteDeadCount--;
        else
            m_Engine.m_nBlackDeadCount--;
    }

    public void ComputerPlayStone() {
        short wPoint;

        wPoint = FindMove(m_Engine.m_nStoneCounter);
        //+++++++++++++++++++++++++++++++++++
        m_Engine.m_nBoardX = (short)(HIBYTE(wPoint) & 0xff);
        m_Engine.m_nBoardY = (short)(LOBYTE(wPoint) & 0xff);

        m_Engine.m_nGameStatus = IS_GAME;

//        return Kernel_PlaceStone((short)(((m_Engine.m_nBoardY+1) << 8) | (m_Engine.m_nBoardX+1)), (byte) m_Engine.m_nMan);
    }

    public void Kernel_Ground(byte cGomi, byte byEndInfo[][]) { //[19][19]
        short sGainValue, i, j;
        short sBlackValue, sWhiteValue;

        try
        {
            AreaGridRead(byEndInfo);

            sGainValue = 0;
            sBlackValue = 0;
            sWhiteValue = 0;

            for (i = 0; i < m_Engine.m_nBoardSize; i++)
                for (j = 0; j < m_Engine.m_nBoardSize; j++) {
                    if (byEndInfo[i][j] == 0)
                        continue;

                    if (byEndInfo[i][j] == IS_BLACK) {
                        if (((m_Engine.m_byBoard[(i + 1) * 20 + j + 1] & 0xff) > 0) &&
                                ((m_Engine.m_byBoard[(i + 1) * 20 + j + 1] & 1) == 0)) //IS_BLACK
                            continue;
                        sGainValue--;
                        sBlackValue++;
                        if (m_Engine.m_byBoard[(i + 1) * 20 + j + 1] > 0) {
                            sGainValue--;
                            sBlackValue++;
                        }
                    } else if (byEndInfo[i][j] == IS_WHITE) {
                        if ((m_Engine.m_byBoard[(i + 1) * 20 + j + 1] & 1) == IS_WHITE)
                            continue;
                        sGainValue++;
                        sWhiteValue++;
                        if (m_Engine.m_byBoard[(i + 1) * 20 + j + 1] > 0) {
                            sWhiteValue++;
                            sGainValue++;
                        }
                    }
                }
            sGainValue += (m_Engine.m_nBlackDeadCount - m_Engine.m_nWhiteDeadCount);
            sBlackValue += m_Engine.m_nWhiteDeadCount;
            sWhiteValue += m_Engine.m_nBlackDeadCount;

            return;
        }
        catch ( Exception e )
        {
            // e.printStackTrace();
        }
    }

    public byte[] getBoard() {
        return m_Engine.m_byBoard;
    }

    public short getBlackDeadCount() {
        return m_Engine.m_nBlackDeadCount;
    }

    public short getWhiteDeadCount() {
        return m_Engine.m_nWhiteDeadCount;
    }

    public short getLastPos() {
        return m_Engine.m_nBoardPos;
    }

    public void saveGiboTo(short[] giboStore) {
        giboStore[0] = m_Engine.m_nBoardPos;
        System.arraycopy(m_Engine.m_byBoard, 0, giboStore, 1, m_Engine.m_byBoard.length);
    }

    public void loadGiboFrom(short[] giboStore) {
        m_Engine.m_nBoardPos = giboStore[0];
        System.arraycopy(giboStore, 1, m_Engine.m_byBoard, 0, m_Engine.m_byBoard.length);
    }

    void InitConstData() {
        {
            byte by_StandardBoard[] = { //421
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16
            };
            /*
            byte by_StandardBoard[] = { //421
                (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0x0c, 0x0b, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0x0c, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0,
                (byte) - 16, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 6, 6,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 7, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0a, 0, 0, 0,
                (byte) - 16, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16, (byte) - 16, (byte) - 16,
                (byte) - 16
            };
            */
            byte _AroundPointPosTable[] = { //point 56 == short 112
                /*L1*/ -1, 0, /*U1*/ 0, -1, /*R1*/ 1, 0, /*D1*/ 0, 1,
                /*L1D1*/-1, 1, /*L1U1*/ -1, -1, /*R1U1*/ 1, -1, /*R1D1*/ 1, 1,
                /*L2*/-2, 0, /*U2*/ 0, -2, /*R2*/ 2, 0, /*D2*/ 0, 2,
                /*L2D1*/-2, 1, /*L2U1*/ -2, -1, /*L1U2*/ -1, -2, /*R1U2*/ 1, -2,
                /*R2U1*/2, -1, /*R2D1*/ 2, 1, /*R1D2*/ 1, 2, /*L1D2*/ -1, 2,
                /*L3*/-3, 0, /*U3*/ 0, -3, /*R3*/ 3, 0, /*D3*/ 0, 3,
                /*L3D1*/-3, 1, /*L3U1*/ -3, -1, /*L1U3*/ -1, -3, /*R1U3*/ 1, -3,
                /*R3U1*/3, -1, /*R3D1*/ 3, 1, /*R1D3*/ 1, 3, /*L1D3*/ -1, 3,
                /*L2D2*/-2, 2, /*L2U2*/ -2, -2, /*R2U2*/ 2, -2, /*R2D2*/ 2, 2,
                /*L4*/-4, 0, /*U4*/ 0, -4, /*R4*/ 4, 0, /*D4*/ 0, 4,
                /*L4D1*/-4, 1, /*L4U1*/ -4, -1, /*L1U4*/ -1, -4, /*R1U4*/ 1, -4,
                /*R4U1*/4, -1, /*R4D1*/ 4, 1, /*R1D4*/ 1, 4, /*L1D4*/ -1, 4,
                /*L3D2*/-3, 2, /*L3U2*/ -3, -2, /*L2U3*/ -2, -3, /*R2U3*/ 2, -3,
                /*R3U2*/3, -2, /*R3D2*/ 3, 2, /*R2D3*/ 2, 3, /*L2D3*/ -2, 3
            };

            byte _byInfo6_3[] = new byte[] { //[0x16]={
                    0x03, 0x07, 0x0b, 0x10, 0x15, 0x1a, 0x20, 0x27, 0x2e, 0x36,
                    0x3f, 0x49,
                    0x54, 0x60, 0x6d, 0x7c, (byte) 0x8c, (byte) 0x9e, (byte) 0xb2, (byte) 0xc8, (byte) 0xe0,
                    (byte) 0xfb
            };

            byte _byConstExtPoss[] = {
                    (byte) 0xA9, (byte) 0x99, (byte) 0x8B, 0x7E, 0x72, 0x67, 0x5D}; // 7

            short _MulValue[] = {
                    10, 20, 40, 17,
                    15, 17, 17, 14,
                    20, 16, 16, 18,
                    12, 20, 10, 50}; //16

            short _wGIniStonePos[][] = { { //3x10
                    0x0303, 0x0f0f, 0x0f03, 0x030f, 0x0309, 0x0f09, 0x0903, 0x090f,
                    0x0909, 0x0210}
                    , {
                    0x0303, 0x0909, 0x0903, 0x0309, 0x0306, 0x0906, 0x0603, 0x0609,
                    0x0606, 0x020a}
                    , {
                    0x0202, 0x0606, 0x0602, 0x0206, 0x0204, 0x0604, 0x0402, 0x0406,
                    0x0404, 0x0107}
            };
            short _nNeighbor[] = {
                    -1, -20, 1, 20, -1}; //5
            short _nStatusOrder[] = {
                    2, -1, 1, -1, -1, 0, 4, 3, 5, 9, 8, 7, -1, -1, 6, -1}; //16
            short _nScrOfPos0[] = {
                    0x08, 0x0c, 0x0d, 0x14, 0x18, 0x19, 0x20, 0x21, 0x24, 0x28,
                    0x29, 0x30, 0x31, 0x00, 0x04, 0x05};
            short _nScrOfPos1[] = {
                    0x09, 0x0e, 0x0f, 0x15, 0x1a, 0x1b, 0x21, 0x22, 0x25, 0x2a,
                    0x2b, 0x32, 0x33, 0x00, 0x05, 0x06};
            short _nScrOfPos2[] = {
                    0x0a, 0x10, 0x11, 0x16, 0x1c, 0x1d, 0x22, 0x23, 0x26, 0x2c,
                    0x2d, 0x34, 0x35, 0x00, 0x06, 0x07};
            short _nScrOfPos3[] = {
                    0x0b, 0x12, 0x13, 0x17, 0x1e, 0x1f, 0x23, 0x20, 0x27, 0x2e,
                    0x2f, 0x36, 0x37, 0x00, 0x07, 0x04};
            short _nScrOfPos4[] = {
                    0x08, 0x0b, 0x0c, 0x13, 0x14, 0x17, 0x18, 0x1f, 0x20, 0x24,
                    0x27, 0x28, 0x29, 0x2e, 0x2f, 0x30, 0x37, 0x00};
            short _nScrOfPos5[] = {
                    0x08, 0x09, 0x0d, 0x0e, 0x14, 0x15, 0x19, 0x1a, 0x21, 0x24,
                    0x25, 0x28, 0x29, 0x2a, 0x2b, 0x31, 0x32, 0x00};
            short _nScrOfPos6[] = {
                    0x09, 0x0a, 0x0f, 0x10, 0x15, 0x16, 0x1b, 0x1c, 0x22, 0x25,
                    0x26, 0x2a, 0x2b, 0x2c, 0x2d, 0x33, 0x34, 0x00};
            short _nScrOfPos7[] = {
                    0x0a, 0x0b, 0x11, 0x12, 0x16, 0x17, 0x1d, 0x1e, 0x23, 0x26,
                    0x27, 0x2c, 0x2d, 0x2e, 0x2f, 0x35, 0x36, 0x00};
            short _nScrOfPos8[] = {
                    0x14, 0x18, 0x19, 0x24, 0x28, 0x29, 0x30, 0x31, 0x00};
            short _nScrOfPos9[] = {
                    0x15, 0x1a, 0x1b, 0x25, 0x2a, 0x2b, 0x32, 0x33, 0x00};
            short _nScrOfPosa[] = {
                    0x16, 0x1c, 0x1d, 0x26, 0x2c, 0x2d, 0x34, 0x35, 0x00};
            short _nScrOfPosb[] = {
                    0x17, 0x1e, 0x1f, 0x27, 0x2e, 0x2f, 0x36, 0x37, 0x00};
            short _nScrOfPosc[] = {
                    0x14, 0x18, 0x19, 0x1f, 0x20, 0x24, 0x28, 0x29, 0x30, 0x37,
                    0x00};
            short _nScrOfPosd[] = {
                    0x14, 0x18, 0x19, 0x1a, 0x21, 0x24, 0x28, 0x29, 0x31, 0x32,
                    0x00};
            short _nScrOfPose[] = {
                    0x15, 0x19, 0x1a, 0x1b, 0x21, 0x25, 0x2a, 0x2b, 0x31, 0x32,
                    0x00};
            short _nScrOfPosf[] = {
                    0x15, 0x1a, 0x1b, 0x1c, 0x22, 0x25, 0x2a, 0x2b, 0x33, 0x34,
                    0x00};
            short _nScrOfPos10[] = {
                    0x16, 0x1b, 0x1c, 0x1d, 0x22, 0x26, 0x2c, 0x2d, 0x33, 0x34,
                    0x00};
            short _nScrOfPos11[] = {
                    0x16, 0x1c, 0x1d, 0x1e, 0x23, 0x26, 0x2c, 0x2d, 0x35, 0x36,
                    0x00};
            short _nScrOfPos12[] = {
                    0x17, 0x1d, 0x1e, 0x1f, 0x23, 0x27, 0x2e, 0x2f, 0x35, 0x36,
                    0x00};
            short _nScrOfPos13[] = {
                    0x17, 0x18, 0x1e, 0x1f, 0x20, 0x27, 0x2e, 0x2f, 0x30, 0x37,
                    0x00};
            short _nScrOfPos14[] = {
                    0x24, 0x28, 0x29, 0x00};
            short _nScrOfPos15[] = {
                    0x25, 0x2a, 0x2b, 0x00};
            short _nScrOfPos16[] = {
                    0x26, 0x2c, 0x2d, 0x00};
            short _nScrOfPos17[] = {
                    0x27, 0x2e, 0x2f, 0x00};
            short _nScrOfPos18[] = {
                    0x24, 0x28, 0x00};
            short _nScrOfPos19[] = {
                    0x24, 0x29, 0x00};
            short _nScrOfPos1a[] = {
                    0x25, 0x2a, 0x00};
            short _nScrOfPos1b[] = {
                    0x25, 0x2b, 0x00};
            short _nScrOfPos1c[] = {
                    0x26, 0x2c, 0x00};
            short _nScrOfPos1d[] = {
                    0x26, 0x2d, 0x00};
            short _nScrOfPos1e[] = {
                    0x27, 0x2e, 0x00};
            short _nScrOfPos1f[] = {
                    0x27, 0x2f, 0x00};
            short _nScrOfPos20[] = {
                    0x28, 0x2f, 0x30, 0x37, 0x00};
            short _nScrOfPos21[] = {
                    0x29, 0x2a, 0x31, 0x32, 0x00};
            short _nScrOfPos22[] = {
                    0x2b, 0x2c, 0x33, 0x34, 0x00};
            short _nScrOfPos23[] = {
                    0x2d, 0x2e, 0x35, 0x36, 0x00};

            short _nConstSurStonePos[] = {
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    1, 1, 1, 1, 1, 1, 1, 1,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
            /*short _pnScreeningPoint[][] = {
                m_Engine.nScrOfPos0, m_Engine.nScrOfPos1,
                m_Engine.nScrOfPos2, m_Engine.nScrOfPos3,
                m_Engine.nScrOfPos4, m_Engine.nScrOfPos5,
                m_Engine.nScrOfPos6, m_Engine.nScrOfPos7,
                m_Engine.nScrOfPos8, m_Engine.nScrOfPos9,
                m_Engine.nScrOfPosa, m_Engine.nScrOfPosb,
                m_Engine.nScrOfPosc, m_Engine.nScrOfPosd,
                m_Engine.nScrOfPose, m_Engine.nScrOfPosf,
                m_Engine.nScrOfPos10, m_Engine.nScrOfPos11,
                m_Engine.nScrOfPos12, m_Engine.nScrOfPos13,
                m_Engine.nScrOfPos14, m_Engine.nScrOfPos15,
                m_Engine.nScrOfPos16,
                m_Engine.nScrOfPos17, m_Engine.nScrOfPos18,
                m_Engine.nScrOfPos19, m_Engine.nScrOfPos1a,
                m_Engine.nScrOfPos1b, m_Engine.nScrOfPos1c,
                m_Engine.nScrOfPos1d,
                m_Engine.nScrOfPos1e, m_Engine.nScrOfPos1f,
                m_Engine.nScrOfPos20, m_Engine.nScrOfPos21,
                m_Engine.nScrOfPos22, m_Engine.nScrOfPos23};*/
            short _pnScreeningPoint[][] = {
                    _nScrOfPos0, _nScrOfPos1,
                    _nScrOfPos2, _nScrOfPos3,
                    _nScrOfPos4, _nScrOfPos5,
                    _nScrOfPos6, _nScrOfPos7,
                    _nScrOfPos8, _nScrOfPos9,
                    _nScrOfPosa, _nScrOfPosb,
                    _nScrOfPosc, _nScrOfPosd,
                    _nScrOfPose, _nScrOfPosf,
                    _nScrOfPos10, _nScrOfPos11,
                    _nScrOfPos12, _nScrOfPos13,
                    _nScrOfPos14, _nScrOfPos15,
                    _nScrOfPos16,
                    _nScrOfPos17, _nScrOfPos18,
                    _nScrOfPos19, _nScrOfPos1a,
                    _nScrOfPos1b, _nScrOfPos1c,
                    _nScrOfPos1d,
                    _nScrOfPos1e, _nScrOfPos1f,
                    _nScrOfPos20, _nScrOfPos21,
                    _nScrOfPos22, _nScrOfPos23};

            short _ConstStoneBoard[] = new short[] { //[421] =
                    -16, -16, -16, -16, -16, -16, -16, -16, -16, -16,
                    -16, -16, -16, -16, -16, -16, -16, -16, -16, -16,
                    -16, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
                    -2, -2, -2, -2, -2,
                    -16, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                    -1, -1, -1, -1, -2,
                    -16, -2, -1, 0x0e, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
                    0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0e, 0x0e, -1, -2,
                    -16, -2, -1, 0x0e, 0x0e, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                    0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0e, 0x0e, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0c, 0x0b, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
                    0x04, 0x04, 0x04, 0x04, 0x04, 0x0b, 0x0c, -1, -2,
                    -16, -2, -1, 0x0e, 0x0e, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                    0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0e, 0x0e, -1, -2,
                    -16, -2, -1, 0x0e, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
                    0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0e, 0x0e, -1, -2,
                    -16, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                    -1, -1, -1, -1, -2,
                    -16, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
                    -2, -2, -2, -2, -2,
                    -16, -16, -16, -16, -16, -16, -16, -16, -16, -16,
                    -16, -16, -16, -16, -16, -16, -16, -16, -16, -16,
                    -16
            };

            byte _byG_BCBoard[] = new byte[] { //[421] =
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1,
                    (byte) - 16, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2,
                    (byte) - 16, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2,
                    (byte) - 16, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16
            };

            byte _byStandardBoard1[] = new byte[] { //[421] =
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16, (byte) - 16, (byte) - 16,
                    (byte) - 16
            };
            byte _byStandardWeightBoard[] = new byte[] { //[421] =

                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff, (byte) 0xff, (byte) 0xff,
                    (byte) 0xff
            };

            byte _cAroundTable[] = new byte[] { //[56] =
                /*L1*/ -1, /*U1*/ -20, /*R1*/ 1, /*D1*/ 20,
                /*L1D1*/19, /*L1U1*/ -21, /*R1U1*/ -19, /*R1D1*/ 21,
                /*L2*/-2, /*U2*/ -40, /*R2*/ 2, /*D2*/ 40,
                /*L2D1*/18, /*L2U1*/ -22, /*L1U2*/ -41, /*R1U2*/ -39,
                /*R2U1*/-18, /*R2D1*/ 22, /*R1D2*/ 41, /*L1D2*/ 39,
                /*L3*/-3, /*U3*/ -60, /*R3*/ 3, /*D3*/ 60,
                /*L3D1*/17, /*L3U1*/ -23, /*L1U3*/ -61, /*R1U3*/ -59,
                /*R3U1*/-17, /*R3D1*/ 23, /*R1D3*/ 61, /*L1D3*/ 59,
                /*L2D2*/38, /*L2U2*/ -42, /*R2U2*/ -38, /*R2D2*/ 42,
                /*L4*/-4, /*U4*/ -80, /*R4*/ 4, /*D4*/ 80,
                /*L4D1*/16, /*L4U1*/ -24, /*L1U4*/ -81, /*R1U4*/ -79,
                /*R4U1*/-16, /*R4D1*/ 24, /*R1D4*/ 81, /*L1D4*/ 79,
                /*L3D2*/37, /*L3U2*/ -43, /*L2U3*/ -62, /*R2U3*/ -58,
                /*R3U2*/-37, /*R3D2*/ 43, /*R2D3*/ 62, /*L2D3*/ 58
            };

            short _nAroundL1[] = {
                    L1, U1, R1, D1};
            short _nAroundL2[] = {
                    L2, U2, R2, D2};
            short _nAroundL3[] = {
                    L3, U3, R3, D3};
            short _nAroundL1D1[] = {
                    L1D1, L1U1, R1U1, R1D1};
            short _nAroundL2D2[] = {
                    L2D2, L2U2, R2U2, R2D2};
            short _nAroundR1U2[] = {
                    R1U2, R2D1, L1D2, L2U1};
            short _nAroundL1U2[] = {
                    L1U2, R2U1, R1D2, L2D1};

            m_Engine.MulValue = _MulValue;
            m_Engine.m_wGIniStonePos = _wGIniStonePos;
            m_Engine.nNeighbor = _nNeighbor;
            m_Engine.nStatusOrder = _nStatusOrder;
            m_Engine.nScrOfPos0 = _nScrOfPos0;
            m_Engine.nScrOfPos1 = _nScrOfPos1;
            m_Engine.nScrOfPos2 = _nScrOfPos2;
            m_Engine.nScrOfPos3 = _nScrOfPos3;
            m_Engine.nScrOfPos4 = _nScrOfPos4;
            m_Engine.nScrOfPos5 = _nScrOfPos5;
            m_Engine.nScrOfPos6 = _nScrOfPos6;
            m_Engine.nScrOfPos7 = _nScrOfPos7;
            m_Engine.nScrOfPos8 = _nScrOfPos8;
            m_Engine.nScrOfPos9 = _nScrOfPos9;
            m_Engine.nScrOfPosa = _nScrOfPosa;
            m_Engine.nScrOfPosb = _nScrOfPosb;
            m_Engine.nScrOfPosc = _nScrOfPosc;
            m_Engine.nScrOfPosd = _nScrOfPosd;
            m_Engine.nScrOfPose = _nScrOfPose;
            m_Engine.nScrOfPosf = _nScrOfPosf;
            m_Engine.nScrOfPos10 = _nScrOfPos10;
            m_Engine.nScrOfPos11 = _nScrOfPos11;
            m_Engine.nScrOfPos12 = _nScrOfPos12;
            m_Engine.nScrOfPos13 = _nScrOfPos13;
            m_Engine.nScrOfPos14 = _nScrOfPos14;
            m_Engine.nScrOfPos15 = _nScrOfPos15;
            m_Engine.nScrOfPos16 = _nScrOfPos16;
            m_Engine.nScrOfPos17 = _nScrOfPos17;
            m_Engine.nScrOfPos18 = _nScrOfPos18;
            m_Engine.nScrOfPos19 = _nScrOfPos19;
            m_Engine.nScrOfPos1a = _nScrOfPos1a;
            m_Engine.nScrOfPos1b = _nScrOfPos1b;
            m_Engine.nScrOfPos1c = _nScrOfPos1c;
            m_Engine.nScrOfPos1d = _nScrOfPos1d;
            m_Engine.nScrOfPos1e = _nScrOfPos1e;
            m_Engine.nScrOfPos1f = _nScrOfPos1f;
            m_Engine.nScrOfPos20 = _nScrOfPos20;
            m_Engine.nScrOfPos21 = _nScrOfPos21;
            m_Engine.nScrOfPos22 = _nScrOfPos22;
            m_Engine.nScrOfPos23 = _nScrOfPos23;

            m_Engine.nConstSurStonePos = _nConstSurStonePos;
            m_Engine.pnScreeningPoint = _pnScreeningPoint;
            m_Engine.ConstStoneBoard = _ConstStoneBoard;
            m_Engine.byG_BCBoard = _byG_BCBoard;
            m_Engine.byStandardBoard1 = _byStandardBoard1;
            m_Engine.byStandardWeightBoard = _byStandardWeightBoard;
            m_Engine.m_cAroundTable = _cAroundTable;
            m_Engine.WhereCall = 0xff;

            m_Engine.nAroundL1 = _nAroundL1;
            m_Engine.nAroundL2 = _nAroundL2;
            m_Engine.nAroundL3 = _nAroundL3;
            m_Engine.nAroundL1D1 = _nAroundL1D1;
            m_Engine.nAroundL2D2 = _nAroundL2D2;
            m_Engine.nAroundR1U2 = _nAroundR1U2;
            m_Engine.nAroundL1U2 = _nAroundL1U2;
            m_Engine.nBoardScoreCtrl = 0;
            m_Engine.byStandardBoard = by_StandardBoard;
            m_Engine.AroundPointPosTable = _AroundPointPosTable;
            m_Engine.byInfo6_3 = _byInfo6_3;
            m_Engine.byConstExtPoss = _byConstExtPoss;

            // Additional initializing

            MEMSET(m_Engine.m_byBoard, 0);
            m_Engine.m_nBoardPos = 0;
            m_Engine.m_nDeadPosbufIndex = 0;
            for (int i = 0; i < m_Engine.m_stGroup.length; i++)
                m_Engine.m_stGroup[i] = new GroupRelation();
            for (int i = 0; i < m_Engine.m_stTempGroup.length; i++)
                m_Engine.m_stTempGroup[i] = new GroupRelation();
            for (int i = 0; i < m_Engine.m_stInterrelGroup.length; i++)
                m_Engine.m_stInterrelGroup[i] = new InterrelGroup();

        }
    }

    final short BoardSize19 = 19;
    final short HighLevel = 5;
    void ClassCreat() {
        // Created by LCI ----
//        try {
//            InputConnection ic = (InputConnection) Connector.open("resource:///pattern/pattern.dtd",
//                                                                  Connector.READ, false);
//            DataInputStream dti = ic.openDataInputStream();
//            int pattDataSize = dti.available();
//            m_Engine.m_pPattData = new byte[pattDataSize];
//            dti.readFully(m_Engine.m_pPattData);
//        } catch (IOException e) {
//
//        }
//
        for (int i = 0; i < m_Engine.m_Candi.length; i++) {
            m_Engine.m_Candi[i] = new CANDIDATA();
        }
        // -------------------//
//This is blank function
    }
    /*
        void InitGame(short nBoardSize, short nColor, short iniStones) {
            InitValue();

            Initialize(nBoardSize, nColor, HighLevel, iniStones);
        }
     */
//H.Joon-2007/03/06>>
    void InitGame( short nBoardSize, short nColor )
    {
        InitValue();

        Initialize(nBoardSize, nColor,
                HighLevel, IniStone0);
    }
    //<<
    void InitValue() {
        m_Engine.m_nTurn = IS_BLACK;
        m_Engine.m_nGameStatus = IS_INITIAL;
        m_Engine.m_nStoneCounter = 0;
    }

    void Initialize(short nSize, short nColor, short nLevel,
                    short nCount) {
        short bCenterFlag;
        short i;

        m_Engine.m_nBoardSize = SIZE19;
        if ( (nSize == SIZE13) || (nSize == SIZE9))
            m_Engine.m_nBoardSize = nSize;

        SetComStoneColor(nColor);
        SetGameLevel(nLevel);
        m_Engine.m_nIniStoneCount = nCount;

        SituatInitialize();

        InitStrings();

        InitPattern();
        m_Engine.m_nProGameStatus = IS_GAME;
        m_Engine.m_bIsInControl = false;
        m_Engine.m_bReStart = false;
        m_Engine.m_nStoneCounter = 0;

        bCenterFlag = 0;
        if (m_Engine.m_nBoardSize != SIZE19)
            ConvertInit();

        if (m_Engine.m_nBoardSize == SIZE19) {
            for (i = STARTPOS; i < ENDPOS; i++) {
                if (m_Engine.m_byPosBoard[i] == INITVALUE)
                    continue;
                if ((m_Engine.m_byPosBoard[i] & 0xff) > 5)
                    m_Engine.m_byPosBoard[i] = 5;
                else
                    m_Engine.m_lBitBoard[i] = 0;
            }
        }

        if (m_Engine.m_nIniStoneCount < 2)
            return;
    }

    void SetComStoneColor(short nColor) {
        m_Engine.m_nComStoneColor = nColor;
    }

    void SetGameLevel(short nLevel) {
        m_Engine.m_nGameLevel = nLevel;
        UpdateByLevel();
    }

    void SituatInitialize() {
        short nPos1 = 0, nPos2 = 0, nPos3 = 0, nPos4 = 0, nCase = 0, i, j;
        short nRnd;
        //byte byDest;

        //byDest = (byte) rand();

        nRnd = (short)rand();

        m_Engine.m_nPaePos = 0;
        m_Engine.m_nTotal = 0;
        m_Engine.nEvaluCount = 0;

        m_Engine.m_byGroupCount = 0;
        m_Engine.m_byWhiteGroupCount = 0;
        m_Engine.m_byBlackGroupCount = 0;

        m_Engine.m_nDifOfTerritory = 0;
        m_Engine.m_wWhiteTSize = 0;
        m_Engine.m_wBlackTSize = 0;

        MEMSET(m_Engine.m_byLiberties, 0);
        MEMSET(m_Engine.m_nStoneCount, 0);
        MEMSET(m_Engine.m_wStatus, 0xff00);
        m_Engine.m_wStatus[0] = 0;

        MEMCPY(m_Engine.byStandardBoard, m_Engine.byStandardBoard1, m_Engine.byStandardBoard.length);

        MEMCPY(m_Engine.m_byGroupBoard, m_Engine.byStandardBoard, m_Engine.m_byGroupBoard.length);
        MEMCPY(m_Engine.m_byBoard, m_Engine.byStandardBoard, m_Engine.m_byBoard.length);
        MEMCPY(m_Engine.m_cWeightBoard, m_Engine.byStandardWeightBoard, m_Engine.m_cWeightBoard.length);

        MEMCPY(m_Engine.m_nBlackStoneBoard, m_Engine.ConstStoneBoard, m_Engine.ConstStoneBoard.length);
        MEMCPY(m_Engine.m_nWhiteStoneBoard, m_Engine.ConstStoneBoard, m_Engine.ConstStoneBoard.length);

        MEMSET(m_Engine.m_byExpressBoard, 0);

        nCase = (short) (nRnd & 3);

        switch (nCase) {
            case 0:
                if ( (nRnd & 4) != 0) {
                    if ( (nRnd & 8) != 0)
                        nPos1 = 84;
                    else
                        nPos1 = 63;
                } else if ( (nRnd & 8) != 0)
                    nPos1 = 64;
                else
                    nPos1 = 83;

                if ( (nRnd & 0x10) != 0) {
                    if ( (nRnd & 0x20) != 0) {
                        nPos2 = 96;
                        nPos3 = 324;
                        nPos4 = 336;
                    } else {
                        nPos2 = 77;
                        nPos3 = 343;
                        nPos4 = 357;
                    }
                } else if ( (nRnd & 0x20) != 0) {
                    nPos2 = 97;
                    nPos3 = 323;
                    nPos4 = 356;
                } else {
                    nPos2 = 76;
                    nPos3 = 344;
                    nPos4 = 337;
                }

                break;
            case 1:
                if ( (nRnd & 4) != 0) {
                    if ( (nRnd & 8) != 0)
                        nPos1 = 96;
                    else
                        nPos1 = 77;
                } else if ( (nRnd & 8) != 0)
                    nPos1 = 97;
                else
                    nPos1 = 76;

                if ( (nRnd & 0x10) != 0) {
                    if ( (nRnd & 0x20) != 0) {
                        nPos2 = 84;
                        nPos3 = 324;
                        nPos4 = 336;
                    } else {
                        nPos2 = 63;
                        nPos3 = 343;
                        nPos4 = 357;
                    }
                } else if ( (nRnd & 0x20) != 0) {
                    nPos2 = 64;
                    nPos3 = 323;
                    nPos4 = 356;
                } else {
                    nPos2 = 83;
                    nPos3 = 344;
                    nPos4 = 337;
                }

                break;
            case 2:
                if ( (nRnd & 4) != 0) {
                    if ( (nRnd & 8) != 0)
                        nPos1 = 324;
                    else
                        nPos1 = 343;
                } else if ( (nRnd & 8) != 0)
                    nPos1 = 323;
                else
                    nPos1 = 344;

                if ( (nRnd & 0x10) != 0) {
                    if ( (nRnd & 0x20) != 0) {
                        nPos2 = 96;
                        nPos3 = 84;
                        nPos4 = 336;
                    } else {
                        nPos2 = 77;
                        nPos3 = 63;
                        nPos4 = 357;
                    }
                } else if ( (nRnd & 0x20) != 0) {
                    nPos2 = 97;
                    nPos3 = 64;
                    nPos4 = 356;
                } else {
                    nPos2 = 76;
                    nPos3 = 83;
                    nPos4 = 337;
                }

                break;
            case 3:
                if ( (nRnd & 4) != 0) {
                    if ( (nRnd & 8) != 0)
                        nPos1 = 336;
                    else
                        nPos1 = 357;
                } else if ( (nRnd & 8) != 0)
                    nPos1 = 356;
                else
                    nPos1 = 337;

                if ( (nRnd & 0x10) != 0) {
                    if ( (nRnd & 0x20) != 0) {
                        nPos2 = 96;
                        nPos3 = 324;
                        nPos4 = 84;
                    } else {
                        nPos2 = 77;
                        nPos3 = 343;
                        nPos4 = 63;
                    }
                } else if ( (nRnd & 0x20) != 0) {
                    nPos2 = 97;
                    nPos3 = 323;
                    nPos4 = 64;
                } else {
                    nPos2 = 76;
                    nPos3 = 344;
                    nPos4 = 83;
                }

                break;
            default:
                break;
        }

        m_Engine.m_nBlackStoneBoard[nPos1] = m_Engine.m_nWhiteStoneBoard[nPos1] = 0x11;

        if ( (nRnd & 0x40) != 0) {
            m_Engine.m_nBlackStoneBoard[nPos4] = m_Engine.m_nWhiteStoneBoard[nPos4] = 0x10;
            m_Engine.m_nBlackStoneBoard[nPos3] = m_Engine.m_nWhiteStoneBoard[nPos3] = 0xf;
            m_Engine.m_nBlackStoneBoard[nPos2] = m_Engine.m_nWhiteStoneBoard[nPos2] = 0xf;
        } else {
            m_Engine.m_nBlackStoneBoard[nPos4] = m_Engine.m_nWhiteStoneBoard[nPos4] = 0xf;
            m_Engine.m_nBlackStoneBoard[nPos3] = m_Engine.m_nWhiteStoneBoard[nPos3] = 0xf;
            m_Engine.m_nBlackStoneBoard[nPos2] = m_Engine.m_nWhiteStoneBoard[nPos2] = 0x10;
        }

        MEMCPY(m_Engine.m_cAreaBoard, m_Engine.byStandardBoard, m_Engine.m_cAreaBoard.length);

        m_Engine.m_bMoveFlag = false;

        m_Engine.m_nStoneCounter = 0;

        m_Engine.m_bDataUpdate = false;
        m_Engine.m_bLocalPatternUpdate = false;

        MEMSET(m_Engine.m_bySameBuf, 0);
        MEMSET(m_Engine.m_byDifferBuf, 0);

        m_Engine.m_nSCount = 0;
        m_Engine.m_nDCount = 0;

        m_Engine.m_cWhiteCountChange = 0;
        m_Engine.m_cBlackCountChange = 0;

        m_Engine.m_nDifOfTwoT9 = 0;
        m_Engine.m_wWhiteTSize9 = 0;
        m_Engine.m_wBlackTSize9 = 0;
        m_Engine.m_nWhiteTChange = 0;
        m_Engine.m_nBlackTChange = 0;

        m_Engine.m_byNewStringNumber = 0;

        m_Engine.m_nChangedTSize = 0;

        m_Engine.m_nOldDeadCount = 0;

        m_Engine.m_byTurnColor = 0;

        m_Engine.m_nBlackDeadCount = 0;
        m_Engine.m_nWhiteDeadCount = 0;

        MEMSET(m_Engine.m_lBitBoard, 0);
        MEMCPY(m_Engine.m_byPosBoard, m_Engine.byG_BCBoard, m_Engine.m_byPosBoard.length);

        if (m_Engine.m_nBoardSize <= 13) {
            for (i = 1; i < 20; i++)
                for (j = 1; j < 20; j++) {
                    if ( (i <= m_Engine.m_nBoardSize) && (j <= m_Engine.m_nBoardSize)) {
                        m_Engine.m_nBlackStoneBoard[20 * j + i] = m_Engine.m_nWhiteStoneBoard[20 * j + i] = 4;
                        continue;
                    }

                    m_Engine.m_byGroupBoard[20 * j + i] = INITVALUE;
                    m_Engine.m_byBoard[20 * j + i] = INITVALUE;
                    m_Engine.m_cWeightBoard[20 * j + i] = -1;

                    m_Engine.m_byPosBoard[20 * j + i] = INITVALUE;

                    m_Engine.m_nBlackStoneBoard[20 * j + i] = INITVALUE;
                    m_Engine.m_nWhiteStoneBoard[20 * j + i] = INITVALUE;

                    m_Engine.m_cAreaBoard[20 * j + i] = -16;

                    m_Engine.byStandardBoard[20 * j + i] = INITVALUE;
                }
            for (i = 1; i <= m_Engine.m_nBoardSize; i++) {
                m_Engine.m_nBlackStoneBoard[20 + i] = m_Engine.m_nWhiteStoneBoard[20 + i] = -2;
                m_Engine.m_nBlackStoneBoard[20 * m_Engine.m_nBoardSize + i] =
                        m_Engine.m_nWhiteStoneBoard[20 * m_Engine.m_nBoardSize + i] = -2;
                m_Engine.m_nBlackStoneBoard[20 * i + 1] = m_Engine.m_nWhiteStoneBoard[20 * i + 1] = -2;
                m_Engine.m_nBlackStoneBoard[20 * i + m_Engine.m_nBoardSize] =
                        m_Engine.m_nWhiteStoneBoard[20 * i + m_Engine.m_nBoardSize] = -2;
            }
            for (i = 2; i < m_Engine.m_nBoardSize; i++) {
                m_Engine.m_nBlackStoneBoard[20 * 2 + i] = m_Engine.m_nWhiteStoneBoard[20 * 2 + i] = -1;
                m_Engine.m_nBlackStoneBoard[20 * (m_Engine.m_nBoardSize - 1) +
                        i] = m_Engine.m_nWhiteStoneBoard[20 * (m_Engine.m_nBoardSize - 1) + i] = -1;
                m_Engine.m_nBlackStoneBoard[20 * i + 2] = m_Engine.m_nWhiteStoneBoard[20 * i + 2] = -1;
                m_Engine.m_nBlackStoneBoard[20 * i + m_Engine.m_nBoardSize -
                        1] = m_Engine.m_nWhiteStoneBoard[20 * i + m_Engine.m_nBoardSize - 1] = -2;
            }
            for (i = 3; i < m_Engine.m_nBoardSize - 1; i++) {
                m_Engine.m_nBlackStoneBoard[20 * 3 + i] = m_Engine.m_nWhiteStoneBoard[20 * 3 + i] = 0xe;
                m_Engine.m_nBlackStoneBoard[20 * (m_Engine.m_nBoardSize - 2) +
                        i] = m_Engine.m_nWhiteStoneBoard[20 * (m_Engine.m_nBoardSize - 2) + i] = 0xe;
                m_Engine.m_nBlackStoneBoard[20 * i + 3] = m_Engine.m_nWhiteStoneBoard[20 * i + 3] = 0xe;
                m_Engine.m_nBlackStoneBoard[20 * i + m_Engine.m_nBoardSize -
                        2] = m_Engine.m_nWhiteStoneBoard[20 * i + m_Engine.m_nBoardSize - 2] = 0xe;
            }
            if (m_Engine.m_nBoardSize == 13) {
                for (i = 4; i < m_Engine.m_nBoardSize - 2; i++) {
                    m_Engine.m_nBlackStoneBoard[20 * 4 + i] = m_Engine.m_nWhiteStoneBoard[20 * 4 + i] = 0xf;
                    m_Engine.m_nBlackStoneBoard[20 * (m_Engine.m_nBoardSize - 3) + i] =
                            m_Engine.m_nWhiteStoneBoard[20 * (m_Engine.m_nBoardSize - 3) + i] = 0xf;
                    m_Engine.m_nBlackStoneBoard[20 * i + 4] = m_Engine.m_nWhiteStoneBoard[20 * i + 4] = 0xf;
                    m_Engine.m_nBlackStoneBoard[20 * i + m_Engine.m_nBoardSize -
                            3] = m_Engine.m_nWhiteStoneBoard[20 * i + m_Engine.m_nBoardSize - 3] = 0xf;
                }
                m_Engine.m_nBlackStoneBoard[20 * 4 + 4] = m_Engine.m_nWhiteStoneBoard[20 * 4 + 4] = 0x11;
                m_Engine.m_nBlackStoneBoard[20 * (m_Engine.m_nBoardSize - 3) + 4] =
                        m_Engine.m_nWhiteStoneBoard[20 * (m_Engine.m_nBoardSize - 3) + 4] = 0x11;
                m_Engine.m_nBlackStoneBoard[20 * 4 + m_Engine.m_nBoardSize - 3] =
                        m_Engine.m_nWhiteStoneBoard[20 * 4 + m_Engine.m_nBoardSize - 3] = 0x11;
                m_Engine.m_nBlackStoneBoard[20 * (m_Engine.m_nBoardSize - 3) + m_Engine.m_nBoardSize - 3] =
                        m_Engine.m_nWhiteStoneBoard[20 * (m_Engine.m_nBoardSize - 3) + m_Engine.m_nBoardSize - 3] = 0x11;

            } else {
                m_Engine.m_nBlackStoneBoard[20 * 3 + 3] = m_Engine.m_nWhiteStoneBoard[20 * 3 + 3] = 0x11;
                m_Engine.m_nBlackStoneBoard[20 * (m_Engine.m_nBoardSize - 2) + 3] =
                        m_Engine.m_nWhiteStoneBoard[20 * (m_Engine.m_nBoardSize - 2) + 3] = 0x11;
                m_Engine.m_nBlackStoneBoard[20 * 3 + m_Engine.m_nBoardSize - 3] =
                        m_Engine.m_nWhiteStoneBoard[20 * 3 + m_Engine.m_nBoardSize - 2] = 0x11;
                m_Engine.m_nBlackStoneBoard[20 * (m_Engine.m_nBoardSize - 2) + m_Engine.m_nBoardSize - 2] =
                        m_Engine.m_nWhiteStoneBoard[20 * (m_Engine.m_nBoardSize - 2) + m_Engine.m_nBoardSize - 2] = 0x11;
            }
        }
        m_Engine.nBoardScoreCtrl = 0;
    }

    void InitStrings() {
        MEMSET(m_Engine.m_byMarkedBoard, 0);
        MEMSET(m_Engine.m_byLastLibs, 0);
        MEMSET(m_Engine.m_nLastStns, 0);
        m_Engine.m_wSimulEnd = 0;
        UpdateByLevel();
    }

    void InitPattern() {
        short i, j, n;
        byte byTemp;
        short nSurX, nSurY, nX, nY;

        MEMSET(m_Engine.m_byLocalPattern, 0);
        for (i = STARTPOS; i < ENDPOS; i++) {
            if ((m_Engine.m_byPosBoard[i] & 0xff) > 4)
                continue;

            nX = (short) (i % 20 - 1);
            nY = (short) (i / 20 - 1);

            for (j = 0; j < 36; j++) {
                n = (short) (i + m_Engine.m_cAroundTable[j]);

                nSurX = (short) (nX + m_Engine.AroundPointPosTable[j * 2]);
                nSurY = (short) (nY + m_Engine.AroundPointPosTable[j * 2 + 1]);

                if ( (nSurX < 0) || (nSurY < 0) || (nSurX > m_Engine.m_nBoardSize - 1)
                        || (nSurY > m_Engine.m_nBoardSize - 1)) {
                    byTemp = (byte) (3 << ( (j % 4) * 2));
                    m_Engine.m_byLocalPattern[i][j / 4] &= ~byTemp;
                    m_Engine.m_byLocalPattern[i][j / 4] |= byTemp;
                }
            }
        }
    }

    void ConvertInit() {
        short i, j, k, l, m;

        m_Engine.m_byPosBoard[21] = m_Engine.m_byPosBoard[20 * m_Engine.m_nBoardSize + 1] = 1;
        m_Engine.m_byPosBoard[20 + m_Engine.m_nBoardSize] =
                m_Engine.m_byPosBoard[20 * m_Engine.m_nBoardSize + m_Engine.m_nBoardSize] = 1;

        for (i = 1; i < m_Engine.m_nBoardSize - 1; i++) {
            m_Engine.m_byPosBoard[21 + i] = m_Engine.m_byPosBoard[20 * (i + 1) + 1] = 2;
            m_Engine.m_byPosBoard[20 * m_Engine.m_nBoardSize + i + 1] =
                    m_Engine.m_byPosBoard[20 * (i + 1) + m_Engine.m_nBoardSize] = 2;
            m_Engine.m_byPosBoard[41 + i] = m_Engine.m_byPosBoard[20 * (i + 1) + 2] = 3;
            m_Engine.m_byPosBoard[20 * (m_Engine.m_nBoardSize - 1) + i + 1] =
                    m_Engine.m_byPosBoard[20 * (i + 1) + m_Engine.m_nBoardSize - 1] = 3;
        }

        for (i = 2; i < m_Engine.m_nBoardSize - 2; i++)
            for (j = 2; j < m_Engine.m_nBoardSize - 2; j++)
                m_Engine.m_byPosBoard[20 * (j + 1) + i + 1] = 4;

        k = (short) ( (SIZE19 - m_Engine.m_nBoardSize) / 2);
        for (i = l = 0; i < SIZE19; i++, l++) {
            for (j = m = 0; j < SIZE19; j++, m++) {
                //MEMCPY(&(m_Engine.m_byLocalPattern[20*(l+1)+m+1][0]), &(m_Engine.m_byLocalPattern[20*(i+1)+j+1][0]), 9);
                System.arraycopy(m_Engine.m_byLocalPattern[20 * (i + 1) + j + 1], 0,
                        m_Engine.m_byLocalPattern[20 * (l + 1) + m + 1], 0, 9);
                if (j == 2)
                    j += k;
            }
            if (i == 2)
                i += k;
        }
    }

    void UpdateByLevel() {
        m_Engine.m_wMemOfSet = SIMULMEMORYOFONESET;
        m_Engine.m_nDepthCrit = 3;
        m_Engine.m_nMaxSimulPoints = 5;

        if (m_Engine.m_nGameLevel < 2)
        {
            m_Engine.m_wMemOfSet = SIMULMEMORYOFONESET / 5;
            m_Engine.m_nDepthCrit = 1;
            m_Engine.m_nMaxSimulPoints = 1;
        }
        else if (m_Engine.m_nGameLevel < 3)
        {
            m_Engine.m_wMemOfSet = SIMULMEMORYOFONESET * 2 / 5;
            m_Engine.m_nDepthCrit = 1;
            m_Engine.m_nMaxSimulPoints = 2;
        }
        else if (m_Engine.m_nGameLevel < 4)
        {
            m_Engine.m_wMemOfSet = SIMULMEMORYOFONESET * 3 / 5;
            m_Engine.m_nDepthCrit = 2;
            m_Engine.m_nMaxSimulPoints = 3;
        }
        else if( m_Engine.m_nGameLevel < 6 )
        {
            m_Engine.m_wMemOfSet = SIMULMEMORYOFONESET * 4 / 5;
            m_Engine.m_nDepthCrit = 2;
            m_Engine.m_nMaxSimulPoints = 4;
        }

    }

    short PlaceStone(short wPoint, byte nStoneColor) {
        short nRet;

        // by KWJ : commented : 2007-04-19
//        if (m_Engine.m_nProGameStatus == IS_GAMEOVER)
//            return IS_GAMEOVER;

        m_Engine.m_nBoardPos = GetBoardPos(wPoint);

        if (nStoneColor == m_Engine.m_nComStoneColor)
            m_Engine.m_wPreviousComputerStonePos = m_Engine.m_nBoardPos;
        else
            m_Engine.m_wPreviousHumanStonePos = m_Engine.m_nBoardPos;

        if (wPoint == M_PASS) { //pass  proccessing
            if (m_Engine.m_nProGameStatus != IS_PASS)
                m_Engine.m_nProGameStatus = IS_PASS;
            else
                m_Engine.m_nProGameStatus = IS_GAMEOVER;

            m_Engine.m_nPaePos = 0;
            m_Engine.m_nDeadStoneCount = 0;
            CountStones(nStoneColor);
            return IS_PASS;
        } else
            m_Engine.m_nProGameStatus = IS_GAME;

        m_Engine.m_byStrNum = 0;
        if ( (nRet = SetStone2(nStoneColor)) < IS_OK)
            return nRet;

        //OUTPUT("m_byBoard", m_Engine.m_byBoard, 20);

        m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] =
                m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = 0;
        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] = 0;

        CountStones(nStoneColor);

        SetBit0_1();
        MarkInArea();
        ExpressTempArea();
        SaveTempArea();

        if (IsDansu( (short) (m_Engine.m_nBoardPos - 20)) ||
                IsDansu( (short) (m_Engine.m_nBoardPos + 20)) ||
                IsDansu( (short) (m_Engine.m_nBoardPos - 1)) ||
                IsDansu( (short) (m_Engine.m_nBoardPos + 1)))
            return IS_DANSU;

        return IS_OK;
    }

    short GetBoardPos(short wPoint) {
        return (short) ( ((LOBYTE(wPoint) & 0xff) + 1) * 20 + (HIBYTE(wPoint) & 0xff) + 1);
    }

    void CountStones(short nStoneColor) {
        m_Engine.m_nStoneCounter++;
        if (m_Engine.m_nDeadStoneCount != 0) {
            if (nStoneColor == IS_BLACK)
                m_Engine.m_nWhiteDeadCount += m_Engine.m_nDeadStoneCount;
            else
                m_Engine.m_nBlackDeadCount += m_Engine.m_nDeadStoneCount;
        }
    }

    void SetBit0_1() {
        byte byStrNumBuf[] = new byte[5];
        short nLibertiesBuf[] = new short[5];
        byte byStrNum;
        short nCount = 0;
        short i, j;
        short wPosBuf[] = new short[5];

        short nTemp;

        //H.Joon-2007/03/05>>
        for ( i = 0; i < wPosBuf.length; i ++ )
            wPosBuf[i] = 0;
        //<<

//	SAVE_SPOINT;
        nTemp = m_Engine.m_nBoardPos;

        byStrNum = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
        if ( ((m_Engine.m_byLiberties[byStrNum & 0xff] & 0xFF) > 0) &&
                ((m_Engine.m_byLiberties[byStrNum & 0xff] & 0xFF) < 4)) {
            byStrNumBuf[nCount] = byStrNum;
            nLibertiesBuf[nCount++] = (short)(m_Engine.m_byLiberties[byStrNum & 0xff] & 0xff);
        }
        for (i = 0; i < m_Engine.m_nDCount; i++)
            if (((m_Engine.m_byDifferLiberties[i] & 0xff) > 0) &&
                    ((m_Engine.m_byDifferLiberties[i] & 0xff) < 4)) {
                byStrNumBuf[nCount] = m_Engine.m_byDifferBuf[i];
                nLibertiesBuf[nCount++] = (short)(m_Engine.m_byDifferLiberties[i] & 0xff);
            }

        for (i = 0; i < nCount; i++) {
            GetEmptyPos(byStrNumBuf[i], nLibertiesBuf[i], wPosBuf); //?????????
            for (j = 0; j < nLibertiesBuf[i]; j++)
                m_Engine.m_lBitBoard[wPosBuf[j] & 0xffff] |= 1;
        }

//	LOAD_SPOINT;
        m_Engine.m_nBoardPos = nTemp;

        SetBitBoard(m_Engine.m_nBoardPos);

        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 1;

    }

    void MarkInArea() {
        short i, j, m, n, k;
        short nMaxX, nMaxY;

        m = (short) (m_Engine.m_nBoardPos / 20);
        n = (short) (m_Engine.m_nBoardPos % 20);

        if (m_Engine.m_byBoard[201] == INITVALUE)
            k = 9;
        else if (m_Engine.m_byBoard[281] == INITVALUE)
            k = 13;
        else
            k = 19;

        nMaxY = (short) Math.min(m + 2, k);
        nMaxX = (short) Math.min(n + 2, k);

        for (i = (short) Math.max(1, m - 2); i <= nMaxY; i++)
            for (j = (short) Math.max(1, n - 2); j <= nMaxX; j++) {
                m_Engine.m_byMarkedBoard[i * 20 + j] = (byte) 0xff;
            }
    }

    void ExpressTempArea() {
        short i;
        short nSurPos;

        short pbyTempWallPos[] = new short[0x38];

        if ( (m_Engine.m_byNewStringNumber == 0) && (m_Engine.m_bMoveDataFlag == false))
            return;

        //HJ_Debug>>
//        if ( bDebug_print )
//            System.out.println("m_nBoardPos = " + m_Engine.m_nBoardPos);
        //<<
        ExpressWallPos(m_Engine.m_nBoardPos, pbyTempWallPos);

        m_Engine.m_nMainPos = m_Engine.m_nBoardPos;
        if (m_Engine.byStandardBoard[m_Engine.m_nMainPos] != 0)
            return;

        if (m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0) {
            if ( (m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] == -2) ||
                    (m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] == -1))
                m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = 0;
        } else
            m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = -1;

        for (i = 0x13; i >= 0; i--) { //0x23//0x37
            if (pbyTempWallPos[i] == 0xff)
                continue;

            nSurPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[i]);

            if (m_Engine.m_byBoard[nSurPos] != 0) {
                if ( (m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] == -2) ||
                        (m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] == -1))
                    m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = 0;
            } else
                m_Engine.m_cAreaBoard[nSurPos] = -1;

            if (i < 0x24)
                continue;

            TempAreaOR((short) (nSurPos - 1));
            TempAreaOR((short) (nSurPos - 20));
            TempAreaOR((short) (nSurPos + 1));
            TempAreaOR((short) (nSurPos + 20));
        }
        return;
    }

    void SaveTempArea() {
        short i;
        byte cSaved;

        for (i = STARTPOS; i < ENDPOS; i++) {
            if (m_Engine.byStandardBoard[i] != 0)
                continue;
            if ( (cSaved = m_Engine.m_cAreaBoard[i]) != 0) {
                m_Engine.m_cAreaBoard[i] = 0;
                m_Engine.m_cTempAreaBoard[i] |= cSaved;
            }
        }
        m_Engine.m_bMoveFlag = true;
    }

    boolean IsDansu(short nPos) {
        byte byStrNum;

        if (m_Engine.m_byBoard[nPos] == INITVALUE)
            return false;

        byStrNum = m_Engine.m_byBoard[nPos];

        if (byStrNum == 0 || ( ( (byStrNum ^ m_Engine.m_byStoneColor) & 1) == 0))
            return false;
        if (m_Engine.m_byLiberties[byStrNum & 0xff] == 1)
            return true;
        return false;
    }

    short SetStone0() {
        short wStatus[] = new short[1];
        byte byAround = 0;
        byte byTemp;
        short nCount;
        short i, i0;
        short nTpPaePos = m_Engine.m_nPaePos;

        wStatus[0] = (short)(m_Engine.m_byStoneColor & 0xFF);

        m_Engine.m_nBoardPos -= 20;
        if (LookAbout(wStatus)) {
            byAround |= UP_MASK;
            m_Engine.m_byNewLiberties++;
        }

        m_Engine.m_nBoardPos += 40;
        if (LookAbout(wStatus)) {
            byAround |= DOWN_MASK;
            m_Engine.m_byNewLiberties++;
        }

        m_Engine.m_nBoardPos -= 21;
        if (LookAbout(wStatus)) {
            byAround |= LEFT_MASK;
            m_Engine.m_byNewLiberties++;
        }

        m_Engine.m_nBoardPos += 2;
        if (LookAbout(wStatus)) {
            byAround |= RIGHT_MASK;
            m_Engine.m_byNewLiberties++;
        }
        m_Engine.m_nBoardPos--;

        m_Engine.m_nDeadStoneCount = 0;

        i = m_Engine.m_nDCount;

        while (--i >= 0) {
            m_Engine.m_byNewStringNumber = m_Engine.m_byDifferBuf[i];
            nCount = (short)(m_Engine.m_byDifferLiberties[i] & 0xff);
            if (nCount == 0)
                DeadStringProc();
            else if (m_Engine.m_bDataUpdate)
                m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff] = (byte) nCount;
        }

        if (m_Engine.m_nSCount == 0) {
            if (m_Engine.m_nDeadStoneCount != 1)
                m_Engine.m_nPaePos = 0;
            if (m_Engine.m_byNewLiberties != 0) {
                if (m_Engine.m_byNewLiberties != 1)
                    m_Engine.m_nPaePos = 0;
                m_Engine.m_byNewStringNumber = m_Engine.m_byStoneColor;

                while (true) {
                    if ((m_Engine.m_byNewStringNumber & 0xff) >= MAX_STRINGCOUNT)
                        return IS_COUNTOVER;
                    if (m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff] == 0)
                        break;
                    m_Engine.m_byNewStringNumber += 2;
                }
                if (m_Engine.m_bDataUpdate) {
                    m_Engine.m_nStoneCount[m_Engine.m_byNewStringNumber & 0xff] = 1;
                    m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff] = m_Engine.m_byNewLiberties;
                    m_Engine.m_byBoard[m_Engine.m_nBoardPos] = m_Engine.m_byNewStringNumber;
                }

                if (m_Engine.m_bLocalPatternUpdate)
                    SetStoneForPattern();
                return (IS_OK);
            }
            //\uFFFDE\uFFFD\uFFFD\uFFFDEEEE\uFFFD \uFFFD@ 0 EE\uFFFDoEEEE \uFFFDo\uFFFD\uFFFD
            if (m_Engine.m_bDataUpdate) {
                i = m_Engine.m_nDCount;
                while (i > 0) {
                    --i;
                    m_Engine.m_byNewStringNumber = m_Engine.m_byDifferBuf[i];
                    ++m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff];
                }
            }
            m_Engine.m_nPaePos = nTpPaePos;
            m_Engine.m_byNewStringNumber = 0;
            return (IS_NOTPLACE);
        }

        m_Engine.m_nPaePos = 0;
        if (m_Engine.m_nSCount == 1) {
            m_Engine.m_byNewStringNumber = m_Engine.m_bySameBuf[0];

            if (m_Engine.m_bDataUpdate)
                m_Engine.m_byNewLiberties += m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff] - 1;
            else
                m_Engine.m_byNewLiberties += m_Engine.m_bySameLiberties[0] - 1;

            if (m_Engine.m_byNewLiberties == 0) { //\uFFFDE\uFFFD\uFFFD\uFFFDEEEE\uFFFD \uFFFD@ 0 EE\uFFFDoEEEE \uFFFDo\uFFFD\uFFFD
                if (m_Engine.m_bDataUpdate) {
                    i = m_Engine.m_nDCount;
                    while (i > 0) {
                        --i;
                        m_Engine.m_byNewStringNumber = m_Engine.m_byDifferBuf[i];
                        ++m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff];
                    }
                }

                m_Engine.m_nPaePos = nTpPaePos;
                m_Engine.m_byNewStringNumber = 0;
                return (IS_NOTPLACE);
            }
            UpdateLiberties(byAround);
            if (m_Engine.m_bDataUpdate) {
                ++m_Engine.m_nStoneCount[m_Engine.m_byNewStringNumber & 0xff];
                m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff] = m_Engine.m_byNewLiberties;
                m_Engine.m_byBoard[m_Engine.m_nBoardPos] = m_Engine.m_byNewStringNumber;
            }
            if (m_Engine.m_bLocalPatternUpdate)
                SetStoneForPattern();
            return (IS_OK);
        }
        // \uFFFDE\uFFFD\uFFFD\uFFFDTEEEE \uFFFDNEE\uFFFD`\uFFFDI\uFFFDE\uFFFD\uFFFDEE \uFFFDE\uFFFD\uFFFD\uFFFD@ 2EE\uFFFDE\uFFFDVEE \uFFFDo\uFFFD\uFFFD

        // \uFFFDNEE\uFFFD` string\uFFFDKEE \uFFFDE\uFFFD\uFFFD\uFFFDEEEE\uFFFD\uFFFDKEE \uFFFDE\uFFFDEEE.
        for (i = 0; i < m_Engine.m_nSCount; i++) {
            m_Engine.m_byNewLiberties += m_Engine.m_bySameLiberties[i];
            m_Engine.m_byNewLiberties--;
        }

        m_Engine.m_byNewStringNumber = m_Engine.m_bySameBuf[0];
        if (m_Engine.m_byNewLiberties == 0) { //\uFFFDE\uFFFD\uFFFD\uFFFDEEEE\uFFFD \uFFFD@ 0 EE\uFFFDoEEEE \uFFFDo\uFFFD\uFFFD
            if (m_Engine.m_bDataUpdate) {
                i = m_Engine.m_nDCount;
                while (i > 0) {
                    --i;
                    m_Engine.m_byNewStringNumber = m_Engine.m_byDifferBuf[i];
                    ++m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff];
                }
            }

            m_Engine.m_nPaePos = nTpPaePos;
            m_Engine.m_byNewStringNumber = 0;
            return (IS_NOTPLACE);
        }

        if (m_Engine.m_bDataUpdate) {
            m_Engine.m_byBoard[m_Engine.m_nBoardPos] = m_Engine.m_byNewStringNumber;
            //\uFFFDE\uFFFD\uFFFD\uFFFDTEEEE \uFFFDNEE\uFFFD`\uFFFD\uFFFD\uFFFDKEE \uFFFD\uFFFDEE\uFFFD\uFFFD \uFFFDI\uFFFDE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDEEE \uFFFDE\uFFFDE\uFFFDE. \uFFFDI\uFFFDE\uFFFD\uFFFDEE \uFFFD\uFFFD\uFFFDx\uFFFDEEz\uFFFDE
            //\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDEE\uFFFD\uFFFDI\uFFFDE\uFFFD\uFFFD\uFFFDKEE\uFFFDE\uFFFDk\uFFFD\uFFFD\uFFFD\uFFFD, \uFFFDE\uFFFDM\uFFFD\uFFFD\uFFFDEEEE\uFFFD,\uFFFDE\uFFFDE\uFFFDA\uFFFD@\uFFFDI\uFFFDKEE \uFFFD|\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDEEE.
            i = m_Engine.m_nSCount;

            while (--i > 0) {
                byTemp = m_Engine.m_bySameBuf[i];
                for (i0 = 21; i0 < 400; i0++) {
                    if (m_Engine.m_byBoard[i0] == byTemp)
                        m_Engine.m_byBoard[i0] = m_Engine.m_byNewStringNumber;
                }
                m_Engine.m_nStoneCount[m_Engine.m_byNewStringNumber & 0xff] += m_Engine.m_nStoneCount[byTemp & 0xff];
                m_Engine.m_nStoneCount[byTemp & 0xff] = 0;
                m_Engine.m_byLiberties[byTemp & 0xff] = 0;
                m_Engine.m_wStatus[byTemp & 0xff] = (short) 0xff00;
            }
            m_Engine.m_byNewLiberties = (byte) CalcLiberties();
            m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff] = m_Engine.m_byNewLiberties;
            ++m_Engine.m_nStoneCount[m_Engine.m_byNewStringNumber & 0xff];
        } else
            CalcSimulLiberties();

        if (m_Engine.m_bLocalPatternUpdate)
            SetStoneForPattern();
        return (IS_OK);
    }

    short SetStone1(byte byStoneColor) {
        short nRet;

        m_Engine.m_bDataUpdate = false;
        m_Engine.m_bLocalPatternUpdate = false;
        nRet = CheckSettable();
        if (nRet == IS_OK) {
            m_Engine.m_byStoneColor = byStoneColor;
            return (SetStone0());
        }
        return (nRet);
    }

    short SetStone2(byte byStoneColor) {
        short nRet;

        m_Engine.m_bDataUpdate = true;
        m_Engine.m_bLocalPatternUpdate = true;
        nRet = CheckSettable();
        if (nRet == IS_OK) {
            m_Engine.m_byStoneColor = byStoneColor;
            return (SetStone0());
        }
        return (nRet);
    }

    short CheckSettable() {
        m_Engine.m_nSCount = 0;
        m_Engine.m_nDCount = 0;
        m_Engine.m_byNewLiberties = 0;

        if (m_Engine.m_nBoardPos > 421 || m_Engine.m_byBoard[m_Engine.m_nBoardPos] == INITVALUE)
            return IS_OUTBOARD;
        if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] != 0)
            return IS_PRESTONE;
        if (m_Engine.m_nPaePos == m_Engine.m_nBoardPos)
            return IS_PAEPOS;
        return IS_OK;
    }

    boolean LookAbout(short[] pwStatus) {
        short wStatus;
        byte byTemp1;
        byte byTemp2;
        short nLiberties;
        short i;
        byte byStringNumber;
        boolean bRet = true;

        try {
            try { // This try statement is need, because BREW allow array bound exceptions.
                // This time BREW returns 0 for array element. ex:arr[-10] = 0;
                if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == INITVALUE)
                    return false;
                byStringNumber = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
                if (byStringNumber == 0)
                    return true;
            } catch (ArrayIndexOutOfBoundsException e) {
                return true;
            }
            nLiberties = (short)(m_Engine.m_byLiberties[byStringNumber & 0xff] & 0xff);

            if (((byStringNumber ^ m_Engine.m_byStoneColor) & 1) == 0) {
                i = m_Engine.m_nSCount;
                while (i > 0) {
                    i--;
                    if (m_Engine.m_bySameBuf[i] == byStringNumber)
                        return false;
                }
                do {
                    if ((byStringNumber & 0xff) == m_Engine.m_byStrNum)
                        pwStatus[0] = (short) 0xffff;
                    else {
                        if ((pwStatus[0] & 8) != 0)
                            break;

                        wStatus = m_Engine.m_wStatus[byStringNumber & 0xff];

                        if ( ( (wStatus & 8) == 0) && ((pwStatus[0] & 0xffff) >= (wStatus & 0xffff)))
                            break;
                        pwStatus[0] = wStatus;
                    }

                    if (m_Engine.m_nSCount != 0) {
                        byTemp1 = m_Engine.m_bySameBuf[0];
                        byTemp2 = m_Engine.m_bySameLiberties[0];
                        m_Engine.m_bySameBuf[0] = byStringNumber;
                        m_Engine.m_bySameLiberties[0] = (byte) nLiberties;
                        byStringNumber = byTemp1;
                        nLiberties = byTemp2;
                    }
                } while (false);
                m_Engine.m_bySameBuf[m_Engine.m_nSCount] = byStringNumber;
                m_Engine.m_bySameLiberties[m_Engine.m_nSCount] = (byte) nLiberties;
                ++ (m_Engine.m_nSCount);
                return false;
            }

            bRet = false;
            --nLiberties;
            if (nLiberties == 0)
                bRet = true;

            i = m_Engine.m_nDCount;
            while (i > 0) {
                i--;
                if (m_Engine.m_byDifferBuf[i] == byStringNumber)
                    return bRet;
            }

            m_Engine.m_byDifferBuf[m_Engine.m_nDCount] = byStringNumber;
            m_Engine.m_byDifferLiberties[m_Engine.m_nDCount] = (byte) nLiberties;
            ++ (m_Engine.m_nDCount);
        } catch (Exception e) {
            //System.out.println("m_Engine.m_nBoardPos : " + m_Engine.m_nBoardPos);
            //e.printStackTrace();
            return false;
        }
        return bRet;
    }

    void DeadStringProc() {
        int nTemp = m_Engine.m_nBoardPos;

        for (m_Engine.m_nBoardPos = 21; m_Engine.m_nBoardPos < 400; m_Engine.m_nBoardPos++) {
            if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] != m_Engine.m_byNewStringNumber)
                continue;

            m_Engine.m_nPaePos = m_Engine.m_nBoardPos;
            if (m_Engine.m_bDataUpdate) {
                m_Engine.m_byBoard[m_Engine.m_nBoardPos] = 0;
                if (m_Engine.m_bLocalPatternUpdate) {
                    ExpressTempArea();
                    DelStoneForPattern();
                    m_Engine.m_nDeadStonePosBuf[m_Engine.m_nDeadStoneCount] = m_Engine.m_nPaePos;
                    //m_Engine.m_nDeadPosbufIndex++;
                }
            }
            ++m_Engine.m_nDeadStoneCount;

            UpdateNeighbouringString(m_Engine.m_byNewStringNumber);
        }

        if (m_Engine.m_bDataUpdate) {
            m_Engine.m_nStoneCount[m_Engine.m_byNewStringNumber & 0xff] = 0;
            m_Engine.m_byLiberties[m_Engine.m_byNewStringNumber & 0xff] = 0;
            m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xff] = (short) 0xff00;
        }

        m_Engine.m_nBoardPos = (short) nTemp;
    }

    void SetStoneForPattern() {
        short nAroundPos;
        byte byTemp;

        short nSurX, nSurY, nX = 0, nY = 0, nIndex;
        boolean bFlag = false;

        for (nIndex = 0; nIndex < 36; nIndex++) { //36
            if (bFlag) {
                nSurX = (short) (nX - m_Engine.AroundPointPosTable[nIndex * 2]);
                nSurY = (short) (nY - m_Engine.AroundPointPosTable[nIndex * 2 + 1]);

                if ( (nSurX < 0) || (nSurY < 0) || (nSurX > m_Engine.m_nBoardSize - 1)
                        || (nSurY > m_Engine.m_nBoardSize - 1))
                    continue;
                else
                    nAroundPos = (short) (m_Engine.m_nBoardPos - m_Engine.m_cAroundTable[nIndex]);
            } else {
                nAroundPos = (short) (m_Engine.m_nBoardPos - m_Engine.m_cAroundTable[nIndex]);

                if (m_Engine.m_byBoard[nAroundPos] == INITVALUE) {
                    bFlag = true;
                    nX = (short) (m_Engine.m_nBoardPos % 20 - 1);
                    nY = (short) (m_Engine.m_nBoardPos / 20 - 1);
                    continue;
                }
            }

            byTemp = (byte) (3 << ( (nIndex % 4) * 2));
            m_Engine.m_byLocalPattern[nAroundPos][nIndex / 4] &= ~byTemp;
            m_Engine.m_byLocalPattern[nAroundPos][nIndex / 4] |=
                    (m_Engine.m_byStoneColor << ((nIndex % 4) * 2));
        }
    }

    void UpdateLiberties(byte byAround) {
        if ( (byAround & UP_MASK) != 0) {
            m_Engine.m_nBoardPos -= 20;
            if (IsSameString(m_Engine.m_byNewStringNumber))
                --m_Engine.m_byNewLiberties;
            m_Engine.m_nBoardPos += 20;
        }
        if ( (byAround & DOWN_MASK) != 0) {
            m_Engine.m_nBoardPos += 20;
            if (IsSameString(m_Engine.m_byNewStringNumber))
                --m_Engine.m_byNewLiberties;
            m_Engine.m_nBoardPos -= 20;
        }
        if ( (byAround & LEFT_MASK) != 0) {
            --m_Engine.m_nBoardPos;
            if (IsSameString(m_Engine.m_byNewStringNumber))
                --m_Engine.m_byNewLiberties;
            ++m_Engine.m_nBoardPos;
        }
        if ( (byAround & RIGHT_MASK) != 0) {
            ++m_Engine.m_nBoardPos;
            if (IsSameString(m_Engine.m_byNewStringNumber))
                --m_Engine.m_byNewLiberties;
            --m_Engine.m_nBoardPos;
        }
    }

    short CalcLiberties() {
        short nCount = 0;
        short nTemp;

        nTemp = m_Engine.m_nBoardPos;

        for (m_Engine.m_nBoardPos = STARTPOS; m_Engine.m_nBoardPos < ENDPOS; m_Engine.m_nBoardPos++) {
            if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == 0
                    && IsSameString(m_Engine.m_byNewStringNumber))
                ++nCount;
        }
        m_Engine.m_nBoardPos = nTemp;

        return nCount;
    }

    void CalcSimulLiberties() {
        short i, nTemp;
        m_Engine.m_byNewLiberties = 0;

        nTemp = m_Engine.m_nBoardPos;
        m_Engine.m_byBoard[m_Engine.m_nBoardPos] = m_Engine.m_bySameBuf[0];

        for (m_Engine.m_nBoardPos = 21; m_Engine.m_nBoardPos < 400; m_Engine.m_nBoardPos++) {
            if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == INITVALUE)
                continue;
            if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == 0) {
                for (i = 0; i < m_Engine.m_nSCount; i++)
                    if (IsSameString(m_Engine.m_bySameBuf[i])) {
                        m_Engine.m_byNewLiberties++;
                        break;
                    }
                continue;
            }
            if (m_Engine.m_nDeadStoneCount == 0)
                continue;

            if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == m_Engine.m_byStoneColor)
                continue;

            i = m_Engine.m_nDCount;
            do {
                --i;
                if (i < 0)
                    break;
            } while (m_Engine.m_byBoard[m_Engine.m_nBoardPos] != m_Engine.m_byDifferBuf[i]);

            if ( (i < 0) || (m_Engine.m_byDifferLiberties[i] != 0))
                continue;

            for (i = 0; i < m_Engine.m_nSCount; i++)
                if (IsSameString(m_Engine.m_bySameBuf[i])) {
                    m_Engine.m_byNewLiberties++;
                    break;
                }
        }

        m_Engine.m_nBoardPos = nTemp;
        m_Engine.m_byBoard[m_Engine.m_nBoardPos] = 0;
    }

    void SetBitBoard(short nBoardPos) {
        short nSurX, nSurY, nX = 0, nY = 0, nAroundPos;
        short i;
        boolean bFlag = false;

        for (i = 0; i < 0x14; i++) { //0x24//0x30
            if (bFlag) {
                nSurX = (short) (nX + (short) m_Engine.AroundPointPosTable[i * 2]);
                nSurY = (short) (nY + (short) m_Engine.AroundPointPosTable[i * 2 + 1]);

                if ( (nSurX < 0) || (nSurY < 0) || (nSurX > m_Engine.m_nBoardSize - 1)
                        || (nSurY > m_Engine.m_nBoardSize - 1))
                    continue;
                else
                    nAroundPos = (short) (nBoardPos + m_Engine.m_cAroundTable[i]);
            } else {
                nAroundPos = (short) (nBoardPos + m_Engine.m_cAroundTable[i]);

                if (m_Engine.m_byBoard[nAroundPos] == INITVALUE) {
                    bFlag = true;
                    nX = (short) (nBoardPos % 20 - 1);
                    nY = (short) (nBoardPos / 20 - 1);
                    continue;
                }
            }

            if (m_Engine.m_byBoard[nAroundPos] == 0)
                m_Engine.m_lBitBoard[nAroundPos] |= 1;
            else
                m_Engine.m_lBitBoard[nAroundPos] &= 0xff00;
        }
    }

    short GetEmptyPos(short byStrNber, short nMaxSEPs, short[] pwSEP) {
        int index = 0;
        short nCount = 0;

        nMaxSEPs = (short) Math.min(nMaxSEPs, 8); //define MAXSEPS 8

        for (m_Engine.m_nBoardPos = STARTPOS; m_Engine.m_nBoardPos < ENDPOS; m_Engine.m_nBoardPos++) {
            if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == INITVALUE)
                continue;
            if ( (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == 0) &&
                    (IsSameString( (byte) byStrNber) == true)) {
                pwSEP[index] = m_Engine.m_nBoardPos;
                index++;
                nCount++;
                if (nCount >= nMaxSEPs)
                    return nCount;
            }
        }

        return nCount;
    }

    boolean IsSameString(byte byStringNumber) {
        if (m_Engine.m_byBoard[m_Engine.m_nBoardPos - 20] == byStringNumber
                || m_Engine.m_byBoard[m_Engine.m_nBoardPos + 20] == byStringNumber
                || m_Engine.m_byBoard[m_Engine.m_nBoardPos - 1] == byStringNumber
                || m_Engine.m_byBoard[m_Engine.m_nBoardPos + 1] == byStringNumber)
            return true;
        return false;
    }

    void ExpressWallPos(short nPos, short[] pbyTempWallPos) {
        short i;
        short nSurX, nSurY, nX = 0, nY = 0, nSurPos;
        boolean bFlag = false;

        nX = (short) (nPos % 20 - 1);
        nY = (short) (nPos / 20 - 1);

        for (i = 0; i < 0x38; i++) { //0x38
            if (bFlag) {
                nSurX = (short) (nX + m_Engine.AroundPointPosTable[i * 2]);
                nSurY = (short) (nY + m_Engine.AroundPointPosTable[i * 2 + 1]);

                if ( (nSurX < 0) || (nSurY < 0) || (nSurX > (m_Engine.m_nBoardSize - 1))
                        || (nSurY > (m_Engine.m_nBoardSize - 1)))
                    pbyTempWallPos[i] = 0xFF;
                else
                    pbyTempWallPos[i] = 0;
            } else {
                nSurPos = (short) (nPos + m_Engine.m_cAroundTable[i]);

                //HJ_Debug>>
//                if ( bDebug_print )
//                    System.out.println("nSurPos = " + nSurPos);
                //<<
                if (m_Engine.m_byBoard[nSurPos] == INITVALUE) {
                    bFlag = true;
                    nX = (short) (nPos % 20 - 1);
                    nY = (short) (nPos / 20 - 1);
                    pbyTempWallPos[i] = 0xFF;
                } else
                    pbyTempWallPos[i] = 0;
            }
        }
        return;
    }

    void DelStoneForPattern() {
        short nAroundPos;
        byte byTemp, nIndex;

//	assert( m_Engine.m_byBoard[m_Engine.m_nBoardPos] != INITVALUE );
//	assert( 20 < m_Engine.m_nBoardPos && m_Engine.m_nBoardPos < 400 );

        short nSurX, nSurY, nX = 0, nY = 0;
        boolean nFlag = false;

//        for (nIndex = 0; nIndex < 0x14; nIndex++) { //36
        for (nIndex = 0; nIndex < 36; nIndex++) { //36
            if (nFlag) {
                nSurX = (short) (nX - m_Engine.AroundPointPosTable[nIndex * 2]);
                nSurY = (short) (nY - m_Engine.AroundPointPosTable[nIndex * 2 + 1]);

                if ( (nSurX < 0) || (nSurY < 0) || (nSurX > m_Engine.m_nBoardSize - 1)
                        || (nSurY > m_Engine.m_nBoardSize - 1))
                    continue;
                else
                    nAroundPos = (short) (m_Engine.m_nBoardPos - m_Engine.m_cAroundTable[nIndex]);
            } else {
                nAroundPos = (short) (m_Engine.m_nBoardPos - m_Engine.m_cAroundTable[nIndex]);

                if (m_Engine.m_byBoard[nAroundPos] == INITVALUE) {
                    nFlag = true;
                    nX = (short) (m_Engine.m_nBoardPos % 20 - 1);
                    nY = (short) (m_Engine.m_nBoardPos / 20 - 1);
                    continue;
                }
            }

            byTemp = (byte) (3 << ((nIndex % 4) * 2));
            m_Engine.m_byLocalPattern[nAroundPos][nIndex / 4] &= ~byTemp;
        }
    }

    void UpdateNeighbouringString(byte byDeadStringNumber) {
        short nIndex = 0;
        short nCount; // string\uFFFDKEE \uFFFDE\uFFFD\uFFFD.
        byte byStringNumber = 0;
        byte byStringBuf[] = new byte[4];
        short i, i0;

        for (i = 0; i < 4; i++) {
            switch (i) {
                case 0:
                    byStringNumber = m_Engine.m_byBoard[m_Engine.m_nBoardPos - 20];
                    break;
                case 1:
                    byStringNumber = m_Engine.m_byBoard[m_Engine.m_nBoardPos + 20];
                    break;
                case 2:
                    byStringNumber = m_Engine.m_byBoard[m_Engine.m_nBoardPos - 1];
                    break;
                case 3:
                    byStringNumber = m_Engine.m_byBoard[m_Engine.m_nBoardPos + 1];
                    break;
            }
            if (byStringNumber == INITVALUE || byStringNumber == 0
                    || byStringNumber == byDeadStringNumber)
                continue;
            Adr2:do {
                if (m_Engine.m_bDataUpdate) {
                    nCount = 0;
                    do {
                        if (nCount == nIndex) {
                            byStringBuf[nCount] = byStringNumber;
                            ++nIndex;
                            ++m_Engine.m_byLiberties[byStringNumber & 0xff];
                            break;
                        } else {
                            if (byStringBuf[nCount] != byStringNumber)
                                nCount++;
                            else
                                break;
                        }
                    } while (true); //
                } else {
                    i0 = m_Engine.m_nSCount;
                    do {
                        if (--i0 < 0)
                            break Adr2;
                    } while (byStringNumber != m_Engine.m_bySameBuf[i0]);

                    nCount = 0;

                    while (true) {
                        if (nCount == nIndex) {
                            byStringBuf[nCount] = byStringNumber;
                            nIndex++;
                            ++m_Engine.m_bySameLiberties[i0];
                            break Adr2;
                        }
                        if (byStringBuf[nCount] == byStringNumber)
                            break Adr2;
                        nCount++;
                    }
                }
            } while (false);
        }
    }

    //HJ_Debug>>
    //short m_nCallCount = 0;
    //<<

    short FindMove(short nStoneCounter) {
        //HJ_Debug>>
        //m_nCallCount ++;
        //<<

        short i;
        //short[] nTpEyeCount = new short[1];
        short wRet;

        short nSwitch;

        m_Engine.m_bStop = false;
        m_Engine.m_nTotal = 0;

        m_Engine.m_bFindMove = true;

        try{

            if (m_Engine.m_bChangedGameStatus) {
                m_Engine.m_nBoardPos = 0;
                m_Engine.m_nComStonePos = 0;
            } else {
                m_Engine.m_nBoardPos = m_Engine.m_wPreviousHumanStonePos;
                m_Engine.m_nComStonePos = m_Engine.m_wPreviousComputerStonePos;
                if ((m_Engine.m_Candi[1].Prop != (byte) 0xff) &&
                        (m_Engine.m_nComStonePos == m_Engine.m_Candi[1].nPos)) {
                    for (i = 2; i < MAXCANDINUM; i++) {
                        if ((m_Engine.m_Candi[i].Prop != (byte) 0xff) &&
                                (m_Engine.m_nComStonePos == m_Engine.m_Candi[i].nPos) &&
                                (m_Engine.m_nComStoneWeight1 > m_Engine.m_Candi[i].Weight1))
                            break;
                    }
                }
            }

            m_dwTimeStart = System.currentTimeMillis(); // by KWJ : 2007-05-07
            Simulation();

            m_Engine.m_nStoreWeight = 0x25;
            LoadTempArea();
            m_Engine.m_byNewStringNumber = 0;
            m_Engine.m_byTurnColor = (byte) (m_Engine.m_nComStoneColor ^ 3);

            m_Engine.nEvaluCount = 0;

            for (i = STARTPOS; i < ENDPOS; i++)
                if (m_Engine.m_byBoard[i] == 0) {
                    if ((m_Engine.m_lBitBoard[i] & 0x1) != 0)
                        m_Engine.nEvaluCount++;
                }

            m_Engine.nBoardScoreCtrl = 1;

            m_Engine.nEvaluCount = 9;

            m_Engine.m_nDifOfTwoT9 = BoardScoreCalc();
            m_Engine.m_nComScore = GetAllScore();

            nSwitch = GetComputerStonePos();
            switch (nSwitch) {
                case 0:
                    wRet = MAKEWORD(GetBoardY(m_Engine.m_nComStonePos),
                            GetBoardX(m_Engine.m_nComStonePos));
                    break;
                case 0xfe:
                    wRet = M_STOP;
                    break;
                default:
                    wRet = M_PASS;
            }

            m_Engine.m_bChangedGameStatus = false;
            nStoneCounter++;

            m_Engine.nEvaluCount = 0;

            return (wRet);
        } catch (Exception e) {
            //e.printStackTrace();
        }
        return M_STOP;//Temp code.
    }
    /*
        public void setInitStones(int inistones) {
            byte byGIniStonePos[][][] = { { {3, 15} //[3][10][2] =
                , {15, 3}
                , {3, 3}
                , {15, 15}
                , {3, 9}
                , {15, 9}
                , {9, 3}
                , {9, 15}
                , {9, 9}
                , {16, 2}
            }
                , { {3, 9}
                , {9, 3}
                , {3, 3}
                , {9, 9}
                , {3, 6}
                , {9, 6}
                , {6, 3}
                , {6, 9}
                , {6, 6}
                , {10, 2}
            }
                , { {2, 6}
                , {6, 2}
                , {2, 2}
                , {6, 6}
                , {2, 4}
                , {6, 4}
                , {4, 2}
                , {4, 6}
                , {4, 4}
                , {7, 1}
            }
            };
            int nGIniStoneOverPos[][][] = { { {6, 6} //[16][17][2] =
                , {12, 12}
            }
                , { {6, 6} //10
                , {12, 12}
                , {9, 9}
            }
                , { {6, 6} //11
                , {12, 12}
                , {6, 12}
                , {12, 6}
            }
                , { {6, 6} //12
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {9, 9}
            }
                , { {6, 6} //13
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
            }
                , { {6, 6} //14
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {9, 9}
            }
                , //15

                { {6, 6}
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
            }
                , { {6, 6} //16
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {9, 9}
            }
                , { {6, 6} //17
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
            }
                , { {6, 6} //18
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
                , {9, 9}
            }
                , { {6, 6} //19
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
                , {6, 2}
                , {12, 16}
            }
                , { {6, 6} //20
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
                , {6, 2}
                , {12, 16}
                , {9, 9}
            }
                , { {6, 6} //21
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
                , {6, 2}
                , {12, 16}
                , {1, 9}
                , {17, 9}
            }
                , { {6, 6} //22
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
                , {6, 2}
                , {12, 16}
                , {1, 9}
                , {17, 9}
                , {9, 9}
            }
                , { {6, 6} //23
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
                , {6, 2}
                , {12, 16}
                , {1, 9}
                , {17, 9}
                , {9, 1}
                , {9, 17}
            }
                , { {6, 6} //24
                , {12, 12}
                , {6, 12}
                , {12, 6}
                , {2, 6}
                , {16, 12}
                , {6, 16}
                , {12, 2}
                , {2, 12}
                , {16, 6}
                , {6, 2}
                , {12, 16}
                , {1, 9}
                , {17, 9}
                , {9, 1}
                , {9, 17}
                , {9, 9}
            }
                , //25
            };

            byte color = (byte)IS_BLACK;
            if (inistones < 2)
                return;

            if ( (inistones > 9) && (m_Engine.m_nBoardSize != 19))
                inistones = 9;

            if ( (inistones >= 2) && (inistones <= 9)) {

                int nSize, i, x, y;

                if (m_Engine.m_nBoardSize == 19)
                    nSize = 0;
                else if (m_Engine.m_nBoardSize == 13)
                    nSize = 1;
                else
                    nSize = 2;

                if ( (inistones == 5) || (inistones == 7)) {
                    for (i = 0; i < inistones - 1; i++) {
                        x = byGIniStonePos[nSize][i][0];
                        y = byGIniStonePos[nSize][i][1];
                        Kernel_PlaceStone((short)(((y+1) << 8) | (x+1)), color);
                    }

                    x = byGIniStonePos[nSize][8][0];
                    y = byGIniStonePos[nSize][8][1];
                    Kernel_PlaceStone((short)(((y+1) << 8) | (x+1)), color);
                } else

                {
                    for (i = 0; i < inistones; i++) {
                        x = byGIniStonePos[nSize][i][0];
                        y = byGIniStonePos[nSize][i][1];
                        Kernel_PlaceStone((short)(((y+1) << 8) | (x+1)), color);
                    }

                    if ( (inistones == 3) && (! (m_Engine.m_nTurn == color))) {
                        x = byGIniStonePos[nSize][2][0];
                        y = byGIniStonePos[nSize][2][1];

                        x = byGIniStonePos[nSize][3][0];
                        y = byGIniStonePos[nSize][3][1];
                        Kernel_PlaceStone((short)(((y+1) << 8) | (x+1)), color);
                    }

                }
            }

            if ( (inistones > 9) && (m_Engine.m_nBoardSize == 19))

            {
                int i, x, y;
                for (i = 0; i < 8; i++) {
                    x = byGIniStonePos[0][i][0];
                    y = byGIniStonePos[0][i][1];
                    Kernel_PlaceStone((short)(((y+1) << 8) | (x+1)), color);
                }
                for (i = 0; i < inistones - 8; i++) {
                    x = nGIniStoneOverPos[inistones - 10][i][0];
                    y = nGIniStoneOverPos[inistones - 10][i][1];
                    Kernel_PlaceStone((short)(((y+1) << 8) | (x+1)), color);
                }
            }

        }
    */
    short BoardScoreCalc() {
        short nTempBoardPos = m_Engine.m_nBoardPos;
        short wFormerWTSize = m_Engine.m_wWhiteTSize, wFormerBTSize = m_Engine.m_wBlackTSize;
        byte cT;

        m_Engine.m_nTotal++;
        if (m_Engine.m_byNewStringNumber == 0) {
            for (m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos++) {
                if ( (cT = (byte) m_Engine.m_byBoard[m_Engine.m_nMainPos]) > 0) {
                    m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = 0;
                } else if (cT == 0)
                    m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = -1;
            }
        } else {
            if (m_Engine.m_nBoardPos != 0) {
                ExpressTempArea();
            }
        }
        BoardWeightCalc();
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);

        if (m_Engine.m_byNewStringNumber == 0)
            MEMCPY(m_Engine.m_cTempWeightBoard, m_Engine.m_cWeightBoard, m_Engine.m_cWeightBoard.length);

        m_Engine.m_cBlackCountChange = (byte) m_Engine.m_byBlackGroupCount;
        m_Engine.m_cWhiteCountChange = (byte) m_Engine.m_byWhiteGroupCount;
        GroupScoreCalc();
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        m_Engine.m_nDifOfTerritory = (short) (m_Engine.m_nDifOfTwoT9 - m_Engine.m_nDifOfTerritory);
        m_Engine.m_cBlackCountChange -= (byte) m_Engine.m_byBlackGroupCount;
        m_Engine.m_cWhiteCountChange -= (byte) m_Engine.m_byWhiteGroupCount;
        m_Engine.m_nWhiteTChange = (short) (wFormerWTSize - m_Engine.m_wWhiteTSize); //\uFFFDE\uFFFD`\uFFFDEEj\uFFFDE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDEEE@\uFFFDG\uFFFDEF\uFFFDE\uFFFD`EEE@\uFFFDE\uFFFDE\uFFFD\uFFFD
        m_Engine.m_nBlackTChange = (short) (wFormerBTSize - m_Engine.m_wBlackTSize); //\uFFFDEE`\uFFFDEEj\uFFFDE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDEEE@\uFFFDG\uFFFDEF\uFFFDEE`EEE@\uFFFDE\uFFFDE\uFFFD\uFFFD
        m_Engine.m_nChangedTSize = (short) (m_Engine.m_nDifOfTerritory - m_Engine.m_nWhiteTChange +
                m_Engine.m_nBlackTChange);
        m_Engine.m_nDifOfTerritory = m_Engine.m_nDifOfTwoT9;

        if (m_Engine.m_byTurnColor == 2) //black
            m_Engine.m_nChangedTSize = (short) - m_Engine.m_nChangedTSize;

        m_Engine.m_nChangedTSize += (m_Engine.m_nDeadStoneCount - m_Engine.m_nOldDeadCount) * 6;

        m_Engine.m_nBoardPos = nTempBoardPos;

        if (m_Engine.m_nChangedTSize < -12)
            return -2;
        if (m_Engine.m_nChangedTSize < -3)
            return -1;
        return ((short) ((m_Engine.m_nChangedTSize + 3) / 6));
    }

    short GetAllScore() {
        short i;
        short nTemp1, nTemp2;

        short nBlackScore = m_Engine.m_nWhiteDeadCount;
        short nWhiteScore = m_Engine.m_nBlackDeadCount;
        short nComScore;

        for (i = 0; i < MAX_STRINGCOUNT; i++)
            if ( (m_Engine.m_wCorrectStatus[i] & 4) != 0) {
                if ( (i & 1) != 0)
                    nBlackScore += (short) (m_Engine.m_nStoneCount[i] << 1);
                else
                    nWhiteScore += (short) (m_Engine.m_nStoneCount[i] << 1);
            }

        for (i = m_Engine.m_nTotalGroupCount; i > 0; i--)
            if ( ( (nTemp1 = m_Engine.m_stGroup[i].nAliveDead) != 0) && (nTemp1 != 0xff)) {
                nTemp2 = m_Engine.m_stGroup[i].nSituation;
                nTemp2 >>= 1;
                if ( (i & 1) != 0)
                    nBlackScore += nTemp2;
                else
                    nWhiteScore += nTemp2;
            }

        for (i = STARTPOS; i < ENDPOS; i++)
            if (m_Engine.m_byBoard[i] == 0) {
                nTemp1 = (short) m_Engine.m_nCorrectWeight[i];
                if (nTemp1 > 0) {
                    if (nTemp1 != 2)
                        nWhiteScore++;
                } else if (nTemp1 < 0) {
                    if (nTemp1 != -2)
                        nBlackScore++;
                }
            }

        i = (short) (nWhiteScore - nBlackScore);
        i += 5;
        nComScore = i;
        if (m_Engine.m_nComStoneColor == IS_WHITE)
            nComScore = (short) - nComScore;

        return nComScore;
    }

    //HJ_Debug>>
//    boolean bDebug_print = false;
    //<<

    short GetComputerStonePos() {
        short i = 0, j = 0, nPos, nTScore;
        short nTempPos = 0;
        short nTempScore = -1;
        short wTempPos[] = {0};
        short nNowStoneWeight1[] = {0}
                , nNowStoneWeight2[] = {0};
        long lBitControlValue;
        short nSelectStatus, nSelectPos;
        short nScoreCom[] = {0}
                , nScoreHuman[] = {0}
                , nWeight2[] = {0};
        short nComWeight1;
        short nNumber[] = {0};
        short nTempWeight, nTemp;

        short nTemp1, nTemp2;
        short wTemp;

        short nTempEvalue = m_Engine.nEvaluCount;

        m_Engine.m_nComStoneWeight1 = 0;

        MoveData();

        for (i = 0; i < MAXCANDINUM; i++) {
            m_Engine.m_Candi[i].nPos = 0;
            m_Engine.m_Candi[i].Prop = (byte) 0xff;
        }

        m_Engine.m_nPrevWeight = 0;

        m_Engine.m_nComStonePos = 0;
        TestFail:
        do {
            TestAble:
            do {
                if (nTempPos != 0) { //??????????
                    if (m_Engine.m_nComStoneWeight1 >= 55)
                        break TestAble;
                    m_Engine.m_nComStoneWeight1 = (short) (m_Engine.m_nComStoneWeight1 * 16 / 10);
                    m_Engine.m_Candi[0].nPos = m_Engine.m_nComStonePos;
                    m_Engine.m_Candi[0].Weight1 = m_Engine.m_nComStoneWeight1;
                    m_Engine.m_Candi[0].Weight2 = (byte) ToWeight2(m_Engine.m_nComStoneWeight1);
                    m_Engine.m_Candi[0].Prop = 0x10;

                    m_Engine.m_nComStonePos = 0;
                    m_Engine.m_nComStoneWeight1 = -1;

                    m_Engine.m_byControlFlag = 1;
                }

                wTempPos[0] = (short) nTempPos;
                nTempScore = GetMoveFromSimul(wTempPos);
                nTempPos = (short) wTempPos[0];

                if (nTempScore > m_Engine.m_nComStoneWeight1) {
                    m_Engine.m_nComStoneWeight1 = nTempScore;
                    m_Engine.m_nComStonePos = nTempPos;
                }

                if (m_Engine.m_nComStoneWeight1 <= 0)
                    break TestFail;

                m_Engine.m_Candi[1].Prop = 0x24;

                m_Engine.m_Candi[1].nPos = m_Engine.m_nComStonePos;
                m_Engine.m_Candi[1].Weight1 = m_Engine.m_nComStoneWeight1;
                m_Engine.m_Candi[1].Weight2 = (byte) ToWeight2(m_Engine.m_nComStoneWeight1);
                m_Engine.m_byControlFlag |= 2;
                break TestFail;
            } while (false); //testable

            m_Engine.m_byTurnColor = (byte) m_Engine.m_nComStoneColor;
            m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;
            if ( (SetStone1( (byte) m_Engine.m_nComStoneColor)) == IS_OK) {
                m_Engine.m_nBlackStoneBoard[m_Engine.m_nComStonePos] =
                        m_Engine.m_nWhiteStoneBoard[m_Engine.m_nComStonePos] = 2000;
                m_Engine.m_nStoreWeight = 0x25;
                for (i = STARTPOS; i < ENDPOS; i++)
                    if ( (byte) m_Engine.m_byBoard[i] >= 0)
                        m_Engine.m_lBitBoard[i] &= 0x2df;

                return (0);
            }
        } while (false); //TestFail;

        m_Engine.m_nComStonePos = 0;
        m_Engine.m_nComStoneWeight1 = 0;
        m_Engine.m_nComStoneWeight2 = 0;

        if (m_Engine.m_nComStoneWeight1 > 0) {
            m_Engine.m_Candi[2].nPos = m_Engine.m_nComStonePos;
            m_Engine.m_Candi[2].Weight1 = m_Engine.m_nComStoneWeight1;
            m_Engine.m_Candi[2].Weight2 = (byte) ToWeight2(m_Engine.m_nComStoneWeight1);
            m_Engine.m_Candi[2].Prop = (byte) 0xf8;
        }

        m_Engine.m_nComStonePos = 0;
        m_Engine.m_nComStoneWeight1 = -1;
        m_Engine.m_nComStoneWeight2 = 0;

        nTempEvalue = m_Engine.nEvaluCount;

        nWeight2[0] = ToWeight2(m_Engine.m_nComStoneWeight1);
        nSelectStatus = 0;

        m_Engine.m_cComAverageWeight = (m_Engine.m_nComStoneColor == IS_WHITE) ? m_Engine.m_cAverageWeight :
                (byte) ( -m_Engine.m_cAverageWeight);

        nPos = m_Engine.m_nComStonePos;
        m_Engine.m_nPrevWeight = 0;

        short nMainCalcCount = 0;

        for (m_Engine.m_nBoardPos = STARTPOS; m_Engine.m_nBoardPos < ENDPOS; m_Engine.m_nBoardPos++) {
            //HJ_Debug>>
            //System.out.println("****m_nBoardPos = " + m_Engine.m_nBoardPos);
            //<<
            if ( (m_Engine.m_byBoard[m_Engine.m_nBoardPos] != 0) ||
                    (m_Engine.m_nBoardPos == m_Engine.m_nPaePos))
                continue;
            lBitControlValue = m_Engine.m_lBitBoard[m_Engine.m_nBoardPos];
            if ( (lBitControlValue & 0x20) != 0)
                continue;
            nTempWeight = 1000;
            if (m_Engine.m_bFirstMove) {
                if ((m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] & 0xFF) <= 3)
                    continue;
            }
            if (m_Engine.m_bFirstMove && (nMainCalcCount > 20)) {
                m_Engine.m_bFirstMove = false;
                break;
            }
            ContNextPos:
            do {
                out_kwj:
                while (true) {
                    if ((lBitControlValue & 0x0d) != 0) {
                        if ((m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] & 0x0100) == 0) {
                            GetMainScore();
                            if ( m_Engine.m_bStop )
                                return 0xfe;
                            nMainCalcCount++;
                            lBitControlValue = m_Engine.m_lBitBoard[m_Engine.m_nBoardPos];
                            m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 0x100;
                        }
                    }
                    IfThrough2:
                    do {
                        GetShapeScore(m_Engine.m_nBoardPos, nScoreCom, nScoreHuman);
                        nComWeight1 = (short) ((nScoreCom[0] + 1) + (nScoreHuman[0] + 1)); //???????????

                        if (nComWeight1 < nTempWeight)
                            nTempWeight = nComWeight1;
                        if (nScoreCom[0] == -2) //?????
                            break ContNextPos;

                        if (((nScoreHuman[0] <= -2) &&
                                ((nScoreCom[0] == 0) || (nScoreCom[0] == 1)))
                                || ((nScoreCom[0] == -1) && (nScoreHuman[0] == 1)))
                            nNowStoneWeight1[0] = nNowStoneWeight2[0] = 0;
                        else {
                            if (nScoreCom[0] != -1) {
                                if (nScoreHuman[0] <= -2) {
                                    nScoreHuman[0] = -1;
                                    nComWeight1++;
                                }
                            } else if (nScoreHuman[0] <= 0)
                                break ContNextPos;
                            if (nComWeight1 < (m_Engine.m_nComStoneWeight1 / 4))
                                break ContNextPos;

                            GetCollectedScore(nScoreCom[0], nScoreHuman[0],
                                    nNowStoneWeight1,
                                    nNowStoneWeight2);

                            nNowStoneWeight2[0] = (short) (nNowStoneWeight1[0] +
                                    nNowStoneWeight2[0]);

                            i = nNowStoneWeight1[0];
                            nNowStoneWeight1[0] = nNowStoneWeight2[0];
                            nNowStoneWeight2[0] = i;

                            if (nNowStoneWeight1[0] == -1)
                                break ContNextPos;
                            nNowStoneWeight2[0]++;
                        }
                        if ((m_Engine.m_nComStoneWeight1 != -1) &&
                                ((nNowStoneWeight1[0] < m_Engine.m_nComStoneWeight1) ||
                                        ((nNowStoneWeight1[0] == m_Engine.m_nComStoneWeight1) &&
                                                (nNowStoneWeight2[0] <= nWeight2[0]))))
                            break ContNextPos;

                        if ((lBitControlValue & 0x0d) == 0) {
                            lBitControlValue |= 1;
                            m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] = (int)lBitControlValue;
                            continue out_kwj;
                        }
                        if (System.currentTimeMillis() - m_dwTimeStart <=
                                (m_dwLimitTime / 2 * (m_Engine.m_nBoardPos - STARTPOS) /
                                        (ENDPOS - STARTPOS) + m_dwLimitTime / 2)) { // by KWJ : 2007-04-30
                            if (((lBitControlValue & 0x10) != 0)&&( m_Engine.m_nGameLevel > 3)) {
                                GetMainScoreOfTest();
                                lBitControlValue = m_Engine.m_lBitBoard[
                                        m_Engine.m_nBoardPos];
                                continue IfThrough2;
                            }
                        }
                        break out_kwj;

                    } while(true); // IfThrough2
                }
                if ((m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] & 0x0200) != 0)
                    continue;
                if (nTempWeight > m_Engine.m_nPrevWeight)
                    m_Engine.m_nPrevWeight = nTempWeight;

                if ((m_Engine.m_byControlFlag & 1) != 0) {
                    for (i = STARTPOS; i < ENDPOS; i++)
                        if (m_Engine.m_byBoard[i] != INITVALUE)
                            m_Engine.m_lBitBoard[i] &= 0xff7f;
                    m_Engine.m_byControlFlag = 0;
                }
                nSelectStatus = (short) (SelectOptimalCandi((short) 0, nWeight2, nNumber) & 0x03);

                if (((m_Engine.m_nBoardPos != m_Engine.m_nComStonePos) ||
                        (nSelectStatus != 0)) && ((lBitControlValue & 0x02) == 0))
                    nSelectStatus = 1;
                else
                    nSelectStatus = 2;
                nWeight2[0] = nNowStoneWeight2[0];
                m_Engine.m_nComStoneWeight1 = nNowStoneWeight1[0];
                m_Engine.m_nComStonePos = m_Engine.m_nBoardPos;
                RegisterCandi((short) (nSelectStatus | 0x30), nWeight2);
            } while(false);// ContNextPos
        }

        nSelectStatus = (short) (SelectOptimalCandi((short) 0, nWeight2, nNumber) & 0x03);
        m_Engine.m_nBoardPos = nPos = m_Engine.m_nComStonePos;
        SetStone2((byte) m_Engine.m_nComStoneColor);
        if ( m_Engine.m_nBoardPos != 0 )//2007/04/20 - New Addition
            SetBit0_1();
        LoadData();
        RegisterCandi((short) - 1, nWeight2);

        m_Engine.m_nComStonePos = 0;
        m_Engine.m_nComStoneWeight1 = -1;

        wTempPos[0] = nTempPos;
        nTempScore = -1;
        nTempPos = (short) wTempPos[0];

        if (nTempScore > m_Engine.m_nComStoneWeight1) {
            m_Engine.m_nBoardPos = nTempPos;
            if (SetStone1((byte) (m_Engine.m_nComStoneColor & 0xff)) == IS_OK) {
                m_Engine.m_nComStoneWeight1 = nTempScore;
                m_Engine.m_nComStonePos = nTempPos;
                nSelectStatus = 3;
            }
        }

        if (m_Engine.m_nComStonePos != 0)
            RegisterCandi( (short) (nSelectStatus | 0x40), nWeight2);
        nSelectStatus = (short) (SelectOptimalCandi( (short) 1, nWeight2, nNumber) & 0x03);

        m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;
        LastProcess:
        do {
            if ( (m_Engine.m_nComStoneWeight1 == 0) || (m_Engine.m_nComStoneWeight1 == -1))
                break LastProcess;
            if (m_Engine.m_nComStoneWeight1 > 0x25)
                m_Engine.m_nStoreWeight = 0x25;
            else
                m_Engine.m_nStoreWeight = m_Engine.m_nComStoneWeight1;
            if (nSelectStatus == 1) {
                if (m_Engine.m_Candi[1].nPos != m_Engine.m_nBoardPos)
                    TestAroundPoints();
            }

            if (m_Engine.m_nComStonePos != m_Engine.m_Candi[1].nPos) {
                m_Engine.m_Candi[1].nPos = 0;
                m_Engine.m_Candi[1].Weight1 = 0;
            }

            while (true) {
                if ( (m_Engine.m_byExpressBoard[m_Engine.m_nComStonePos] != 3) ||
                        ( (m_Engine.m_lBitBoard[m_Engine.m_nComStonePos] & 0x80000000) == 0)) {
                    if (m_Engine.nEvaluCount < 25) {
                        if ( (nTempEvalue >= 25) && (m_Engine.m_byExpressBoard[m_Engine.m_nComStonePos] == 1)) {
                            m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;
                            GetMainScore();
                            m_Engine.m_lBitBoard[m_Engine.m_nComStonePos] &= 0xfffffffe;
                        } else if (nTempEvalue < 25) {
                            m_Engine.nEvaluCount = 13;
                            m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;
                            GetMainScore();
                            m_Engine.m_lBitBoard[m_Engine.m_nComStonePos] &= 0xfffffffe;
                        }
                    } else {
                        m_Engine.nEvaluCount = 23;

                        m_Engine.m_byNewStringNumber = 0;
                        BoardScoreCalc();
                        MoveData();

                        m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;
                        GetMainScore();
                        m_Engine.m_lBitBoard[m_Engine.m_nComStonePos] &= 0xfffffffe;

                    }
                }

                if ( (m_Engine.m_nBlackStoneBoard[m_Engine.m_nComStonePos] <= 0) &&
                        (m_Engine.m_nWhiteStoneBoard[m_Engine.m_nComStonePos] <= 0)) {
                    if (m_Engine.m_Candi[1].nPos == m_Engine.m_nComStonePos) {
                        if ( (m_Engine.m_nBlackStoneBoard[m_Engine.m_nComStonePos] < 0) &&
                                (m_Engine.m_nWhiteStoneBoard[m_Engine.m_nComStonePos] < 0)) {
                            m_Engine.m_Candi[1].nPos = 0;
                            m_Engine.m_Candi[1].Weight1 = 0;

                            if (m_Engine.m_Candi[3].nPos == m_Engine.m_nComStonePos) {
                                if ( (m_Engine.m_Candi[4].nPos != 0) && (m_Engine.m_Candi[4].Weight1 > 0))
                                    m_Engine.m_nComStonePos = m_Engine.m_Candi[4].nPos;
                                else
                                    break LastProcess;
                            } else {
                                if ( (m_Engine.m_Candi[3].nPos != 0) && (m_Engine.m_Candi[3].Weight1 > 0))
                                    m_Engine.m_nComStonePos = m_Engine.m_Candi[3].nPos;
                                else
                                    break LastProcess;
                            }
                        } else
                            break;
                    } else if (m_Engine.m_Candi[3].nPos == m_Engine.m_nComStonePos) {
                        if ( (m_Engine.m_Candi[4].nPos != 0) && (m_Engine.m_Candi[4].Weight1 > 0))
                            m_Engine.m_nComStonePos = m_Engine.m_Candi[4].nPos;
                        else
                            break LastProcess;
                    } else if (m_Engine.m_Candi[4].nPos == m_Engine.m_nComStonePos) {
                        if ( (m_Engine.m_Candi[5].nPos != 0) && (m_Engine.m_Candi[5].Weight1 > 0))
                            m_Engine.m_nComStonePos = m_Engine.m_Candi[5].nPos;
                        else
                            break LastProcess;
                    } else if (m_Engine.m_Candi[5].nPos == m_Engine.m_nComStonePos) {
                        if ( (m_Engine.m_Candi[6].nPos != 0) && (m_Engine.m_Candi[6].Weight1 > 0))
                            m_Engine.m_nComStonePos = m_Engine.m_Candi[6].nPos;
                        else
                            break LastProcess;
                    } else {
                        nSelectPos = 0;
                        nTScore = 0;

                        for (i = STARTPOS; i < ENDPOS; i++) {
                            if (m_Engine.m_byBoard[i] != 0)
                                continue;
                            if (i == m_Engine.m_nPaePos)
                                continue;
                            GetComHumanScore(i, nScoreCom, nScoreHuman);

                            if ( (nScoreCom[0] == -2) || (nScoreHuman[0] == -2) ||
                                    ( (nScoreHuman[0] <= 0) && (nScoreCom[0] <= 0)))
                                continue;

                            if (nTScore > (nScoreHuman[0] + nScoreCom[0]))
                                continue;

                            nSelectPos = i;
                            nTScore = (short) (nScoreHuman[0] + nScoreCom[0]);
                        }
                        if ( (nSelectPos == 0) || (nTScore <= 0))
                            break LastProcess;

                        m_Engine.m_nComStonePos = nSelectPos;
                    }

                } else
                    break;
            }

            m_Engine.nEvaluCount = nTempEvalue;
            m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;

            //$PutStone:

            for (i = STARTPOS; i < ENDPOS; i++) {
                if (m_Engine.m_byBoard[i] == INITVALUE)
                    continue;
                m_Engine.m_lBitBoard[i] &= 0x02ff;
                if ( (m_Engine.m_lBitBoard[i] & 0x20) != 0)
                    m_Engine.m_lBitBoard[i] &= 0xff50;
                else {
                    if ( (m_Engine.m_lBitBoard[i] & 0x40) != 0)
                        m_Engine.m_lBitBoard[i] &= 0xff51;
                    else
                        m_Engine.m_lBitBoard[i] &= 0xff10;
                }
            }
            m_Engine.m_lBitBoard[m_Engine.m_nComStonePos] |= 0x01;
            m_Engine.m_byTurnColor = (byte) m_Engine.m_nComStoneColor;

            if (SetStone1( (byte) m_Engine.m_nComStoneColor) == IS_OK)
                return 0;

        } while (false); //LastProcess:

        m_Engine.nEvaluCount = nTempEvalue;

        m_Engine.m_nStoreWeight = 0;

        boolean bBackwardToPutStone = false; //goto $PutStone; = false
        $PutStone:
        do {
            if ( bBackwardToPutStone )
            {
                for (i = STARTPOS; i < ENDPOS; i++) {
                    if (m_Engine.m_byBoard[i] == INITVALUE)
                        continue;
                    m_Engine.m_lBitBoard[i] &= 0x02ff;
                    if ((m_Engine.m_lBitBoard[i] & 0x20) != 0)
                        m_Engine.m_lBitBoard[i] &= 0xff50;
                    else {
                        if ((m_Engine.m_lBitBoard[i] & 0x40) != 0)
                            m_Engine.m_lBitBoard[i] &= 0xff51;
                        else
                            m_Engine.m_lBitBoard[i] &= 0xff10;
                    }
                }
                m_Engine.m_lBitBoard[m_Engine.m_nComStonePos] |= 0x01;
                m_Engine.m_byTurnColor = (byte) m_Engine.m_nComStoneColor;

                if (SetStone1((byte) m_Engine.m_nComStoneColor) == IS_OK)
                    return 0;

                m_Engine.nEvaluCount = nTempEvalue;

                m_Engine.m_nStoreWeight = 0;
            }

            for (i = STARTPOS; i < ENDPOS; i++) {
                if (m_Engine.m_byBoard[i] != 0)
                    continue;
                if (i == m_Engine.m_nPaePos)
                    continue;
                GetComHumanScore(i, nScoreCom, nScoreHuman);

                if (! (((nScoreCom[0] == -1) && ( (nScoreHuman[0] == 1) || (nScoreHuman[0] == 0)))
                        || ((nScoreCom[0] == -2) && (nScoreHuman[0] >= 0))))
                    continue;

                if ( ( (m_Engine.m_nComStoneColor == IS_BLACK) && (m_Engine.m_cWeightBoard[i] > 3)) ||
                        ( (m_Engine.m_nComStoneColor == IS_WHITE) && (m_Engine.m_cWeightBoard[i] < -3)))
                    continue;
                m_Engine.m_nBoardPos = i;
                nTemp1 = m_Engine.m_nBlackStoneBoard[i];
                nTemp2 = m_Engine.m_nWhiteStoneBoard[i];
                wTemp = GetPosForLast();
                m_Engine.m_nBlackStoneBoard[i] = nTemp1;
                m_Engine.m_nWhiteStoneBoard[i] = nTemp2;
                if ( (wTemp == 0) || (wTemp == (short) m_Engine.m_nPaePos))
                    continue;
                m_Engine.m_nBoardPos = wTemp;

                nTemp1 = m_Engine.m_nPaePos;
                if (SetStone1( (byte) m_Engine.m_nComStoneColor) != IS_OK) {
                    m_Engine.m_nPaePos = nTemp1;
                    continue;
                }
                m_Engine.m_nPaePos = nTemp1;
                m_Engine.m_nComStonePos = m_Engine.m_nBoardPos;
                m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = 0;
                m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = 0;
                bBackwardToPutStone = true; //goto $PutStone;
                continue $PutStone;
            }

            m_Engine.m_nComStonePos = 0;
            nNowStoneWeight1[0] = 2;
            nNowStoneWeight2[0] = 0;

            for (m_Engine.m_nBoardPos = STARTPOS; m_Engine.m_nBoardPos < ENDPOS; m_Engine.m_nBoardPos++) {
                if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] != 0)
                    continue;
                if (m_Engine.m_nBoardPos == m_Engine.m_nPaePos)
                    continue;
                GetComHumanScore(m_Engine.m_nBoardPos, nScoreCom, nScoreHuman);
                if (nScoreCom[0] == -2)
                    continue;
                if ( ( (nScoreHuman[0] == -2) && (nScoreCom[0] < 2))
                        || ( (nScoreCom[0] == -1) && (nScoreHuman[0] == 1))) {
                    nScoreCom[0] += 2;
                    nScoreHuman[0] = 0;
                } else {
                    if (nScoreCom[0] != -1) {
                        if (nScoreHuman[0] == -2)
                            nScoreHuman[0] = -1;
                    } else {
                        if (nScoreHuman[0] <= 0)
                            continue;
                    }
                    if ( (nScoreCom[0] != 0) || (nScoreHuman[0] != 0)) {
                        short pi[] = {0}
                                , pj[] = {0};
                        pi[0] = i;
                        pj[0] = j;
                        GetCollectedScore(nScoreCom[0], nScoreHuman[0], pi, pj);
                        i = pi[0];
                        j = pj[0];
                        j = (short) (i + j);
                        if (j == -1)
                            continue;
                        nScoreCom[0] = j;
                        nScoreHuman[0] = (short) (i + 1);
                    } else
                        nScoreHuman[0] = 1;
                    nTemp = m_Engine.m_nPaePos;
                    if (SetStone1( (byte) m_Engine.m_nComStoneColor) != IS_OK) {
                        m_Engine.m_nPaePos = nTemp;
                        continue;
                    }
                    m_Engine.m_nPaePos = nTemp;
                    nScoreCom[0] = (short) (m_Engine.m_nSCount + m_Engine.m_nDCount);
                }
                if ( (nScoreCom[0] > nNowStoneWeight1[0]) ||
                        ( (nScoreCom[0] == nNowStoneWeight1[0]) && (nScoreHuman[0] > nNowStoneWeight2[0]))) {
                    lBitControlValue = m_Engine.m_lBitBoard[m_Engine.m_nBoardPos];
                    i = 0;
                    if ( (lBitControlValue & 0x0d) == 0) {
                        GetMainScore();
                        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 0x01;
                        i = 1;
                    }
                    if ( (lBitControlValue & 0x10) != 0) {
                        GetMainScoreOfTest();
                        i = 2;
                    }
                    if (i != 0) {
                        m_Engine.m_nBoardPos--;
                        continue;
                    }
                    nNowStoneWeight1[0] = nScoreCom[0];
                    nNowStoneWeight2[0] = nScoreHuman[0];
                    m_Engine.m_nComStonePos = m_Engine.m_nBoardPos;
                }
            }
            if (m_Engine.m_nComStonePos != 0) {
                m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;
                bBackwardToPutStone = true; //goto $PutStone;
                continue $PutStone;
            }
            bBackwardToPutStone = false;
        } while (bBackwardToPutStone);

        for (i = STARTPOS; i < ENDPOS; i++) {
            if (m_Engine.m_byBoard[i] == INITVALUE)
                continue;
            m_Engine.m_lBitBoard[i] &= 0x2ff;
        }

        return (0xff);
    }

    short GetBoardY(short nBoardPos) {
        return (short) ( (nBoardPos - STARTPOS) / 20);
    }

    short GetBoardX(short nBoardPos) {
        return (short) ( (nBoardPos - STARTPOS) % 20);
    }

    void Simulation() {
        short byStr, byStr1 = 0;
        short wStatus, wStatus1;
        short n, nPeris;

        m_Engine.m_wOppPoint = m_Engine.m_nBoardPos;
        BackupStrDatas(PARENT_BACKUP);
        BackupStrDatas(CHILD_BACKUP);
        MEMCPY(m_Engine.m_byTempLocalPattern, m_Engine.m_byLocalPattern, m_Engine.m_byLocalPattern.length);

        MEMSET(m_Engine.m_wResultInFirst, 0xffff);
        MEMSET(m_Engine.m_wResultInSecond, 0xffff);
        MEMSET(m_Engine.m_wSetInFirst, 0xffff);
        MEMSET(m_Engine.m_wSetInSecond, 0xffff);
        m_Engine.m_wResultCurr = 0;
        m_Engine.m_nOutCall = 0;

        for (byStr = 1; byStr < MAX_STRINGCOUNT; byStr++) {
            switch (m_Engine.m_byLiberties[byStr]) {
                case 0:
                    wStatus = (short) 0xff00;
                    break;
                case 1:
                case 2:
                case 3:
                    wStatus1 = m_Engine.m_wTempStatus[byStr];
                    switch (wStatus1 & 0x0808) {
                        case 0x0808:
                            wStatus = (short) 0xffff;
                            break;
                        case 0x0800:
                            wStatus = (short) (wStatus1 & 0xff00);
                            break;
                        case 0x0008:
                            wStatus = (short) (wStatus1 & 0x00ff);
                            break;
                        case 0x0000:
                            wStatus = 0x0000;
                        default:
                            wStatus = 0;
                    }
                    break;
                default:
                    wStatus = (short) 0xff01;
            }
            m_Engine.m_wTempStatus[byStr] = wStatus;

            if ( (m_Engine.m_byLiberties[byStr] == m_Engine.m_byLastLibs[byStr]) &&
                    (m_Engine.m_nStoneCount[byStr] == m_Engine.m_nLastStns[byStr]))
                continue;

            for (n = STARTPOS; n < ENDPOS; n++) {
                if (m_Engine.m_byBoard[n] == 0) {
                    if (IsSameStringg(n, (byte)byStr))
                        m_Engine.m_byMarkedBoard[n] = (byte) 0xff;
                }
            }
        }

        FixupSimulArea();

        m_Engine.m_nReflexMax = 1;
        m_Engine.m_nMaxDepth = 8;
        for (byStr = (byte) (MAX_STRINGCOUNT - 1); byStr > 0; byStr--) {
            if (m_Engine.m_byLiberties[byStr] == 1) {
                if ( (m_Engine.m_wTempStatus[byStr] == (short) 0xffff) ||
                        ( (m_Engine.m_wTempStatus[byStr] & 0x00ff) == 0) ||
                        ( (m_Engine.m_wTempStatus[byStr] & 0xff00) == 0)) {
                    SimulInSecond(byStr, (byte) 1);
                    if (m_Engine.m_cSimulStatus == -1)
                        SimulInFirstBrief();
                    else
                        SimulInFirst( (byte) 1);
                }
            }
        }

        m_Engine.m_nMaxDepth = 6;
        for (byStr = (short) (MAX_STRINGCOUNT - 1); byStr > 0; byStr--) {
            if (m_Engine.m_byLiberties[byStr] == 2) {
                if ( (m_Engine.m_wTempStatus[byStr] == (short) 0xffff) ||
                        ( (m_Engine.m_wTempStatus[byStr] & 0x00ff) == 0) ||
                        ( (m_Engine.m_wTempStatus[byStr] & 0xff00) == 0))

                    //HJ_Debug>>
//                    System.out.println("Simulation() : byStr = " + byStr);
                    //<<
                    SimulOfMoreLibsString(byStr);
            }
        }

        m_Engine.m_nMaxDepth = 4;
        for (byStr = (byte) (MAX_STRINGCOUNT - 1); byStr > 0; byStr--) {
            if (m_Engine.m_byLiberties[byStr] == 3) {
                if ( (m_Engine.m_wTempStatus[byStr] == (short) 0xffff) ||
                        ( (m_Engine.m_wTempStatus[byStr] & 0x00ff) == 0) ||
                        ( (m_Engine.m_wTempStatus[byStr] & 0xff00) == 0))
                    SimulOfMoreLibsString(byStr);
            }
        }

        for (byStr = 1; byStr < MAX_STRINGCOUNT; byStr++) {
            if ( (m_Engine.m_byLiberties[byStr] != 3) || ( (m_Engine.m_wTempStatus[byStr] & 0x0008) == 0))
                continue;

            nPeris = GetPeriStrs(byStr, (byte) 3);
            if (nPeris == 0)
                continue;

            for (n = 0; n < nPeris; n++) {
                byStr1 = m_Engine.m_byPeriStr[n];

                if ( (byStr1 < byStr) && (m_Engine.m_byLiberties[byStr1] == 3) &&
                        ( (m_Engine.m_wTempStatus[byStr1] & 0x0008) != 0))
                    break;
            }
            if ( (n >= nPeris) || (m_Engine.m_wSetInSecond[byStr1] == (short) 0xffff))
                continue;

            wStatus = (short) (m_Engine.m_wTempStatus[byStr] & 0xff00);
            wStatus1 = (short) (m_Engine.m_wTempStatus[byStr1] & 0xff00);

            //H.Joon-2007/03/07>>
            //wStatus |= (wStatus1 >> 8);
            wStatus |= ((wStatus1 & 0xFFFF) >>> 8);
            //<<
            m_Engine.m_wTempStatus[byStr] = wStatus;
            m_Engine.m_wStatus[byStr] = wStatus;

            //H.Joon-2007/03/07>>
            //wStatus1 |= (wStatus >> 8);
            wStatus1 |= ((wStatus & 0xFFFF) >>> 8);
            //<<
            m_Engine.m_wTempStatus[byStr1] = wStatus1;
            m_Engine.m_wStatus[byStr1] = wStatus1;

            m_Engine.m_wResultInSecond[byStr] = m_Engine.m_wResultCurr;
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr] = 1;
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr + 1] = 0;
            m_Engine.m_wResultCurr += sizeofSIMULRESULT;

            wStatus = (short) (m_Engine.m_wSetInSecond[byStr] + sizeofSIMULSET);
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr + 2] =
                    m_Engine.m_pSimulArea[wStatus + 2];
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr] =
                    m_Engine.m_pSimulArea[wStatus + sizeofSIMULUNIT];
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr + 1] =
                    m_Engine.m_pSimulArea[wStatus + sizeofSIMULUNIT + 1];
            m_Engine.m_wResultCurr += sizeofSIMULMOVE;

            m_Engine.m_wResultInFirst[byStr] = m_Engine.m_wResultCurr;
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr] = 1;
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr + 1] = 0;
            m_Engine.m_wResultCurr += sizeofSIMULRESULT;

            wStatus = (short) (m_Engine.m_wSetInSecond[byStr1] + sizeofSIMULSET);
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr + 2] = m_Engine.m_pSimulArea[wStatus + 2];
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr] = m_Engine.m_pSimulArea[wStatus + sizeofSIMULUNIT];
            m_Engine.m_pResultArea[m_Engine.m_wResultCurr + 1] = m_Engine.m_pSimulArea[wStatus +
                    sizeofSIMULUNIT + 1];
            m_Engine.m_wResultCurr += sizeofSIMULMOVE;
        }

        RestorStrDatas(PARENT_BACKUP);
        MEMCPY(m_Engine.m_byLocalPattern, m_Engine.m_byTempLocalPattern, m_Engine.m_byLocalPattern.length);
        m_Engine.m_nBoardPos = m_Engine.m_wOppPoint;
    }

    void FixupSimulArea() {
        short wPreSimulEnd;
        short wTrackDes, wTrackSrc, wNextStr, wNextSet;
        short wSet[] = new short[8];
        short nPeris, nNormal, i;
        byte byStr, byStatus1, byStatus2;
        short wStatus;
        byte cRelStatus;
        short wTemp;
        short wChildUnit;

        wPreSimulEnd = m_Engine.m_wSimulEnd;

        if (wPreSimulEnd != 0) {

            m_Engine.m_wSimulEnd = 0;
            wTrackSrc = 0;

            while ((wTrackSrc & 0xffff) < (wPreSimulEnd & 0xffff)) {
                //wNextStr = *(LPWORD)(m_pSimulArea + wTrackSrc);
                wNextStr = (short)(((m_Engine.m_pSimulArea[wTrackSrc+1] & 0xFFFF) << 8) |
                        (m_Engine.m_pSimulArea[wTrackSrc] & 0xff));
                if (wNextStr == 0)
                    break;

                wTrackDes = m_Engine.m_wSimulEnd;
                m_Engine.m_wMoveDis = (short) (wTrackSrc - wTrackDes);

                wTrackSrc += sizeofWORD;
                if (m_Engine.m_pSimulArea[wTrackSrc + sizeofSIMULSET + 3] == 0)
                //((LPUNIT)(m_pSimulArea + wTrackSrc + sizeof(SIMULSET)))->byCandis
                {
                    wTrackSrc = wNextStr;
                    continue;
                }

                //((LPSET)(m_pSimulArea + wTrackSrc))->byStr
                m_Engine.m_byStrNum = m_Engine.m_pSimulArea[wTrackSrc + 2];

                if ( (m_Engine.m_byLiberties[m_Engine.m_byStrNum] !=
                        m_Engine.m_byLastLibs[m_Engine.m_byStrNum]) ||
                        (m_Engine.m_nStoneCount[m_Engine.m_byStrNum] !=
                                m_Engine.m_nLastStns[m_Engine.m_byStrNum])) {
                    wTrackSrc = wNextStr;
                    continue;
                }

                nPeris = GetPeriStrs(m_Engine.m_byStrNum, (byte) 0xff);
                if (nPeris > 0) {
                    for (i = 0; i < nPeris; i++) {
                        byStr = m_Engine.m_byPeriStr[i];
                        if ((m_Engine.m_nStoneCount[byStr & 0xff] != m_Engine.m_nLastStns[byStr& 0xff]) ||
                                ((m_Engine.m_byLiberties[byStr & 0xff] != m_Engine.m_byLastLibs[byStr& 0xff]) &&
                                        ((m_Engine.m_byLastLibs[byStr& 0xff] & 0xff) < 6)))
                            break;
                    }

                    if (i < nPeris) {
                        wTrackSrc = wNextStr;
                        continue;
                    }
                }

                wTemp = (short) (wNextStr - m_Engine.m_wMoveDis);
                //C : *(LPWORD)(m_pSimulArea + wTrackDes) = wNextStr - m_wMoveDis;
                //H.Joon-2007/03/07>>
                //m_Engine.m_pSimulArea[wTrackDes] = (short) ( (wTemp >> 8) & 0xff);
                m_Engine.m_pSimulArea[wTrackDes] = (short) (wTemp & 0xff);
                //<<
                m_Engine.m_pSimulArea[wTrackDes + 1] =  (short) ( ((wTemp & 0xFFFF) >>> 8) & 0xff);
                wTrackDes += sizeofWORD;

                nNormal = 1;
                i = 0;

                while ((wTrackSrc & 0xffff) < (wNextStr & 0xffff)) {
                    //wNextSet = ((LPSET)(m_pSimulArea + wTrackSrc))->wNext;
                    wNextSet = (short) ((((m_Engine.m_pSimulArea[wTrackSrc + 1] & 0xFFFF) << 8)) |
                            (m_Engine.m_pSimulArea[wTrackSrc] & 0xff));
                    m_Engine.m_pSimulArea[wTrackDes + 2] = m_Engine.m_pSimulArea[wTrackSrc + 2];
                    m_Engine.m_pSimulArea[wTrackDes + 3] = m_Engine.m_pSimulArea[wTrackSrc + 3];
                    //C : ((LPSET)(m_pSimulArea + wTrackDes))->wNext = wNextSet - m_wMoveDis;
                    wTemp = (short) (wNextSet - m_Engine.m_wMoveDis);
                    //H.Joon-2007/03/07>>
                    //m_Engine.m_pSimulArea[wTrackDes] = (short) ( (wTemp >> 8) & 0xff);
                    m_Engine.m_pSimulArea[wTrackDes] = (short) (wTemp & 0xff);
                    //<<
                    m_Engine.m_pSimulArea[wTrackDes + 1] = (short) ( ((wTemp & 0xFFFF) >>> 8) & 0xff);

                    wSet[i++] = wTrackDes;
                    wTrackDes += sizeofSIMULSET;
                    wTrackSrc += sizeofSIMULSET;

                    //MEMCPY(m_Engine.m_pTempArea, & m_Engine.m_pSimulArea[wTrackSrc], wNextSet - wTrackSrc);
                    System.arraycopy(m_Engine.m_pSimulArea, wTrackSrc, m_Engine.m_pTempArea, 0,
                            wNextSet - wTrackSrc);

                    m_Engine.m_wTrackSrc = wTrackSrc;
                    nNormal = MoveUnit(wTrackDes, 0);

                    if (nNormal == 0)
                        break;

                    wTrackSrc = wNextSet;
                    wTrackDes = (short) (wTrackSrc - m_Engine.m_wMoveDis);
                }

                if (nNormal == 0) {
                    wTrackSrc = wNextStr;
                    continue;
                }

                m_Engine.m_wSetInSecond[m_Engine.m_byStrNum] = wSet[0];
                m_Engine.m_wSetInFirst[m_Engine.m_byStrNum] = wSet[i - 1];

                byStatus1 = (byte) (m_Engine.m_pSimulArea[wSet[0] + sizeofSIMULSET + 2] & 0xff);
                byStatus2 = (byte) (m_Engine.m_pSimulArea[wSet[i - 1] + sizeofSIMULSET + 2] & 0xff);

                wStatus = MAKEWORD((byStatus2 & 0xff), (byStatus1 & 0xff));
                m_Engine.m_wStatus[m_Engine.m_byStrNum] = wStatus;
                m_Engine.m_wBackStatus[m_Engine.m_byStrNum] = wStatus;
                m_Engine.m_wTempStatus[m_Engine.m_byStrNum] = wStatus;

                m_Engine.m_byStr1 = 0;

                if (i > 2) {
                    wTrackDes = (short) (wSet[0] + sizeofSIMULSET + sizeofSIMULUNIT);
                    m_Engine.m_wPoint1 = (short) ( ((m_Engine.m_pSimulArea[wTrackDes + 1] & 0xFFFF) << 8) |
                            (m_Engine.m_pSimulArea[wTrackDes] & 0xff));

                    wChildUnit = (short) ( ((m_Engine.m_pSimulArea[wTrackDes + 3] & 0xFFFF) << 8) |
                            (m_Engine.m_pSimulArea[wTrackDes + 2] & 0xff));
                    wTrackDes = (short) (wChildUnit + sizeofSIMULUNIT);
                    m_Engine.m_wPoint2 = (short) ( ((m_Engine.m_pSimulArea[wTrackDes + 1] & 0xFFFF) << 8) |
                            (m_Engine.m_pSimulArea[wTrackDes] & 0xff));

                    cRelStatus = (byte) (m_Engine.m_pSimulArea[wSet[i - 2] + sizeofSIMULSET + 2] & 0xff);
                    if (cRelStatus > 0) {
                        m_Engine.m_byStr1 = (byte) (m_Engine.m_pSimulArea[wSet[i - 2] + 2] & 0xff);
                        m_Engine.m_cSimulStatus = cRelStatus;
                        OutputSimulResultOnRel();
                    } else {
                        if ( ( (wStatus & 0x00ff) != 0x00ff) && ( (wStatus & 0xff00) != 0xff00))
                            OutputSimulResult();
                    }
                } else if (i == 2) {
                    if ( ( (wStatus & 0x00ff) != 0x00ff) && ( (wStatus & 0xff00) != 0xff00))
                        OutputSimulResult();
                }

                wTrackSrc = wNextStr;
                m_Engine.m_wSimulEnd = (short) (wTrackSrc - m_Engine.m_wMoveDis);
            }
        }

        for (i = STARTPOS; i < ENDPOS; i++)
            m_Engine.m_byMarkedBoard[i] = 0;

        if (m_Engine.m_nPaePos != 0)
            m_Engine.m_byMarkedBoard[m_Engine.m_nPaePos] = (byte) 0xff;

        for (i = 1; i < MAX_STRINGCOUNT; i++) {
            m_Engine.m_byLastLibs[i] = m_Engine.m_byLiberties[i];
            m_Engine.m_nLastStns[i] = m_Engine.m_nStoneCount[i];
        }
    }

    void OutputSimulResultOnRel() {
        short byStrNum;
        int pnResult;
        byte byColor;
        short wPaePos, wPos;
        short i, nLibs;
        short wPoint1 = 0;
        short wPoint2 = 0;

        m_Engine.m_wResultInSecond[m_Engine.m_byStrNum] = m_Engine.m_wResultCurr;
        AssignResultOnRel();

        m_Engine.m_cSimulStatus = 1;
        m_Engine.m_wResultInFirst[m_Engine.m_byStrNum] = m_Engine.m_wResultCurr;
        AssignResultOnRel();

        byStrNum = m_Engine.m_byStrNum;
        pnResult = m_Engine.m_wResultInFirst[byStrNum];

        if (RegMove(m_Engine.m_wPoint2, pnResult) == 0)
            return;

        byColor = ((byStrNum & 1) != 0) ? IS_WHITE : IS_BLACK;
        wPaePos = m_Engine.m_nPaePos;

        nLibs = GetLibs(m_Engine.m_byStr1, m_Engine.m_wEmptyPoint);

        for (i = 0; i < nLibs; i++) {
            wPos = m_Engine.m_wEmptyPoint[i];
            if (IsInResult(wPos, pnResult) == 1)
                continue;

            m_Engine.m_nBoardPos = wPos;
            m_Engine.m_nPaePos = 0;
            SetTestStone(byColor);
            if ((m_Engine.m_byNewLiberties & 0xff) >= 5) {
                if (RegMove(wPos, pnResult) == 0) {
                    m_Engine.m_nPaePos = wPaePos;
                    return;
                }
            }
        }

        GetPeriStrs(m_Engine.m_byStr1, (byte) 1);
        m_Engine.m_byStrNum = (short)(m_Engine.m_byStr1 & 0xff);
        m_Engine.m_byStoneColor = byColor;
        for (i = 0; i < m_Engine.m_nOneLibStrs; i++) {
            GetLibs(m_Engine.m_byPeriStr[i], m_Engine.m_wEmptyPoint);
            wPos = m_Engine.m_wEmptyPoint[0];
            if (IsInResult(wPos, pnResult) == 1)
                continue;

            m_Engine.m_nBoardPos = wPos;
            m_Engine.m_nPaePos = 0;
            SetSimulStone();
            if ((m_Engine.m_byLiberties[m_Engine.m_byStr1 & 0xff] & 0xff) >= 5) {
                if (RegMove(wPos, pnResult) == 0) {
                    RestorStrDatas(PARENT_BACKUP);
                    return;
                }
            }
            RestorStrDatas(PARENT_BACKUP);
        }
        m_Engine.m_byStrNum = byStrNum;

        wPoint1 = 0;
        wPoint2 = 0;

        for (i = 0; i < 4; i++) {
            wPos = (short) (m_Engine.m_wPoint1 + m_Engine.nNeighbor[i]);
            if (m_Engine.m_byBoard[wPos] != 0)
                continue;
            if (wPoint1 == 0)
                wPoint1 = wPos;
            else if (wPoint2 == 0) {
                wPoint2 = wPos;
                break;
            }
        }

        if (wPoint2 == 0)
            return;
        if (IsInResult(wPoint1, pnResult) == 0) {
            m_Engine.m_nBoardPos = wPoint1;
            SetTestStone(byColor);
            if ((m_Engine.m_byNewLiberties & 0xff) > 1) {
                if (RegMove(wPoint1, pnResult) == 0) {
                    m_Engine.m_nPaePos = wPaePos;
                    return;
                }
            }
        }

        if (IsInResult(wPoint2, pnResult) == 0) {
            m_Engine.m_nBoardPos = wPoint2;
            SetTestStone(byColor);
            if ((m_Engine.m_byNewLiberties & 0xff) > 1)
                RegMove(wPoint2, pnResult);
        }
        m_Engine.m_nPaePos = wPaePos;
    }

    short IsInResult(short wPoint, int pnResult) {
        int pnMove = pnResult + sizeofSIMULMOVE;
        short nFound = 0;
        short nCount = m_Engine.m_pResultArea[pnResult];

        while (nCount > 0) {
            short wTemp = (short) (((m_Engine.m_pResultArea[pnMove + 1] & 0xffff) << 8) |
                    (m_Engine.m_pResultArea[pnMove] & 0xff));
            if (wTemp == wPoint) {
                nFound = 1;
                break;
            }
            nCount--;
            pnMove += sizeofSIMULMOVE;
        }
        return nFound;
    }

    short RegMove(short wPoint, int pnResult) {

        int pnMove = m_Engine.m_wResultCurr;

        if (m_Engine.m_wResultCurr > MAXSIMULRESULTS - sizeofSIMULMOVE)
            return 0;

        //H.Joon-2007/03/07>>
        //m_Engine.m_pTempArea[pnMove] = (short) ( (wPoint >> 8) & 0xff);
        m_Engine.m_pTempArea[pnMove] = (short) (wPoint & 0xff);
        //<<
        m_Engine.m_pTempArea[pnMove + 1] = (short) ( ((wPoint & 0xFFFF) >>> 8) & 0xff);
        m_Engine.m_pTempArea[pnMove + 2] = 1;
        m_Engine.m_pResultArea[pnResult] += 1;
        m_Engine.m_wResultCurr += sizeofSIMULMOVE;
        return 1;
    }

    void AssignResultOnRel() {
        int pnResult = m_Engine.m_wResultCurr;

        m_Engine.m_pResultArea[pnResult] = 1;
        m_Engine.m_pResultArea[pnResult + 1] = (short) (m_Engine.m_byStr1 & 0xff);
        m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT] = (short) (m_Engine.m_wPoint1 & 0xff);
        m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT + 1] = (short) ( ((m_Engine.m_wPoint1 & 0xFFFF) >> 8) & 0xff);
        m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT + 2] = (short) (m_Engine.m_cSimulStatus & 0xff);
        m_Engine.m_wResultCurr += sizeofSIMULRESULT + sizeofSIMULMOVE;
    }

    void OutputSimulResult() {
        short byStrNum = m_Engine.m_byStrNum;
        short pbyTemp;
        short wSet;
        short nCount;

        if (m_Engine.m_wResultCurr > MAXSIMULRESULTS - 2 * (sizeofSIMULRESULT + sizeofSIMULMOVE))
            return;

        m_Engine.m_pSimulArea1 = m_Engine.m_pSimulArea;
        m_Engine.m_wResultInSecond[byStrNum] = m_Engine.m_wResultCurr;
        wSet = m_Engine.m_wSetInSecond[byStrNum];
        if (wSet == (short) 0xffff) {
            AssignResultOnRel();
            nCount = 1;
            pbyTemp = 0;
            m_Engine.m_pSimulArea1 = m_Engine.m_pTempArea;
        } else {
            nCount = AssignResult(wSet);
            pbyTemp = m_Engine.m_wSetInFirst[byStrNum];
        }

        if (nCount > 0) {
            m_Engine.m_wResultInFirst[byStrNum] = m_Engine.m_wResultCurr;
            nCount = AssignResult(pbyTemp);
            if (nCount > 0)
                return;
        }

        m_Engine.m_wResultCurr = m_Engine.m_wResultInSecond[byStrNum];
        m_Engine.m_wResultInSecond[byStrNum] = (short) 0xffff;
        m_Engine.m_wResultInFirst[byStrNum] = (short) 0xffff;
    }

    short AssignResult(short pbySet) {
        int pnResult = m_Engine.m_wResultCurr;
        int pnMove;
        short nChecked, nCount = 0;
        short cStatus;
        short wTemp;

        try {

            if (m_Engine.m_wResultCurr > MAXSIMULRESULTS - (sizeofSIMULRESULT + sizeofSIMULMOVE))
                return 0;

            pbySet += sizeofSIMULSET;
            nChecked = m_Engine.m_pSimulArea1[pbySet + 4];
            if (nChecked == 0)
                return 0;

            cStatus = m_Engine.m_pSimulArea1[pbySet + 2];
            pbySet += sizeofSIMULUNIT;
            pnMove = pnResult + sizeofSIMULRESULT;
            m_Engine.m_wResultCurr += sizeofSIMULRESULT;
            nCount = 0;

            while (true) {
                wTemp = (short)(((m_Engine.m_pSimulArea1[pbySet + 1] & 0xffff) << 8) |
                        (m_Engine.m_pSimulArea1[pbySet] & 0xff));
                m_Engine.m_pResultArea[pnMove] = (short) (wTemp & 0xff);
                m_Engine.m_pResultArea[pnMove + 1] = (short) ( ((wTemp & 0xFFFF) >> 8) & 0xff);
                m_Engine.m_pResultArea[pnMove + 2] = (short) (cStatus & 0xff);

                pnMove += sizeofSIMULMOVE;
                nCount++;
                m_Engine.m_wResultCurr += sizeofSIMULMOVE;

                if ( (m_Engine.m_wResultCurr > MAXSIMULRESULTS - sizeofSIMULMOVE) ||
                        (nChecked == 1))
                    break;

                do {
                    nChecked --;
                    pbySet += sizeofSIMULPOINT;
                    wTemp = (short) (((m_Engine.m_pSimulArea1[pbySet + 3] & 0xffff) << 8) |
                            (m_Engine.m_pSimulArea1[pbySet + 2] & 0xff));
                    cStatus = (byte)m_Engine.m_pSimulArea1[wTemp + 2];
                } while ( (cStatus == -1) && (nChecked > 1));

                if (cStatus == -1)
                    break;
            }

            m_Engine.m_pResultArea[pnResult] = nCount;
        } catch (Exception e) {
            // System.out.println("AssignResult");
        }
        return nCount;
    }

    short MoveUnit(int pDes, int pSrc) {
        short nPoints, nUnits, i;
        short wPoint;
        int pnPoint;
        short wParent;
        short wChildUnit;

        //MEMCPY(&m_Engine.m_pSimulArea[pDes], &m_Engine.m_pTempArea[pSrc], sizeof(SIMULUNIT));
        System.arraycopy(m_Engine.m_pTempArea, pSrc, m_Engine.m_pSimulArea, pDes, sizeofSIMULUNIT);

//        pnPoint = (short) (m_Engine.m_pTempArea[pSrc + sizeofSIMULUNIT] << 8 & 0xff)
//            + (short) (m_Engine.m_pTempArea[pSrc + sizeofSIMULUNIT + 1] & 0xff);
        pnPoint = pSrc + sizeofSIMULUNIT;
        wParent = (short) (((m_Engine.m_pSimulArea[pDes + 1] & 0xffff) << 8) |
                (m_Engine.m_pSimulArea[pDes] & 0xff));
        if (wParent != 0)
            wParent -= m_Engine.m_wMoveDis;

        m_Engine.m_pSimulArea[pDes] = (short) (wParent & 0xff);
        m_Engine.m_pSimulArea[pDes + 1] = (short) ( ((wParent & 0xFFFF) >>> 8) & 0xff);

        nPoints = m_Engine.m_pSimulArea[pDes + 3];//((LPUNIT)pDes)->byCandis
        nUnits = m_Engine.m_pSimulArea[pDes + 4];//((LPUNIT)pDes)->byChecked
        if (nPoints == 0)
            return 1;

        pDes += sizeofSIMULUNIT;
        pSrc += sizeofSIMULUNIT;
        for (i = 0; i < nPoints; i++) {
            wPoint = (short) (((m_Engine.m_pTempArea[pSrc + 1] & 0xFFFF) << 8) |
                    (m_Engine.m_pTempArea[pSrc] & 0xff));//((NPSIMULPOINT) pSrc)->wPoint
            if (wPoint != 0) {
                if ( (m_Engine.m_byMarkedBoard[wPoint] != 0) ||
                        ( (short) m_Engine.m_nComStonePos == wPoint) ||
                        (m_Engine.m_wOppPoint == wPoint))
                    break;
            }

            //((LPSIMULPOINT) pDes)->wPoint = wPoint;
            m_Engine.m_pSimulArea[pDes] = (short) (wPoint & 0xff);
            m_Engine.m_pSimulArea[pDes + 1] = (short) ( ((wPoint  & 0xFFFF)>>> 8) & 0xff);

            //((NPSIMULPOINT) pSrc)->wChildUnit
            wChildUnit = (short) (((m_Engine.m_pTempArea[pSrc + 3] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pSrc + 2] & 0xff));
            if ((wChildUnit & 0xff) > 0) {
                //((NPSIMULPOINT) pSrc)->wChildUnit
                m_Engine.m_pSimulArea[pDes + 2] = (short) ((wChildUnit - m_Engine.m_wMoveDis) & 0xff);
                m_Engine.m_pSimulArea[pDes + 3] = (short) ((((wChildUnit - m_Engine.m_wMoveDis) & 0xffff) >>> 8) & 0xff);
            } else {
                //((NPSIMULPOINT) pSrc)->wChildUnit
                m_Engine.m_pSimulArea[pDes + 2] = 0;
                m_Engine.m_pSimulArea[pDes + 3] = 0;
            }
            pDes += sizeofSIMULPOINT;
            pSrc += sizeofSIMULPOINT;
        }

        if (i < nPoints)
            return 0;
        if (nUnits == 0)
            return 1;

        for (i = 0; i < nUnits; i++, pnPoint += sizeofSIMULPOINT) {
            //pnPoint += sizeofSIMULPOINT;
            wChildUnit = (short) ( ((m_Engine.m_pTempArea[pnPoint + 3] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnPoint + 2] & 0xff));
            if ((wChildUnit & 0xff) > 0) {
                if (MoveUnit(wChildUnit - m_Engine.m_wMoveDis, wChildUnit - m_Engine.m_wTrackSrc) == 0)
                    break;
            }
        }
        if (i < nUnits)
            return 0;
        return 1;
    }

    void SimulInSecond(short byStrNum, byte n) {
        m_Engine.m_byStrNum = byStrNum;
        Prepare(IS_SECOND);
        SetPaePoint();

        if (n == 1)
            m_Engine.m_cSimulStatus = SimulInSecondOfOSStr();
        else
            m_Engine.m_cSimulStatus = SimulInSecondOfMSStr();

        m_Engine.m_wPoint1 = (short)(((m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT + 1] & 0xffff) << 8) |
                (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT] & 0xff));

        m_Engine.m_wPreSimulEnd = m_Engine.m_wSimulEnd;
        if (SaveSimulDatas() == 0)
            m_Engine.m_wPreSimulEnd = (short) 0xffff;
        else
            m_Engine.m_wSetInSecond[byStrNum] = (short) (m_Engine.m_wPreSimulEnd + sizeofWORD);
    }

    void PrepareSet(int pbyTemp) {
        m_Engine.m_pTempArea[pbyTemp] = 0;
        m_Engine.m_pTempArea[pbyTemp + 1] = 0;
        m_Engine.m_pTempArea[pbyTemp + 2] = m_Engine.m_byStrNum;
        m_Engine.m_pTempArea[pbyTemp + 3] = (short) (m_Engine.m_byColor & 0xff);
        m_Engine.m_wCurrEnd += sizeofSIMULSET;

        m_Engine.m_nCurrUnit = (pbyTemp + sizeofSIMULSET);
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 1] = 0;

        m_Engine.m_wAssignLimit = (short) (m_Engine.m_wCurrEnd + m_Engine.m_wMemOfSet);
        m_Engine.m_wCurrLimit = m_Engine.m_wAssignLimit;

        m_Engine.m_nDepth = 0;
        InitGoodTimes();
    }

    void Prepare(short nHand) {
        int pnTemp = 0;

        if (nHand == IS_SECOND) {
            m_Engine.m_pTempArea[pnTemp] = 0;
            m_Engine.m_pTempArea[pnTemp+1] = 0;
            pnTemp += sizeofWORD;
            m_Engine.m_byColor = ( (m_Engine.m_byStrNum & 1) != 0) ? IS_BLACK : IS_WHITE;
            m_Engine.m_wCurrEnd = sizeofWORD;
        } else {
            m_Engine.m_byColor = ( (m_Engine.m_byStrNum & 1) != 0) ? IS_WHITE : IS_BLACK;
            m_Engine.m_wCurrEnd = 0;
        }

        PrepareSet(pnTemp);
    }

    void SimulInFirstBrief() {
        short byStrNum = m_Engine.m_byStrNum;

        Prepare(IS_FIRST);

        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 2] = 1;
        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 3] = 0;
        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 4] = 0;
        m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

        m_Engine.m_wStatus[byStrNum] = (short) 0xff01;
        m_Engine.m_wBackStatus[byStrNum] = (short) 0xff01;
        m_Engine.m_wTempStatus[byStrNum] = (short) 0xff01;

        if (m_Engine.m_wPreSimulEnd == (short) 0xffff)
            m_Engine.m_wSetInSecond[byStrNum] = (short) 0xffff;
        else {
            short wSimulEnd = m_Engine.m_wSimulEnd;
            if (SaveSimulDatas() == 0) {
                m_Engine.m_wSimulEnd = m_Engine.m_wPreSimulEnd;
                m_Engine.m_wSetInSecond[byStrNum] = (short) 0xffff;
            } else {
                m_Engine.m_pSimulArea[wSimulEnd] = (short) (m_Engine.m_wSimulEnd & 0xff);
                m_Engine.m_pSimulArea[wSimulEnd + 1] = (short) ( ((m_Engine.m_wSimulEnd & 0xffff) >> 8) & 0xff);
                m_Engine.m_wSetInFirst[byStrNum] = wSimulEnd;
                m_Engine.m_pSimulArea[m_Engine.m_wPreSimulEnd] = (short) (m_Engine.m_wSimulEnd & 0xff);
                m_Engine.m_pSimulArea[m_Engine.m_wPreSimulEnd + 1] = (short) ( ((m_Engine.m_wSimulEnd & 0xffff) >> 8) & 0xff);
            }
        }
        return;
    }

    void SimulInFirst(byte n) {
        short byStrNum = m_Engine.m_byStrNum;
        short wStatus;
        short wSimulEnd;
        byte cStatus;

        Prepare(IS_FIRST);

        MEMCPY(m_Engine.m_wStatus, m_Engine.m_wTempStatus, m_Engine.m_wStatus.length);
        m_Engine.m_wStatus[byStrNum] = (short) 0xff01;
        SetPaePoint();

        if (n == 1)
            cStatus = SimulInFirstOfOSStr();
        else
            cStatus = SimulInFirstOfMSStr();

        if (m_Engine.m_wPreSimulEnd == (short) 0xffff)
            m_Engine.m_wSetInSecond[byStrNum] = (short) 0xffff;
        else {
            wSimulEnd = m_Engine.m_wSimulEnd;
            if (SaveSimulDatas() == 0) {
                m_Engine.m_wSimulEnd = m_Engine.m_wPreSimulEnd;
                m_Engine.m_wSetInSecond[byStrNum] = (short) 0xffff;
            } else {
                m_Engine.m_pSimulArea[wSimulEnd] = (short) (m_Engine.m_wSimulEnd & 0xff);
                m_Engine.m_pSimulArea[wSimulEnd + 1] = (short) ( ((m_Engine.m_wSimulEnd & 0xffff) >> 8) & 0xff);
                m_Engine.m_wSetInFirst[byStrNum] = wSimulEnd;
                m_Engine.m_pSimulArea[m_Engine.m_wPreSimulEnd] = (short) (m_Engine.m_wSimulEnd & 0xff);
                m_Engine.m_pSimulArea[m_Engine.m_wPreSimulEnd + 1] = (short) ( ((m_Engine.m_wSimulEnd & 0xffff) >> 8) & 0xff);
            }
        }

        wStatus = MAKEWORD((cStatus & 0xff), (m_Engine.m_cSimulStatus & 0xff));
        m_Engine.m_wStatus[byStrNum] = wStatus;
        m_Engine.m_wBackStatus[byStrNum] = wStatus;
        m_Engine.m_wTempStatus[byStrNum] = wStatus;

        m_Engine.m_byStr1 = 0;
        if ( ( (wStatus & 0x00ff) != 0x00ff) && ( (wStatus & 0xff00) != (short) 0xff00))
            OutputSimulResult();

        RestorStrDatas(PARENT_BACKUP);
    }

    void SimulOfMoreLibsString(short byStrNum) {
        SimulInSecond(byStrNum, (byte) 2);

        if (m_Engine.m_cSimulStatus == -1)
            SimulInFirstBrief();
        else
            SimulInFirst( (byte) 2);
    }

    void LoadTempArea() {
        short i;
        byte cSaved;

        if (!m_Engine.m_bMoveFlag)
            return;

        for (i = STARTPOS; i < ENDPOS; i++) {
            if (m_Engine.byStandardBoard[i] != 0)
                continue;
            if ( (cSaved = m_Engine.m_cTempAreaBoard[i]) != 0) {
                m_Engine.m_cTempAreaBoard[i] = 0;
                m_Engine.m_cAreaBoard[i] |= cSaved;
            }
        }
        m_Engine.m_bMoveFlag = false;
    }

    void EvaluEyePos(short[] nTpEyeCount) {

        byte byGrp, bySurGrp;
        short i, j, k;

        m_Engine.m_nFuncControlFlag = 3; //OtherGrpCalc()

        for (i = STARTPOS; i < ENDPOS; i++) {
            if (m_Engine.m_byBoard[i] != 0)
                continue;
            if ( (m_Engine.m_lBitBoard[i] & 0x1) != 0)
                continue;
            if ( (m_Engine.m_lBitBoard[i] & 0xc) != 0) {
                if ( (byGrp = m_Engine.m_byGroupBoard[i]) == 0) {
                    m_Engine.m_lBitBoard[i] &= 0xfffffff3;

                    nTpEyeCount[0]--;

                    continue;
                }

                m_Engine.m_pbyTmpBitGroupRelAdr = (byGrp + 1) * 10 - 1;

                m_Engine.m_nFuncControlFlag = 3; //OtherGrpCalc()

                m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;
                InterrelGSearch( (byte) 0xff, byGrp); //OtherGrpCalc()

                if (m_Engine.m_byLOResult == 0x00) {
                    m_Engine.m_lBitBoard[i] &= 0xfffffff3;

                    nTpEyeCount[0]--;

                    continue;
                }

                for (j = STARTPOS; j < ENDPOS; j++) {
                    if (m_Engine.m_byBoard[j] != 0)
                        continue;
                    if ( (m_Engine.m_lBitBoard[j] & 0x1) == 0)
                        continue;
                    if ( (bySurGrp = m_Engine.m_byGroupBoard[j]) == 0)
                        continue;

                    for (k = 0; k < (m_Engine.m_byLOResult & 0xff); k++) {
                        if (m_Engine.m_byBufForOtherSurG[k] == bySurGrp)
                            break;
                    }
                    if (k < (m_Engine.m_byLOResult & 0xff))
                        break;
                }
                if (j < ENDPOS)
                    continue;

                m_Engine.m_lBitBoard[i] &= 0xfffffff3;

                nTpEyeCount[0]--;

                continue;

            } else if ( (m_Engine.m_lBitBoard[i] & 0x40000000) != 0) {
                m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;

                if ( (byGrp = m_Engine.m_byGroupBoard[i]) == 0) {
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i - 1]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i - 20]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i + 1]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i + 20]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i - 19]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i - 21]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i + 19]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                    if ( (bySurGrp = (byte) m_Engine.m_byGroupBoard[i + 21]) > 0)
                        m_Engine.m_byBufForOtherSurG[(m_Engine.m_byLOResult++) & 0xff] = bySurGrp;
                } else {
                    m_Engine.m_pbyTmpBitGroupRelAdr = (byGrp + 1) * 10 - 1;

                    InterrelGSearch( (byte) 0xff, byGrp); //OtherGrpCalc()
                }

                if (m_Engine.m_byLOResult == 0x00) {
                    m_Engine.m_lBitBoard[i] &= 0xbfffffff;

                    nTpEyeCount[0]--;

                    continue;
                }

                for (j = STARTPOS; j < ENDPOS; j++) {
                    if (m_Engine.m_byBoard[j] != 0)
                        continue;
                    if ( (m_Engine.m_lBitBoard[j] & 0x1) == 0)
                        continue;
                    if ( (bySurGrp = m_Engine.m_byGroupBoard[j]) == 0)
                        continue;

                    for (k = 0; k < (m_Engine.m_byLOResult & 0xff); k++) {
                        if (m_Engine.m_byBufForOtherSurG[k] == bySurGrp)
                            break;
                    }
                    if (k < (m_Engine.m_byLOResult & 0xff))
                        break;
                }
                if (j < ENDPOS)
                    continue;

                m_Engine.m_lBitBoard[i] &= 0xbfffffff;

                nTpEyeCount[0]--;

                continue;
            }
        }

        for (i = STARTPOS; i < ENDPOS; i++) {
            if ( (m_Engine.m_lBitBoard[i] & 0x40000000) != 0)
                m_Engine.m_lBitBoard[i] |= 0x1;
        }

    }

    boolean InterrelGSearch(byte byWhiteBlackBit, byte byGrpNumber) {
        short nLoopCFlag = 0;
        byte byGSCount, Tmp, byEqGrpNumber, byTmpBit;

        for (byGSCount = 0x48; (byte) byGSCount >= 0; byGSCount -= 8,
                m_Engine.m_pbyTmpBitGroupRelAdr--) {
            //byTmpBit = *m_Engine.m_pbyTmpBitGroupRelAdr;
            byTmpBit = m_Engine.m_byBitGroupRelInfo[m_Engine.m_pbyTmpBitGroupRelAdr];

            if ( (nLoopCFlag == 0) && ( (byTmpBit &= byWhiteBlackBit) != 0)) {
                Tmp = 1;
                byEqGrpNumber = byGSCount;

                while (byTmpBit != 0) {
                    if (nLoopCFlag != 0)
                        break;
                    if ( (byTmpBit & Tmp) != 0) {
                        byTmpBit &= ~Tmp;

                        switch (m_Engine.m_nFuncControlFlag) {
                            case 1:
                                if (!EqGrpInflu(byGrpNumber, byEqGrpNumber))
                                    nLoopCFlag = 1;
                                break;
                            case 3:
                                OtherGrpCalc(byGrpNumber, byEqGrpNumber);
                                break;
                            case 5:
                                if (!CompetitionAbility(byGrpNumber, byEqGrpNumber))
                                    nLoopCFlag = 1;
                                break;
                            case 6:
                                if (!UpdateBitControlBoard(byGrpNumber, byEqGrpNumber))
                                    nLoopCFlag = 1;
                                break;
                            case 7:
                                Info12Sum((short)byEqGrpNumber);
                                break;
                            case 8:
                                if (ArmiesForRGoodD(byGrpNumber, byEqGrpNumber) == 0)
                                    nLoopCFlag = 1;
                                break;
                            case 9:
                                SurGroupCalc(byGrpNumber, byEqGrpNumber);
                                break;
                            default:
                                break;
                        }
                    }

//                    Tmp <<= 1;
                    Tmp = (byte)((Tmp & 0xff) << 1);
                    byEqGrpNumber++;
                }
            }
        }
        if (nLoopCFlag == 1)
            return false;
        else
            return true;
    }

    boolean EqGrpInflu(byte byGrpNum, byte byEqGrpNum) {
        short byTemp = (short) (m_Engine.m_stGroup[byEqGrpNum & 0xff].nImGirth +
                m_Engine.m_stGroup[byEqGrpNum & 0xff].nExtendSize);

        short byInfo2, byInfo3, byRelInfo2[] = {0}
                , byRelInfo3[] = {0};
        byte byTmpHi, byTmpLo;

        byTmpHi = m_Engine.m_byHIResult;
        byTmpLo = m_Engine.m_byLOResult;

        byInfo2 = m_Engine.m_stGroup[byGrpNum & 0xff].nAliveDead;
        byInfo3 = m_Engine.m_stGroup[byGrpNum & 0xff].nImportance;

        if (byTemp > 9) {
            byTemp -= 9;
            //H.Joon-2007/03/07>>
            //byTemp >>= 1;
            byTemp = (short)((byTemp & 0xff) >> 1);
            //<<
            m_Engine.m_stGroup[byGrpNum].nBattleGain += Math.min(byTemp, 9);

//		m_Engine.m_stGroup[byGrpNum].nBattleGain = min( byTemp, 9 );
        }

        if (GetRelInfo2_3(byGrpNum, byEqGrpNum, byRelInfo2, byRelInfo3) == true) {
            if (m_Engine.m_stGroup[byGrpNum & 0xff].nHomeSize >= 0x12) {
                m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;
                return false;
            }
        } else {
            if (byInfo3 >= byRelInfo3[0])
                byInfo3 -= byRelInfo3[0];
            else
                byInfo3 = 0;

            if (byInfo2 <= byRelInfo2[0]) {
                m_Engine.m_byHIResult = byTmpHi;
                m_Engine.m_byLOResult = byTmpLo;
                return true;
            }

            byInfo2 -= byRelInfo2[0];
        }
        byInfo3++;
        byInfo2++;
        //H.Joon-2007/03/07>>
        //byInfo3 >>= 1;
        //byInfo2 >>= 1;
        byInfo3 = (short)((byInfo3 & 0xffff) >> 1);
//        byInfo2 >>>= 1;
        byInfo2= (short)((byInfo2 & 0xffff) >> 1);
        //<<

        if ((m_Engine.m_byLOResult & 0xff) >= (byInfo3 & 0xff))
            m_Engine.m_byLOResult -= (byte) byInfo3;
        else
            m_Engine.m_byLOResult = 0;

        if ((m_Engine.m_byHIResult & 0xff) <= (byInfo2 & 0xff)) {
            m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;
            return false;
        }

        m_Engine.m_byHIResult -= (byte) byInfo2;
        return true;
    }

    void OtherGrpCalc(byte byGrpNumber, byte byEqGrpNumber) {
        if (m_Engine.m_stGroup[byEqGrpNumber & 0xff].nAliveDead != 0)
            ++m_Engine.m_byHIResult; // Not Alive

        m_Engine.m_byBufForOtherSurG[m_Engine.m_byLOResult++] = byEqGrpNumber; // All
    }

    boolean CompetitionAbility(byte byGrpNumber, byte byEqGrpNumber) {
        short byInfo, byAbility;
        short byMyActualNecHome, bySurActualNecHome;
        short byMyAllSEPsOfStrInG, bySurAllSEPsOfStrInG;
        short wTemp;

        short dwMyCmptiAbility, dwSurCmtiAbility;

        byInfo = m_Engine.m_stGroup[byEqGrpNumber & 0xff].nAliveDead;

        if (byInfo == 0x00)
            return true;

        byMyActualNecHome = (short) ( (( (0x20 - m_Engine.m_stGroup[byGrpNumber & 0xff].nHomeSize) *
                m_Engine.m_stGroup[byGrpNumber & 0xff].nAliveDead + 0x80) & 0xffff) >> 8);
        bySurActualNecHome = (short) ( (( (0x20 - m_Engine.m_stGroup[byEqGrpNumber & 0xff].nHomeSize) *
                m_Engine.m_stGroup[byEqGrpNumber & 0xff].nAliveDead + 0x80) & 0xffff) >> 8);

        bySurAllSEPsOfStrInG = m_Engine.m_stGroup[byEqGrpNumber & 0xff].nImGirth;
        byMyAllSEPsOfStrInG = m_Engine.m_stGroup[byGrpNumber & 0xff].nImGirth;

        if (((bySurAllSEPsOfStrInG & 0xff) * (byMyAllSEPsOfStrInG & 0xff)) == 0)
        {
            // System.out.println("Error divided by 0...");
            return false; //critical code by lci
        }

        dwMyCmptiAbility = (short) (((bySurActualNecHome & 0xff) * (byMyAllSEPsOfStrInG & 0xff) + 0x80) /
                (bySurAllSEPsOfStrInG & 0xff) * (byMyAllSEPsOfStrInG & 0xff) + 0x80);

        if (dwMyCmptiAbility > 0x10000) {
            m_Engine.m_stGroup[byGrpNumber].nCompetition = 0x14;
            return false;
        }

        dwSurCmtiAbility = (short) ( (byMyActualNecHome * bySurAllSEPsOfStrInG + 0x80) / byMyAllSEPsOfStrInG
                * bySurAllSEPsOfStrInG + 0x80);

        Adr_Result:
        do {
            if ((dwSurCmtiAbility & 0xffff) <= 0x10000) {
                if ((dwMyCmptiAbility & 0xffff) < (dwSurCmtiAbility & 0xffff)) {
                    wTemp = (short) (dwSurCmtiAbility - dwMyCmptiAbility);

                    if ((wTemp & 0xffff) < 0x0e00)
                        wTemp = (short) - wTemp;
                    else {
                        byAbility = 0xe5;
                        break Adr_Result;
                    }
                } else {
                    wTemp = (short) (dwMyCmptiAbility - dwSurCmtiAbility);

                    if ((wTemp & 0xffff) >= 0x0a00) {
                        m_Engine.m_stGroup[byGrpNumber & 0xff].nCompetition = 0x14;
                        return false;
                    }
                }

                if (m_Engine.m_stGroup[byGrpNumber & 0xff].nExtendSize > 2)
                    wTemp += ( (m_Engine.m_stGroup[byGrpNumber & 0xff].nExtendSize - 2) * 0x100) >> 2;

                wTemp = (short) ( ((wTemp & 0xffff) << 1) + 0x0080);
                byAbility = HIBYTE(wTemp);
            } else
                byAbility = 0xe5;
        } while (false);

        if ( (byte) byAbility > (byte) m_Engine.m_stGroup[byGrpNumber & 0xff].nCompetition) // not jle
            m_Engine.m_stGroup[byGrpNumber & 0xff].nCompetition = (short)(byAbility & 0xff);
        return true;
    }

    boolean UpdateBitControlBoard(byte byGrpNum, byte byEqGrpNum) {
        if (m_Engine.m_stGroup[byEqGrpNum & 0xff].nAliveDead <= 0xe4)
            return true;
        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == -16)
                continue;

            if ( (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == 0) &&
                    (FindSameGrpAround(byGrpNum)))
                m_Engine.m_lBitBoard[m_Engine.m_nMainPosition] |= 0x40000000;
        }
        return false;
    }

    short ArmiesForRGoodD(byte byMainGrpNum, byte bySurGrpNum) {
        short byGroupCount;
        short byBothInfo2[] = new short[1], byBothInfo3[] = new short[1];
        short byMainImport;
        short byMainAliveDead;

        if ( (m_Engine.m_stGroup[bySurGrpNum & 0xff].nExtendSize & 0x80) != 0)
            return -1;

        byGroupCount = m_Engine.m_nTotalGroupCount;
        byGroupCount++;
        m_Engine.m_stGroup[bySurGrpNum & 0xff].nExtendSize |= 0x80;

        byMainAliveDead = m_Engine.m_stGroup[byGroupCount].nAliveDead;
        byMainImport = m_Engine.m_stGroup[byGroupCount].nImportance;

        //Strong Upversion
        if (GetRelInfo2_3( (byte) byGroupCount, (byte) bySurGrpNum, byBothInfo2, byBothInfo3)) {
            if (m_Engine.m_stGroup[byGroupCount].nHomeSize >= 0x12) {
                m_Engine.m_byHIResult = 0;
                m_Engine.m_byLOResult = 0;
                return 0;
            }
        } else {
            byMainImport -= byBothInfo3[0];
            if (byMainAliveDead <= byBothInfo2[0])
                return 1;
            byMainAliveDead -= byBothInfo2[0];
        }
        byMainImport = (byte) ( (byMainImport + 1) / 2);
        byMainAliveDead = (byte) ( (byMainAliveDead + 1) / 2);

        if ((m_Engine.m_byLOResult & 0xff) >= byMainImport)
            byMainImport = (byte) (m_Engine.m_byLOResult - byMainImport);
        else
            byMainImport = 0x0;

        if ((m_Engine.m_byHIResult & 0xff) <= byMainAliveDead) {
            m_Engine.m_byHIResult = 0;
            m_Engine.m_byLOResult = 0;
            return 0;
        } else {
            byMainAliveDead = (short) ((m_Engine.m_byHIResult & 0xff) - byMainAliveDead);
            m_Engine.m_byHIResult = (byte) byMainAliveDead;
            m_Engine.m_byLOResult = (byte) byMainImport;
            return 1;
        }

    }

    void SurGroupCalc(byte byGrpNumber, byte byEqGrpNumber) {
        if ( ( (byGrpNumber ^ byEqGrpNumber) & 1) != 0) {
            if (m_Engine.m_stGroup[byEqGrpNumber & 0xff].nAliveDead != 0)
                ++m_Engine.m_byHIResult;
        } else {
            if ( (m_Engine.m_stGroup[byEqGrpNumber & 0xff].nAliveDead <= 0xE4)
                    || (m_Engine.m_stGroup[byEqGrpNumber & 0xff].nHomeSize > 7)
                    || (m_Engine.m_stGroup[byEqGrpNumber & 0xff].nExtendSize > 3))

                ++m_Engine.m_byLOResult;
        }
    }

    boolean GetRelInfo2_3(byte byGrpNum, byte byEqGrpNum, short[] pbyRelInfo2, short[] pbyRelInfo3) {
        short byInfo6, byInfo5;
        short wInfo;

        pbyRelInfo2[0] = 0;

        byInfo6 = m_Engine.m_stGroup[byEqGrpNum & 0xff].nExtendSize;

        if (0xff - (byInfo6 & 0xff) >= m_Engine.m_stGroup[byGrpNum & 0xff].nExtendSize) {
            byInfo6 += m_Engine.m_stGroup[byGrpNum & 0xff].nExtendSize;

            byInfo5 = m_Engine.m_stGroup[byEqGrpNum & 0xff].nHomeSize;

            if (0xff - (byInfo5 & 0xff) >= m_Engine.m_stGroup[byGrpNum & 0xff].nHomeSize) {
                byInfo5 += m_Engine.m_stGroup[byGrpNum & 0xff].nHomeSize;

                wInfo = LiveDeadDegree( (byte) byInfo5, (byte) byInfo6, byGrpNum);

                pbyRelInfo2[0] = (short)(HIBYTE(wInfo) & 0xff);
                pbyRelInfo3[0] = (short)(LOBYTE(wInfo) & 0xff);
            }
        }

        if (pbyRelInfo2[0] == 0)
            return true;
        else
            return false;
    }

    short LiveDeadDegree(byte byInfo5, byte byInfo6, byte byGrpNum) {
        byte byDeadDegree;
        byte byCorrExtendPoss;
        byte byInfo2 = 0, byInfo3 = 0;
        short byTemp;
        //short byInfo6_tmp = byInfo6;
        byte byTemp1;
        short wTemp, wTemp1;

        if ( ((byInfo5 & 0xff) >= 0x18) || ((byInfo6 & 0xff) >= 0x20) )
            return 0;

        byDeadDegree = (byte) (0x18 - (byInfo5 & 0xff));

        if ((byInfo6 & 0xff) >= 0x13) {
            byInfo2 = (byte) (0x20 - (byInfo6 & 0xff));
//		byInfo2=(byte)(((short)byInfo2*(short)byDeadDegree)/4);
            byInfo2 = (byte)(((byInfo2 & 0xff) * (byDeadDegree & 0xff)) / 2);
            //byInfo2 /= 2;
            byInfo2 = (byte)((byInfo2 & 0xff) / 2);
        }

        if ((byInfo6 & 0xff) < 5) {
            if ((byInfo6 & 0xff) >= 2)
                byCorrExtendPoss = (byte) ((byInfo6 & 0xff) - 2);
            else
                byCorrExtendPoss = 0;
        } else if (byInfo6 == 5)
            byCorrExtendPoss = 4;
        else
            byCorrExtendPoss = byInfo6;

        byTemp = (short) (((byCorrExtendPoss & 0xff) / 7) + 3);

        wTemp = (short) (((m_Engine.byConstExtPoss[(byCorrExtendPoss & 0xff) % 7] & 0xff) *
                (byDeadDegree & 0xff)) >>> byTemp);

        if ((byInfo6 & 0xff) < 0x13) {
            if ((wTemp & 0xffff) >= 0xff)
                byInfo2 = (byte) 0xfe;
            else
                byInfo2 = LOBYTE(wTemp);
        }

        if ((byInfo6 & 0xff) < 0x06) {
            wTemp = GetInfo3(byGrpNum, byInfo2);
            byInfo3 = HIBYTE(wTemp);
            return ((short)(byInfo3 | ((short)(byInfo2 & 0xff)) << 8));
        }

        //H.Joon-2007/03/07>>
        //wTemp >>= 3;
//        wTemp >>>= 3;
        wTemp = (short)((wTemp & 0xffff) >>> 3);
        //<<

        if ((byInfo6 & 0xff) >= 0x1c) {
            byInfo3 = LOBYTE(wTemp);
//            return ((short)(((byte) (byInfo3)) | ( (short)byInfo2) << 8));
            return (short)( ((byte)byInfo3) | (((short)(byInfo2 & 0xff)) << 8) );
        }

        byTemp = (short) ((byInfo6 & 0xff) - 0x06);
        byTemp1 = m_Engine.byInfo6_3[byTemp];
        wTemp = (short) ((LOBYTE(wTemp) & 0xff) *(byTemp1 & 0xff));

        byTemp = (short) (0x1b - (byInfo6 & 0xff));
        byTemp1 += m_Engine.byInfo6_3[byTemp];
        wTemp1 = GetInfo3(byGrpNum, byInfo2);
        wTemp1 = (short) ((HIBYTE(wTemp1) & 0xff) * (m_Engine.byInfo6_3[byTemp] & 0xff));

        wTemp += wTemp1;
        //H.Joon-2007/03/07>>
        //wTemp += (byTemp1 >> 1);
        wTemp += ((byTemp1 & 0xff) >>> 1);
        //<<

//	byInfo3=wTemp/byTemp1;
        byInfo3 = (byte) ((wTemp & 0xffff) / (byTemp1 & 0xff));
        return ((short) (((byte) (byInfo3 & 0xff)) | ((short)((byte)(byInfo2 & 0xff))) << 8));
    }

    short GetInfo3(byte byGrpNum, byte byInfo2) {
        byte byHi, byLo;
        short wTemp;

        byLo = (byte) m_Engine.m_stGroup[byGrpNum].nTotalSize;
        byHi = byLo;
        if ((byInfo2 & 0xff) < 0xfe)
            wTemp = (short) ((byLo & 0xff) * (byInfo2 & 0xff) + 0x0080);
        else
            wTemp = ((short)(((byte)(byLo & 0xff)) | ((short)((byte)(byHi & 0xff))) << 8));
        return wTemp;
    }

    void BoardWeightCalc() {
        short nTempBoardPos = m_Engine.m_nBoardPos;

        byte byStringNumber;

        byte cMainWeight[] = new byte[1];
        byte byBitThatManyTwosIs[] = new byte[1];
        short nColor;
        short nSidePos;
        short nSideCount;

        short nWhiteSumWeight = 0;
        short nBlackSumWeight = 0;

        short wOtherStoneCoord[] = new short[1], wAnOtherStoneCoord[] = new short[1],
                wNextSideStoneCoord[] = new short[1],  wSideStoneCoord[] = new short[1];
        byte byOtherStoneCount[] = new byte[1];
        byte byStandard;
        byte cInitialWeight;
        short byStrNber;

        byte byStrNumber;
        byte cSideWeight, cTempWeight;
        short nTempSavedPos, nDeltaPos, ndPos;

        m_Engine.m_wWhiteTSize9 = 0;
        m_Engine.m_wBlackTSize9 = 0;

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        for (m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos++) {
            //HJ_Debug>>
//            if ( bDebug )
//            System.out.println("m_nMainPos = " + m_Engine.m_nMainPos);
            //<<
            byStringNumber = m_Engine.m_byBoard[m_Engine.m_nMainPos];
            if ( (byte) byStringNumber > 0) {
                m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = 0;
                StonePosWeight(byStringNumber);
            }
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        //by Jong 2004/08/17
        if ( m_Engine.m_nGameLevel > 2 )
        {
            for( m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos ++ )
            {
//	    if( byStandardBoard[m_nMainPos] != 0 )
//		continue;
                if ( ( m_Engine.m_byPosBoard[ m_Engine.m_nMainPos ] > 3 ) &&
                        ( m_Engine.m_cAreaBoard[ m_Engine.m_nMainPos ] == 1 ) )
                {
                    m_Engine.m_nBoardPos = m_Engine.m_nMainPos;
                    AstonePosWeight( true );
                    m_Engine.m_cAreaBoard[ m_Engine.m_nMainPos ] = 0;
                }
            }
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        for (m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos++) {
            if (m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] == -1) {
                PotentialWeightOfSpace();
                m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = -2;
            }
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        //by Jong 2004/8/17

        if( m_Engine.m_nGameLevel > 1 )
            FourCornerWeight();

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        for (m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos++) {

            if (m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] >= 0)
                continue;

            cMainWeight[0] = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos];

            if ( (cMainWeight[0] <= 2) && (cMainWeight[0] >= -2))
                continue;

            nColor = (short) ( (cMainWeight[0] > 2) ? 1 : 2);

            if (DiagInfluCalc(nColor, byBitThatManyTwosIs, cMainWeight)) {
                if ((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) < 3) {
                    m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
                    continue;
                }

                if (m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0) {
                    m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
                    continue;
                } else {
                    byStandard = 1;

                    SideOtherStone(nColor, byStandard, byOtherStoneCount, wOtherStoneCoord,
                            wAnOtherStoneCoord);

                    if ((byOtherStoneCount[0] & 0xff) <= (byStandard & 0xff)) {
                        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
                        continue;
                    }
                    cMainWeight[0] = 3;
                }

                if (nColor == 2)
                    cMainWeight[0] = (byte) - cMainWeight[0];

                m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
                continue;
            } else {
                byBitThatManyTwosIs[0] |= (byte)(cMainWeight[0] & 0xff);
                byBitThatManyTwosIs[0] = (byte) - byBitThatManyTwosIs[0];

                m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = byBitThatManyTwosIs[0];

                if (m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0) {
                    if (nColor == 2)
                        cMainWeight[0] = (byte) - cMainWeight[0];

                    m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
                    continue;
                }
            }

            if (nColor == 2)
                cMainWeight[0] = (byte) - cMainWeight[0];

            for (nSideCount = 0x0; nSideCount < 4; nSideCount++) {
                nSidePos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSideCount]);

                if (nColor == 1)
                    WhiteSideWeight(nSidePos, cMainWeight);
                else
                    BlackSideWeight(nSidePos, cMainWeight);
            }

            if ( (cMainWeight[0] == 0x6) || (cMainWeight[0] == -6)) {
                for (nSideCount = 0x0; nSideCount < 4; nSideCount++) {
                    nSidePos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSideCount]);

                    byStrNumber = m_Engine.m_byBoard[nSidePos];

                    if ( (byte) byStrNumber <= 0)
                        continue;

                    if ( ( (byStrNumber ^ nColor) & 1) != 0) {
                        cMainWeight[0] = (byte) (cMainWeight[0] + (cMainWeight[0] / 2));
                        break;
                    }
                }
            }

            m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        for( m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos ++ )
        {
//	    if( byStandardBoard[m_nMainPos] != 0 )
//		conntinue;

            //HJ_Debug>>
            //System.out.println("m_nMainPos = " + m_Engine.m_nMainPos);
            //<<
            if(m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] >= 0)
                continue;

            if( m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0 )
                continue;

            cMainWeight[0] = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos];

            if( cMainWeight[0] == -1 )
            {
//		CaseOfFF( m_nMainPos - 1 );
//		CaseOfFF( m_nMainPos - 20 );
//		CaseOfFF( m_nMainPos + 1 );
//		CaseOfFF( m_nMainPos + 20 );

                continue;
            }
            else if( cMainWeight[0] == 0x01 )
            {
//		CaseOf01( m_nMainPos - 1 );
//		CaseOf01( m_nMainPos - 20 );
//		CaseOf01( m_nMainPos + 1 );
//		CaseOf01( m_nMainPos + 20 );

                continue;
            }
            else
            {
                //short	nColor;
                short nFlagOfOppoStone = 0;
                byte cSubWeight;

                if( cMainWeight[0] == -9 )
                {
                    nColor = 0x00;
                    cMainWeight[0] = -10;
                    cSubWeight = -6;
                }
                else if( cMainWeight[0] == 0x9 )
                {
                    nColor = 0x01;
                    cMainWeight[0] = 10;
                    cSubWeight = 6;
                }
                else
                    continue;

                short nTmp[] = new short[1];
                nTmp[0] = nFlagOfOppoStone;
                boolean ret = SurSearch( nColor,cSubWeight,nTmp );
                nFlagOfOppoStone = nTmp[0];
                if( !ret )
                {
                    if( nFlagOfOppoStone == 0 )
                        cMainWeight[0] += cMainWeight[0] / 2;
                    else
                        continue;
                }
                m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
            }
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        for (m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos++) {
            if (m_Engine.byStandardBoard[m_Engine.m_nMainPos] != 0)
                continue;

            cMainWeight[0] = m_Engine.m_cAreaBoard[m_Engine.m_nMainPos];

            if (cMainWeight[0] <= -4) {
                m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = -2;
                cMainWeight[0] = (byte) - cMainWeight[0];
                byBitThatManyTwosIs[0] = (byte) (cMainWeight[0] & 0x10);
                cMainWeight[0] &= 0x0F;

                if ( (cInitialWeight = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos]) > 0)
                    nColor = 1;
                else {
                    nColor = 0;
                    cInitialWeight = (byte) - cInitialWeight;
                }
                if (cInitialWeight > 6)
                    continue;

                EyeBasedDataCalc(nColor, byBitThatManyTwosIs[0], cMainWeight);

                if (!SpecialValue(cMainWeight[0])) { //4,7,8
                    if (nColor == 0)
                        cMainWeight[0] = (byte) - cMainWeight[0];
                    m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cMainWeight[0];
                }
            }
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        //by Jong 2004/8/14
        if( m_Engine.m_nGameLevel > 1 )
            CornerEyeBase();

        //HJ_Debug>>
//    if ( bDebug )
//    OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<


        for(  m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos ++ )
        {
//		if( byStandardBoard[m_nMainPos] != 0 )
//			continue;

            if( ( m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] >= 0 ) ||
                    ( m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0 ) )
                continue;

            cMainWeight[0] = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos];

            if( cMainWeight[0] == 0 )
                m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = 0;

            if( cMainWeight[0] > 5 )
                continue;

            if( cMainWeight[0] == 4 )
                continue;

            if( cMainWeight[0] >= 3 )
                nColor = 1;
            else if ( cMainWeight[0] < -5 )
                continue;
            else if ( cMainWeight[0] == -4 )
                continue;
            else if ( cMainWeight[0] <= -3 )
                nColor = 0;
            else
                continue;

            if( SideOtherStone( nColor, 2, byOtherStoneCount, wSideStoneCoord, wAnOtherStoneCoord ) == 0 )
                continue;

            if( byOtherStoneCount[0] != 2 )
                continue;

            if( m_Engine.m_byBoard[ wSideStoneCoord[0] & 0xffff ] != 0 )
                continue;

            cSideWeight = m_Engine.m_cWeightBoard[ wSideStoneCoord[0] & 0xffff ];

            if( nColor != 0 )
            {
                if( cSideWeight != 3 )
                {
                    if( cSideWeight == 5 )
                    {
                        if ( cSideWeight == cMainWeight[0] )
                            continue;
                    }
                    else
                    {
                        wSideStoneCoord[0] = wAnOtherStoneCoord[0];

                        if( m_Engine.m_byBoard[ wSideStoneCoord[0] & 0xffff ] != 0 )
                            continue;

                        cSideWeight = m_Engine.m_cWeightBoard[ wSideStoneCoord[0] & 0xffff ];

                        if( cSideWeight != 3 )
                        {
                            if( cSideWeight != 5 )
                                continue;

                            if( cSideWeight == cMainWeight[0] )
                                continue;
                        }
                    }
                }
            }
            else
            {
                if( cSideWeight != -3 )
                {
                    if( cSideWeight == -5 )
                    {
                        if ( cSideWeight == cMainWeight[0] )
                            continue;
                    }
                    else
                    {
                        wSideStoneCoord[0] = wAnOtherStoneCoord[0];

                        if( m_Engine.m_byBoard[ wSideStoneCoord[0] & 0xffff ] != 0)
                            continue;

                        cSideWeight = m_Engine.m_cWeightBoard[ wSideStoneCoord[0] & 0xffff ];

                        if( cSideWeight != -3 )
                        {
                            if( cSideWeight != -5 )
                                continue;
                            if( cSideWeight == cMainWeight[0] )
                                continue;
                        }
                    }
                }
            }

            nTempSavedPos = m_Engine.m_nMainPos;

            m_Engine.m_nMainPos = wSideStoneCoord[0];

            if( SideOtherStone( nColor, 2, byOtherStoneCount, wNextSideStoneCoord, wAnOtherStoneCoord ) == 0 )
            {
                m_Engine.m_nMainPos = nTempSavedPos;
                continue;
            }

//		short	nDeltaX = m_byBoardX - nTempSavedX;
//		short	nDeltaY = m_byBoardY - nTempSavedY;
            nDeltaPos = (short)(m_Engine.m_nMainPos - nTempSavedPos);

            m_Engine.m_nMainPos = nTempSavedPos;

            if ( byOtherStoneCount[0] != 2 )
                continue;

//		short x, y, dx, dy;
            if( ( nDeltaPos == 1 )||( nDeltaPos == -1 ))
                ndPos = 20;
            else
                ndPos = 0;
//		if( nDeltaX  & 1)
//		{
//			dx = 0; dy = 1;
//		}
//		else
//		{
//			dx = 1; dy =0;
//		}


            if( m_Engine.byStandardBoard[ m_Engine.m_nMainPos + ndPos ] == 0 )
//		if(((m_byBoardX + dx) < m_byBoardSize) && ((m_byBoardY + dy) < m_byBoardSize))
            {
                ndPos = (short)-ndPos;
//			dx = -dx;
//			dy = -dy;

//			if(( (m_byBoardX + dx) >= 0) && ((m_byBoardY + dy) >= 0))
                if( m_Engine.byStandardBoard[ m_Engine.m_nMainPos + ndPos ] == 0 )
                {
                    if( cSideWeight > 0 )
                        cTempWeight = 4;
                    else
                    {
                        cSideWeight = (byte)-cSideWeight;
                        cTempWeight = -4;
                    }

                    if( cSideWeight == 5 )
                        m_Engine.m_cWeightBoard[ wSideStoneCoord[0] & 0xffff ] = cTempWeight;
                    else
                        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cTempWeight;

                    continue;
                }
            }


//		x = (short) HIBYTE( wSideStoneCoord ) - dx + nDeltaX ;
//		y = (short) LOBYTE( wSideStoneCoord ) - dy + nDeltaY ;

//		if((x >= 0) && (x < m_byBoardSize) && (y >= 0) && (y < m_byBoardSize) &&
//				(m_byBoard[y][x] == 0))
            if( (m_Engine.byStandardBoard[ (wSideStoneCoord[0] & 0xffff) - ndPos + nDeltaPos ] == 0)||
                    (m_Engine.byStandardBoard[ (wSideStoneCoord[0] & 0xffff) - ndPos - nDeltaPos ] == 0))
                continue;

//		x =  m_byBoardX - dx - nDeltaX;
//		y =  m_byBoardY - dy - nDeltaY;

//		if((x >= 0) && (x < m_byBoardSize) && (y >= 0) && (y < m_byBoardSize) &&
//				(m_byBoard[y][x] == 0))
//					continue;

            if( cSideWeight > 0 )
                cTempWeight = 4;
            else
            {
                cSideWeight = (byte)-cSideWeight;
                cTempWeight = -4;
            }

            if( cSideWeight == 5 )
                m_Engine.m_cWeightBoard[ wSideStoneCoord[0] & 0xffff ] = cTempWeight;
            else
                m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cTempWeight;
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<


        for (m_Engine.m_nMainPos = STARTPOS; m_Engine.m_nMainPos < ENDPOS; m_Engine.m_nMainPos++) {
            if (m_Engine.byStandardBoard[m_Engine.m_nMainPos] != 0)
                continue;

            m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = 0;

            cMainWeight[0] = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos];

            byStrNber = m_Engine.m_byBoard[m_Engine.m_nMainPos];

            if (cMainWeight[0] >= 1) {
                if (cMainWeight[0] == 1) {
                    if ( (byStrNber == 0) || ( (m_Engine.m_wStatus[byStrNber] & 4) != 0)) {
                        cMainWeight[0] = 3;
                        nWhiteSumWeight += cMainWeight[0];
                    }
//#ifdef UPDATE
//#else
                    else
                        nWhiteSumWeight += cMainWeight[0];
//#endif
                } else if (cMainWeight[0] == 4) {
//UpDate by JSH
                    if ( (byStrNber > 0) && (m_Engine.m_wStatus[byStrNber] == 0x01ff))
                        cMainWeight[0] = 6;
                    else

//End Of UpDate by JSH
                        cMainWeight[0] = 3;
                    nWhiteSumWeight += cMainWeight[0];
                } else {
                    //In Case Of 5,3,2.
                    // No Problem In Two Csae.
//#ifdef UPDATE
//                    if (cMainWeight[0] >= 6)
//                        cMainWeight[0] = 6;
//                    else if ( (byStrNber == 0) || ((m_Engine.m_wStatus[byStrNber] & 0xffff) >= 0x400))
//                        cMainWeight[0] -= 2;
//                    nWhiteSumWeight += cMainWeight[0];
//#else
                    if( cMainWeight[0] > 6 )
                        cMainWeight[0] = 6;
                    nWhiteSumWeight += cMainWeight[0];
//#endif
                }
            } else if (cMainWeight[0] != 0) { //upversion
                if (cMainWeight[0] == -1) {
                    byStrNber = (short)(m_Engine.m_byBoard[m_Engine.m_nMainPos] & 0xff);
                    if ( (byStrNber == 0) || ( (m_Engine.m_wStatus[byStrNber] & 4) != 0)) {
                        cMainWeight[0] = -3;
                        nBlackSumWeight -= cMainWeight[0];
                    }
//#ifdef UPDATE
//#else
                    else
                        nBlackSumWeight -= cMainWeight[0];
//#endif
                } else if (cMainWeight[0] == -4) {
                    //UpDate by JSH
                    if ( (byStrNber > 0) && (m_Engine.m_wStatus[byStrNber] == 0x1ff))
                        cMainWeight[0] = -6;
                    else

                        //End Of UpDate by JSH
                        cMainWeight[0] = -3;
                    nBlackSumWeight -= cMainWeight[0];
                } else {
                    //In Case Of 5,3,2.
                    // No Problem In Two Csae.
//#ifdef UPDATE
//                    if (cMainWeight[0] <= -6)
//                        cMainWeight[0] = -6;
//                    else if ((byStrNber == 0) || ((m_Engine.m_wStatus[byStrNber] & 0xffff) >= 0x400))
//                        cMainWeight[0] += 2;
//
//                    nBlackSumWeight -= cMainWeight[0];
//#else
                    if( cMainWeight[0] <= -6 )
                        cMainWeight[0] = -6;
                    nBlackSumWeight -= cMainWeight[0];
//#endif
                }
            }
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        m_Engine.m_nBoardPos = nTempBoardPos;

        if ( (byte) m_Engine.m_byNewGroupNumber < 0) {
            m_Engine.m_nDifOfTwoT9 = (short) (nWhiteSumWeight - nBlackSumWeight);
            return;
        }

        for (byStrNber = 1; byStrNber < MAX_STRINGCOUNT; byStrNber++) {
            if ( (m_Engine.m_wStatus[byStrNber] & 4) == 0)
                continue;
            if (IsWhite(byStrNber)) {
                nWhiteSumWeight += (6 * (m_Engine.m_nStoneCount[byStrNber] & 0xff));
                m_Engine.m_wBlackTSize9 += (6 * (m_Engine.m_nStoneCount[byStrNber] & 0xff));
            } else {
                nBlackSumWeight += (6 * (m_Engine.m_nStoneCount[byStrNber] & 0xff));
                m_Engine.m_wWhiteTSize9 += (6 * (m_Engine.m_nStoneCount[byStrNber] & 0xff));
            }
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        if ( (byte) m_Engine.m_byNewStringNumber != 0) {
            if (m_Engine.m_byTurnColor == 2) {
                nWhiteSumWeight += (12 * m_Engine.m_nDeadStoneCount);
                m_Engine.m_wBlackTSize9 += (12 * m_Engine.m_nDeadStoneCount);
            } else {
                nBlackSumWeight += (12 * m_Engine.m_nDeadStoneCount);
                m_Engine.m_wWhiteTSize9 += (12 * m_Engine.m_nDeadStoneCount);
            }
        }

        //HJ_Debug>>
//        if ( bDebug )
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        m_Engine.m_nDifOfTwoT9 = (short) (nWhiteSumWeight - nBlackSumWeight);
    }

    void GroupLinkByPat()
    {
        byte	byTempStrNum;
        byte	byPatOfDiag;
        byte	byPatOfSide;
        byte	byFirstGrpNum,bySecondGrpNum;
        byte	byTemp;
        short   nTp;

        if( (m_Engine.m_byPosBoard[m_Engine.m_nMainPosition] & 0xff) < 3 )
            return;

        byPatOfSide = m_Engine.m_byLocalPattern[m_Engine.m_nMainPosition][0];
        byPatOfDiag = m_Engine.m_byLocalPattern[m_Engine.m_nMainPosition][1];

        switch( byPatOfSide )
        {
            case 0x11:
            case 0x22:
                if( m_Engine.m_byBoard[m_Engine.m_nMainPosition-1] != (byte)0xf0 )
                {
                    byTempStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition-1];
                    if( (m_Engine.m_byLiberties[byTempStrNum & 0xff] & 0xff) <= 2 )
                        return;
                }

                if( m_Engine.m_byBoard[m_Engine.m_nMainPosition+1] != (byte)0xf0 )
                {
                    byTempStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition+1];
                    if( (m_Engine.m_byLiberties[byTempStrNum & 0xff] & 0xff) <= 2 )
                        return;
                }

                if( byPatOfSide == 0x22 )
                {
                    if( ( (byPatOfDiag & 0x14) != 0 ) &&
                            ( (byPatOfDiag & 0x41 ) != 0 ) )
                        return;
                }
                else
                {
                    if( ( (byPatOfDiag & 0x28) != 0 ) &&
                            ( (byPatOfDiag & 0x82) != 0 ) )
                        return;
                }

                bySecondGrpNum = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition-1];
                byFirstGrpNum = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition+1];
                break;

            case 0x44:
            case -0x78://0x88:
                if( m_Engine.m_nMainPosition > 40 )
                {
                    byTempStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition - 20];
                    if( (m_Engine.m_byLiberties[byTempStrNum & 0xff] & 0xff) <= 2 )
                        return;
                }

                if( m_Engine.m_nMainPosition < (ENDPOS - 20 ))
                {
                    byTempStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition + 20];
                    if( (m_Engine.m_byLiberties[byTempStrNum & 0xff] & 0xff) <= 2 )
                        return;
                }

                if( byPatOfSide == (byte)0x88 )
                {
                    if( ( (byPatOfDiag & 0x05) != 0 ) &&
                            ( (byPatOfDiag & 0x50 ) == 0 ) )
                        return;
                }
                else
                {
                    if( ( (byPatOfDiag & 0x0a) != 0 ) &&
                            ( (byPatOfDiag & 0xa0) != 0 ) )
                        return;
                }

                bySecondGrpNum = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition - 20];
                byFirstGrpNum = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition + 20];
                break;
            default:
                return;
        }

        byTemp = byFirstGrpNum;
        byTemp ^= bySecondGrpNum;

        if( ( byTemp == 0) || ( ( byTemp & 1) != 0 ) )
            return;

        // In Case Of The Equal Group Or The Opposite Color, Return!

        if( (byFirstGrpNum & 0xff) >= (bySecondGrpNum & 0xff) )
        {
            byTemp = byFirstGrpNum;
            byFirstGrpNum = bySecondGrpNum;
            bySecondGrpNum = byTemp;
        }
        nTp = 0;

        short[] nTmpValue = new short[1];
        nTmpValue[0] = nTp;
        AbsEqInterrel( byFirstGrpNum, bySecondGrpNum, nTmpValue );//upversion
        nTp = nTmpValue[0];
        EqualTwoGroupLink( ENDPOS , byFirstGrpNum, bySecondGrpNum );

        return;
    }

    boolean Get11Grp(short nPos, byte byStrNum )
    {
        byte byGrpNumber;
        short wTemp;

        byGrpNumber = m_Engine.m_byGroupBoard[nPos];

        if((byGrpNumber == 0)
                || (((byGrpNumber ^ byStrNum) & 1) == 0)	//by Jong 2004/8/5
                ||( m_Engine.m_byBoard[nPos] == (byte)0xf0))
            return false;

        wTemp = m_Engine.m_n11GrpCount;
        while(--wTemp >= 0)
        {
            if(m_Engine.m_bySurGrpOf11[wTemp & 0xff] == byGrpNumber)
                return true;
        }
        m_Engine.m_bySurGrpOf11[m_Engine.m_n11GrpCount] = byGrpNumber;
        m_Engine.m_n11GrpCount ++;
        return true;
    }

    void GetNewGrpNumber()
    {
        byte byGrpNumber;

        if((byte)(m_Engine.m_byNewStringNumber) <= (byte)0)
            return;

        m_Engine.m_nMainPosition = m_Engine.m_nPos1;

        byGrpNumber = (byte)m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition];

        if(byGrpNumber == 0)
            return;
        if(((byGrpNumber ^ m_Engine.m_byNewStringNumber) & 0x1) != 0)
            return;
        m_Engine.m_byNewGroupNumber = byGrpNumber;
    }

    void GroupScoreCalc() {
        short byGrpNumber;
        byte byWhiteBlackBit;
        short tmp, j;
        short nGroupNumber;
        short nImport;

        byte Tmp[] = {0};
        short TmpAdr;
        int pbyTmpAdrSave;

        boolean	bNotAliveExistFlag = false;

        short wTemp;
        byte byTempInfo3;
        byte byChangedInfo3;

        short wSurImport;

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        if (m_Engine.nEvaluCount >= 25) {
            m_Engine.m_wWhiteTSize = 0;
            m_Engine.m_wBlackTSize = 0;
            m_Engine.m_byBlackGroupCount = 0;
            m_Engine.m_byWhiteGroupCount = 0;

            if (m_Engine.m_byNewStringNumber == 0x0)
                StringAndWeightMove();

            //HJ_Debug>>
//            if ( m_nCallCount == 3 )
//            OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
            //<<

            return;
        }

        m_Engine.m_nTotalGroupCount = 0;

        MEMSET(m_Engine.m_stGroup, 0);
        MEMSET(m_Engine.m_byBitGroupRelInfo, 0);
        MEMSET(m_Engine.m_stInterrelGroup, 0);

        m_Engine.m_byTotalInterrelCount = 0;

        MEMCPY(m_Engine.m_byGroupBoard, m_Engine.byStandardBoard, m_Engine.m_byGroupBoard.length);

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            try {
                if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xf0) //-16 = -16
                    continue;

                ExpressOfGroup();
            } catch (Exception e) {
                //System.out.println("m_Engine.m_nMainPosition : " + m_Engine.m_nMainPosition);
            }
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        if ( m_Engine.m_nTotalGroupCount == 0 )
        {
            StringAndWeightMove();
            return;
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for (byGrpNumber = (short)(m_Engine.m_nTotalGroupCount & 0xff);
             byGrpNumber > 0; byGrpNumber--) {
            if (m_Engine.m_stGroup[byGrpNumber].nTotalSize != 0)
                continue;

            m_Engine.m_stGroup[byGrpNumber].nImportance = 0;
            m_Engine.m_stGroup[byGrpNumber].nSituation = 0;
            m_Engine.m_stGroup[byGrpNumber].nHomeSize = 0;
            m_Engine.m_stGroup[byGrpNumber].nCompetition = 0;

            if (byGrpNumber >= m_Engine.m_nTotalGroupCount) {
                if (--m_Engine.m_nTotalGroupCount == 0)
                    return;
            }

            for (tmp = 0; tmp < 10; tmp++)
                m_Engine.m_byBitGroupRelInfo[byGrpNumber * 10 + tmp] = 0;

            TmpAdr = GInterRelationAdr( (byte)(m_Engine.m_nTotalGroupCount & 0xff), (byte)byGrpNumber, Tmp );
            Tmp[0] = (byte)~Tmp[0];
            for ( j = 1; j <= m_Engine.m_nTotalGroupCount; j ++ )
            {
                m_Engine.m_byBitGroupRelInfo[TmpAdr] &= Tmp[0];
                TmpAdr -= 10;
            }
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xf0 )
                continue;

            if ((byGrpNumber = (short)(m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] & 0xff)) == 0)
                continue;

            if (m_Engine.m_stGroup[byGrpNumber].nTotalSize == 0)
                m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] = 0;
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xf0)
                continue;

            if (m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] != 0)
                continue;

            //by Jong 2004/8/17
            GroupLinkByPat();

            LinkableGroupFind();
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        //by Jong 2004/8/17
        CaseOfStatus11();
        GetNewGrpNumber();

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<
        if ( m_Engine.m_nGameLevel > 1 )
        {
            if (m_Engine.nBoardScoreCtrl == 1) {
                for (m_Engine.m_nMainPosition = STARTPOS;
                     m_Engine.m_nMainPosition < ENDPOS;
                     m_Engine.m_nMainPosition++) {
                    if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte) 0xf0)
                        continue;
                    ExtendGrpInfo();
                }
            }
        }
        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        m_Engine.m_pbyTmpBitGroupRelAdr = (m_Engine.m_nTotalGroupCount + 1) * 10 - 1;

        pbyTmpAdrSave = m_Engine.m_pbyTmpBitGroupRelAdr;
        m_Engine.m_wCtrlGroupNum = 0;

        for (byGrpNumber = (short)(m_Engine.m_nTotalGroupCount & 0xff);
             byGrpNumber > 0; byGrpNumber--) {
            short nStoneCount = m_Engine.m_stGroup[byGrpNumber].nTotalSize;

            if (nStoneCount == 0) {
                m_Engine.m_stGroup[byGrpNumber].nAliveDead = 0;
                m_Engine.m_stGroup[byGrpNumber].nImportance = 0;
                continue;
            } else {
                m_Engine.m_stGroup[byGrpNumber].nSituation = nStoneCount;

                if (m_Engine.m_stGroup[byGrpNumber].nImportance > 3)
                    nStoneCount++;

                nStoneCount += m_Engine.m_stGroup[byGrpNumber].nCompetition;

                if (nStoneCount > 0xFF)
                    nStoneCount = 0xFF;

                m_Engine.m_stGroup[byGrpNumber].nTotalSize = nStoneCount;
            }
        }

        UpdateInfo9();

        for (byGrpNumber = m_Engine.m_nTotalGroupCount; byGrpNumber > 0; byGrpNumber--) {
            if (m_Engine.m_stGroup[byGrpNumber].nTotalSize != 0) {
                GroupEstimation((byte)byGrpNumber);
            }
        }

        m_Engine.m_pbyTmpBitGroupRelAdr = pbyTmpAdrSave;
        m_Engine.m_nFuncControlFlag = 1; //means call of 73b1 module
        for (byGrpNumber = (short)(m_Engine.m_nTotalGroupCount & 0xff); byGrpNumber > 0; byGrpNumber--)
            UpdateInfo2_3((byte)byGrpNumber);

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for (byGrpNumber = (short)(m_Engine.m_nTotalGroupCount & 0xff); byGrpNumber > 0; byGrpNumber--) {

            m_Engine.m_stGroup[byGrpNumber].nCompetition = 0;
            m_Engine.m_stGroup[byGrpNumber].nImGirth +=
                    m_Engine.m_stGroup[byGrpNumber].nBattleGain;
            m_Engine.m_stGroup[byGrpNumber].nBattleGain = 0;
        }

        m_Engine.m_bMoveDataFlag = false;

        m_Engine.m_pbyTmpBitGroupRelAdr = pbyTmpAdrSave;
        m_Engine.m_nFuncControlFlag = 3; //  Call of OtherGrpCalc()

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for (nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber--) {
            if (m_Engine.m_stGroup[nGroupNumber].nAliveDead > 0xE4) {
                if ( ((byte)(nGroupNumber & 0xff) & 0x01) == 0)
                    byWhiteBlackBit = (byte) 0xaa;
                else
                    byWhiteBlackBit = 0x55;

                m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;
                InterrelGSearch(byWhiteBlackBit, (byte) nGroupNumber); // OtherGrpCalc( ,)

                if (m_Engine.m_byHIResult == 0) {
                    if (!m_Engine.m_bMoveDataFlag)
                        MoveDataSave();
                    m_Engine.m_stGroup[nGroupNumber].nAliveDead = 0xff;
                    m_Engine.m_stGroup[nGroupNumber].nImportance =
                            m_Engine.m_stGroup[nGroupNumber].nTotalSize;
                    KillStringInGroup( (byte) nGroupNumber);
                }
            } else
                m_Engine.m_pbyTmpBitGroupRelAdr -= 0x000a;
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        //by Jong 2004/8/17
        for( m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition ++ )
        {
            if( m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xF0 )
                continue;
            if(m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] == 0x00)
            {
                short nStringCount;

                nStringCount =(short)m_Engine.m_byBoard[m_Engine.m_nMainPosition];
                if(nStringCount != 0)
                {
                    if( !m_Engine.m_bMoveDataFlag )
                        MoveDataSave();
                    m_Engine.m_wStatus[nStringCount] &= 0xfffb;
                    m_Engine.m_wStatus[nStringCount] |= 0x400;
                }
            }
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        if (m_Engine.m_bMoveDataFlag ) {
            short wWhiteTemp;
            short wBlackTemp;

            wWhiteTemp = m_Engine.m_wWhiteTSize9;
            wBlackTemp = m_Engine.m_wBlackTSize9;

            BoardWeightCalc();

            m_Engine.m_nDifOfTwoT9 += m_Engine.m_wWhiteTSize9 - m_Engine.m_wBlackTSize9 + wBlackTemp -
                    wWhiteTemp;

            m_Engine.m_wBlackTSize9 = wBlackTemp;
            m_Engine.m_wWhiteTSize9 = wWhiteTemp;
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        if (m_Engine.m_byNewStringNumber == 0x0)
            StringAndWeightMove();

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        if (m_Engine.m_bMoveDataFlag) {
            short nTemp;

            nTemp = m_Engine.m_nDifOfTwoT9;
            MoveDataLoad();
            m_Engine.m_nDifOfTwoT9 = nTemp;
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        m_Engine.m_wWhiteTSize = m_Engine.m_wWhiteTSize9;
        m_Engine.m_wBlackTSize = m_Engine.m_wBlackTSize9;

        m_Engine.m_pbyTmpBitGroupRelAdr = pbyTmpAdrSave;
        m_Engine.m_nFuncControlFlag = 5; // CompetitionAbility()

        for (nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber--) {
            if ( (m_Engine.m_stGroup[nGroupNumber].nAliveDead != 0x00) &&
                    (m_Engine.m_stGroup[nGroupNumber].nAliveDead != 0xff)) {

                if ((nGroupNumber & 0x01) == 0)
                    byWhiteBlackBit = (byte) 0xaa;
                else
                    byWhiteBlackBit = 0x55;

                m_Engine.m_stGroup[nGroupNumber].nCompetition = 0x80;
                InterrelGSearch(byWhiteBlackBit, (byte) nGroupNumber); //CompetitionAbility()
            } else
                m_Engine.m_pbyTmpBitGroupRelAdr -= 0x000a;
        }

        m_Engine.m_pbyTmpBitGroupRelAdr = pbyTmpAdrSave;
        m_Engine.m_nFuncControlFlag = 3; //OtherGrpCalc()

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for (nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber--) {
            if ( (m_Engine.m_stGroup[nGroupNumber].nAliveDead != 0x00) &&
                    (m_Engine.m_stGroup[nGroupNumber].nAliveDead != 0xff)) {
                if ( (byte) m_Engine.m_stGroup[nGroupNumber].nCompetition <= 0x04)
                    RelativeGoodDegree(nGroupNumber);
                else
                    m_Engine.m_pbyTmpBitGroupRelAdr -= 0x000a;
            } else
                m_Engine.m_pbyTmpBitGroupRelAdr -= 0x000a;
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        if (m_Engine.m_byNewStringNumber == 0x00) {
            m_Engine.m_pbyTmpBitGroupRelAdr = pbyTmpAdrSave;
            m_Engine.m_nFuncControlFlag = 6; //UpdateBitControlBoard( ,)

            for (nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber--) {
                if (m_Engine.m_stGroup[nGroupNumber].nAliveDead > 0xe4) {
                    if ( (nGroupNumber & 0x01) == 0)
                        byWhiteBlackBit = (byte) 0xaa;
                    else
                        byWhiteBlackBit = 0x55;

                    InterrelGSearch(byWhiteBlackBit, (byte) nGroupNumber); //UpdateBitControlBoard()
                } else
                    m_Engine.m_pbyTmpBitGroupRelAdr -= 0x000a;
            }
        }

        m_Engine.m_byBlackGroupCount = 0;
        m_Engine.m_byWhiteGroupCount = 0;

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for (nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber--) {
            if (m_Engine.m_stGroup[nGroupNumber].nTotalSize != 0x00) {
                if ( (nGroupNumber & 0x01) == 0)
                    m_Engine.m_byBlackGroupCount++;
                else
                    m_Engine.m_byWhiteGroupCount++;

                if (m_Engine.m_stGroup[nGroupNumber].nAliveDead != 0x00) {
                    if (m_Engine.m_stGroup[nGroupNumber].nImportance >
                            (m_Engine.m_stGroup[nGroupNumber].nBattleGain & 0xff)) {
                        m_Engine.m_stGroup[nGroupNumber].nSituation = (short) (
                                m_Engine.m_stGroup[nGroupNumber].nImportance -
                                        m_Engine.m_stGroup[nGroupNumber].nBattleGain);
                        nImport = (short) (0x06 * m_Engine.m_stGroup[nGroupNumber].nSituation);

                        if ( (nGroupNumber & 0x01) != 0) {
                            m_Engine.m_wBlackTSize += nImport;
                            if (m_Engine.m_stGroup[nGroupNumber].nAliveDead == 0xff)
                                m_Engine.m_nDifOfTwoT9 += nImport;
                        } else {
                            m_Engine.m_wWhiteTSize += nImport;
                            if (m_Engine.m_stGroup[nGroupNumber].nAliveDead == 0xff)
                                m_Engine.m_nDifOfTwoT9 -= nImport;
                        }
                    } else
                        m_Engine.m_stGroup[nGroupNumber].nSituation = 0x00;
                } else
                    m_Engine.m_stGroup[nGroupNumber].nSituation = 0x00;
            } else
                m_Engine.m_stGroup[nGroupNumber].nSituation = 0x00;
        }

        m_Engine.m_bInfo10Flag = false;

        if( m_Engine.m_nGameLevel  < 3 )
            return;
        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        for( nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber-- )
        {
            if( m_Engine.m_stGroup[nGroupNumber].nImportance == 0 )
            {
                m_Engine.m_stGroup[nGroupNumber].nOtherSumImp = 0;
                m_Engine.m_stGroup[nGroupNumber].nSumImport = 0;
            }
            else
            {
                bNotAliveExistFlag = true;

                wTemp = (short)(m_Engine.m_stGroup[nGroupNumber].nImportance + 6);
                byTempInfo3 = (byte)wTemp;

                if( wTemp <= 0xff )
                {
                    wTemp = (short)( 0x24 * m_Engine.m_stGroup[nGroupNumber].nImportance );
                    wTemp += ( (byTempInfo3 & 0xff) >>> 1 );
                    byChangedInfo3 = (byte)( wTemp / byTempInfo3 );

                    //  ( 0x24 * nImportance + nImportance / 2 + 3 )/( nImportance + 0x0006 )
                    //  byInfo3 == 0  --->  m_byLOResult = 1/2
                    //  byInfo3 == 0xff ->	m_byLOResult = 0x23
                }
                else
                    byChangedInfo3 = 0x24;

                m_Engine.m_stGroup[nGroupNumber].nSumImport = byChangedInfo3;
                byChangedInfo3 = (byte)( (byChangedInfo3 & 0xff) >>> 1 );
                m_Engine.m_stGroup[nGroupNumber].nOtherSumImp = byChangedInfo3;
            }
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<

        if( bNotAliveExistFlag )
        {
            m_Engine.m_bInfo10Flag = true;
            m_Engine.m_pbyTmpBitGroupRelAdr = pbyTmpAdrSave;
            m_Engine.m_nFuncControlFlag = 7; // Info12Sum(11111)

            for( nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber-- )
            {
                if( m_Engine.m_stGroup[nGroupNumber].nTotalSize != 0x0 )
                {
                    byWhiteBlackBit = (byte)0xff;
                    m_Engine.m_byHIResult = 0x00;
                    m_Engine.m_byLOResult = 0x08;

                    InterrelGSearch( byWhiteBlackBit, (byte)nGroupNumber );//Info12Sum(11111)

                    wSurImport = (short)m_Engine.m_byLOResult;

                    if( (m_Engine.m_byHIResult & 0xff) > 0x01 )
                    {
                        wSurImport = (short)((m_Engine.m_byLOResult & 0xff) * ( (m_Engine.m_byHIResult & 0xff) + 1 ) / (m_Engine.m_byHIResult & 0xff));

                        if( wSurImport >= 0x100 )
                        {
                            m_Engine.m_stGroup[nGroupNumber].nSumImport = 0x77;
                            continue;
                        }
                    }
                    wSurImport = (short)( ( ( wSurImport + 1 ) >>> 1 ) +
                            m_Engine.m_stGroup[nGroupNumber].nSumImport );

                    if( wSurImport > 0x77 )
                    {
                        m_Engine.m_stGroup[nGroupNumber].nSumImport = 0x77;
                        continue;
                    }

                    m_Engine.m_stGroup[nGroupNumber].nSumImport = (short)(wSurImport & 0xff);
                }
                else
                {
                    m_Engine.m_stGroup[nGroupNumber].nSumImport = m_Engine.m_stGroup[nGroupNumber].nTotalSize;
                    m_Engine.m_pbyTmpBitGroupRelAdr -= 0x000a;
                }
            }
        }

        //HJ_Debug>>
//        if ( m_nCallCount == 3 )
//        OUTPUT("m_byGroupBoard", m_Engine.m_byGroupBoard, 20);
        //<<
        return;
    }

    void StonePosWeight(short byStrNumbr) {
        byte cOldWeight;
        short i, nPos = m_Engine.m_nMainPos;
        boolean bWhite = IsWhite(byStrNumbr);
        byte buf[] = {0, 0, 0, 0}; //4

        short wStatus = m_Engine.m_wStatus[byStrNumbr];
        byte cWeight;
        Result:
        do { //for Result
            if ( (wStatus & 0x04) != 0) {
                cWeight = 6;
                m_Engine.m_cAreaBoard[nPos] = -3;
                if (bWhite) {
                    cWeight = (byte) - cWeight;
                    m_Engine.m_wBlackTSize9 += 6;
                } else
                    m_Engine.m_wWhiteTSize9 += 6;
                break Result;
            }
            Start:
            do {
                if ( (wStatus & 0x400) == 0) {
                    cWeight = 3;
                    m_Engine.m_cAreaBoard[nPos] = 3;

                    if (m_Engine.m_nStoneCount[byStrNumbr] != 1) {
                        if (bWhite)
                            cWeight = (byte) - cWeight;
                        break Result;
                    }
                    break Start;
                }

                cWeight = 0;
                m_Engine.m_cAreaBoard[nPos] = 0;
                if (m_Engine.m_nStoneCount[byStrNumbr] != 1)
                    break Result;

                cWeight = (byte) (m_Engine.m_byPosBoard[nPos] - 3);

                if (cWeight <= 0) {
                    m_Engine.m_nBoardPos = m_Engine.m_nMainPos;
                    cWeight = AstonePosWeight(false);
                }
            } while (false); ///start
            m_Engine.m_cAreaBoard[nPos] = 1;

            if ( (cOldWeight = (byte) ThreatDegree(byStrNumbr)) != 0) {
                if (!IsFourDiagonalLinkable(buf, (byte) byStrNumbr)) {
                    if ( (cWeight != 0) && ((m_Engine.m_byPosBoard[nPos] & 0xff) <= 2))
                        cWeight = 5;
                    if ((long)cOldWeight > (long)cWeight)
                        cWeight = cOldWeight;

                    for (i = 0; i < 4; i++) {
                        if (buf[i] == 2) {
                            cWeight -= 2;
                            if ( (wStatus & 0x400) != 0)
                                break;
                            if ((long)cWeight < 3)
                                cWeight = 3;
                            // upversion
                            //  break;
                            if (bWhite)
                                cWeight = (byte) - cWeight;
                            break Result;
                        }
                    }
                    m_Engine.m_cAreaBoard[nPos] = 3;

                    if (bWhite)
                        cWeight = (byte) - cWeight;
                    break Result;
                }
                m_Engine.m_cAreaBoard[nPos] = 0;
            }

            if ( ( (wStatus & 0x400) == 0) ||
                    ((m_Engine.m_byPosBoard[nPos] & 0xff) < 4)) {
                if (bWhite)
                    cWeight = (byte) - cWeight;
            } else
                cWeight = 0;
        } while (false); //Result

        cOldWeight = m_Engine.m_cWeightBoard[nPos];
        m_Engine.m_cWeightBoard[nPos] = cWeight;
        wStatus = m_Engine.m_wStatus[byStrNumbr];
        byStrNumbr = (short)(m_Engine.m_byTempBoard[nPos] & 0xff);

        if ( (byStrNumbr == 0) ||
                (wStatus != m_Engine.m_wTempStatus[byStrNumbr]) ||
                ( ( (wStatus & 0x800) != 0) && (cWeight != cOldWeight))) {
            m_Engine.m_nBoardPos = m_Engine.m_nMainPos;
            ExpressTempArea();
        }
        return;
    }

    boolean PotentialWeightOfSpace() {
        byte byMainStoneLayer;
        byte pbyBitStoneStatus[] = {0};
        byte bySurSEPs[] = {0};
        byte bySurStoneWeight[] = {0};

        short nResultFlag;
        short nSurCount = 0;

        byte byMainWeight = 0;
        byte byDistanceScore = 4;
        byte bySideStoneProperty[] = {0};

        byte byOtherStoneCount[] = {0};
        short wOtherStoneCoord[] = {0};
        short wAnOtherStoneCoord[] = {0};

        ExpressWallPos(m_Engine.m_nMainPos, m_Engine.m_byPotentialWallPos);
        byMainStoneLayer = (byte) Math.max((4 - (m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff)), 0);

        do {
            nResultFlag = SurStoneExistColor(nSurCount, pbyBitStoneStatus, bySurSEPs,
                    bySurStoneWeight);

            if (nResultFlag == -1)
                continue;
/*
#ifdef UPDATE
            if (nResultFlag == 1) {
                if ( (byte) bySurStoneWeight[0] < -5)
                    byMainWeight = (byte)((byMainWeight & 0xff) - (byDistanceScore & 0xff));
                else {
                    if ( (pbyBitStoneStatus[0] & 0x4) != 0)
                        pbyBitStoneStatus[0] |= 0x1;
                    else
                        pbyBitStoneStatus[0] |= 0x4;

                    if ( (byte) bySurStoneWeight[0] <= -5) {
                        pbyBitStoneStatus[0] |= 0x40;
                        //byMainWeight++;
                        byMainWeight = (byte)((byMainWeight & 0xff) + 1);
                    } else {
                        pbyBitStoneStatus[0] |= 0x40;
                        byMainWeight += byDistanceScore;
                        if ( (byte) bySurStoneWeight[0] > -3) {
                            if (bySurSEPs[0] < 3) {
                                if ( (pbyBitStoneStatus[0] & 0x4) != 0)
                                    pbyBitStoneStatus[0] |= 0x1;
                                else
                                    pbyBitStoneStatus[0] |= 0x4;
                            } else
                                pbyBitStoneStatus[0] |= 0x1;
                        } else {
                            //byMainWeight += (2 + (byte) bySurStoneWeight[0]);
                            byMainWeight = (byte)((byMainWeight & 0xff) +
                                           (2 + (byte) bySurStoneWeight[0]));
                            if ((bySurSEPs[0] >= 3) && ( (byte) bySurStoneWeight[0] == -3)) {
                                if ( (pbyBitStoneStatus[0] & 0x4) != 0)
                                    pbyBitStoneStatus[0] |= 0x1;
                                else
                                    pbyBitStoneStatus[0] |= 0x4;
                            }
                        }
                    }
                }
                if (bySurSEPs[0] < 2)
                    continue;
                bySideStoneProperty[0] = 0;

                if ((byte) bySurStoneWeight[0] > -4)
                    bySideStoneProperty[0] = 0x31; //31 //???  31
                SideStoneScreening(nSurCount, bySurStoneWeight, bySideStoneProperty);
                continue;
            } else {
                if ( (byte) bySurStoneWeight[0] > 5)
                    //byMainWeight += byDistanceScore;
                    byMainWeight = (byte)((byMainWeight & 0xff) + (byDistanceScore & 0xff));
                else {
                    if ( (pbyBitStoneStatus[0] & 0x8) != 0)
                        pbyBitStoneStatus[0] |= 0x2;
                    else
                        pbyBitStoneStatus[0] |= 0x8;

                    if ((byte) bySurStoneWeight[0] >= 5) {
                        pbyBitStoneStatus[0] |= 0x80;
                        //byMainWeight--;
                        byMainWeight = (byte)((byMainWeight & 0xff) - 1);
                    } else {
                        pbyBitStoneStatus[0] |= 0x80;
                        //byMainWeight -= byDistanceScore;
                        byMainWeight = (byte)((byMainWeight & 0xff) - (byDistanceScore & 0xff));

                        if ( (byte) bySurStoneWeight[0] < 3) {
                            if ((bySurSEPs[0] & 0xff) < 3) {
                                if ( (pbyBitStoneStatus[0] & 0x8) != 0)
                                    pbyBitStoneStatus[0] |= 0x2;
                                else
                                    pbyBitStoneStatus[0] |= 0x8;
                            } else
                                pbyBitStoneStatus[0] |= 0x2;
                        } else {
                            //byMainWeight += ( -2 + (byte) bySurStoneWeight[0]);
                            byMainWeight = (byte)((byMainWeight & 0xff) + ( -2 + (byte) bySurStoneWeight[0]));
                            if (((bySurSEPs[0] & 0xff) >= 3) && ((byte) bySurStoneWeight[0] == 3)) {
                                if ( (pbyBitStoneStatus[0] & 0x8) != 0)
                                    pbyBitStoneStatus[0] |= 0x2;
                                else
                                    pbyBitStoneStatus[0] |= 0x8;
                            }
                        }
                    }
                }
                if (bySurSEPs[0] < 2)
                    continue;
                bySideStoneProperty[0] = 0;

                if ( (byte) bySurStoneWeight[0] < 4)
                    bySideStoneProperty[0] = 0x32;

                SideStoneScreening(nSurCount, bySurStoneWeight, bySideStoneProperty);
                continue;
            }
        //} while (++nSurCount < 4);

#else
*/
            if (nResultFlag == 1) {
                if (((byte)bySurStoneWeight[0] > -6) && (bySurSEPs[0] == 1)) {
                    pbyBitStoneStatus[0] |= 0x10;
                    if ((pbyBitStoneStatus[0] & 0x20) != 0) {
                        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = 0;
                        return true;
                    }
                } else {
                    if ((byte)bySurStoneWeight[0] >= -5) {
                        if ((pbyBitStoneStatus[0] & 0x4) != 0)
                            pbyBitStoneStatus[0] |= 0x1;
                        else
                            pbyBitStoneStatus[0] |= 0x4;
                    }

                    if ((byte)bySurStoneWeight[0] == -5) {
                        pbyBitStoneStatus[0] |= 0x40;
                        //byMainWeight++;
                        byMainWeight = (byte)((byMainWeight & 0xff) + 1);
                    } else if ((byte)bySurStoneWeight[0] > -5) {
                        pbyBitStoneStatus[0] |= 0x40;
                        //byMainWeight += byDistanceScore;
                        byMainWeight = (byte)((byMainWeight & 0xff) + (byDistanceScore & 0xff));
                        if (bySurStoneWeight[0] > -3) {
                            //upversion
                            // pbyBitStoneStatus |= 1;
                            if ((bySurSEPs[0] & 0xff) >= 3)
                                pbyBitStoneStatus[0] |= 1;
                            else if ((pbyBitStoneStatus[0] & 4) != 0)
                                pbyBitStoneStatus[0] |= 1;
                            else
                                pbyBitStoneStatus[0] |= 4;
                        } else {
                            //byMainWeight += (2 + bySurStoneWeight);
                            byMainWeight = (byte)((byMainWeight & 0xff) + (2 + (byte)bySurStoneWeight[0]));
                            if (((bySurSEPs[0] & 0xff) >= 3) &&
                                    ((byte)bySurStoneWeight[0] == -3)) {
                                if ((pbyBitStoneStatus[0] & 4) != 0)
                                    pbyBitStoneStatus[0] |= 1;
                                else
                                    pbyBitStoneStatus[0] |= 4;
                            }
                        }
                    } else //byMainWeight -= byDistanceScore;
                        byMainWeight = (byte)((byMainWeight & 0xff) - (byDistanceScore & 0xff));
                }
                bySideStoneProperty[0] = 0;

                if ((byte)bySurStoneWeight[0] > -4)
                    bySideStoneProperty[0] = 0x32; //31 //???  31
                SideStoneScreening(nSurCount, bySurStoneWeight, bySideStoneProperty);
            } else {
                if (((byte)bySurStoneWeight[0] < 0x6) && (bySurSEPs[0] == 1)) {
                    pbyBitStoneStatus[0] |= 0x20;
                    if ((pbyBitStoneStatus[0] & 0x10) != 0) {
                        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = 0;
                        return true;
                    }
                } else {
                    if ((byte)bySurStoneWeight[0] <= 5) {
                        if ((pbyBitStoneStatus[0] & 0x8) != 0)
                            pbyBitStoneStatus[0] |= 0x2;
                        else
                            pbyBitStoneStatus[0] |= 0x8;
                    }

                    if (bySurStoneWeight[0] == 5) {
                        (pbyBitStoneStatus[0]) |= 0x80;
                        //byMainWeight--;
                        byMainWeight = (byte)((byMainWeight & 0xff) - 1);
                    } else if ((byte)bySurStoneWeight[0] < 5) {
                        (pbyBitStoneStatus[0]) |= 0x80;
                        //byMainWeight -= byDistanceScore;
                        byMainWeight = (byte)((byMainWeight & 0xff) - (byDistanceScore & 0xff));
                        if ((byte)bySurStoneWeight[0] < 3) {
                            if ((bySurSEPs[0] & 0xff) >= 3)
                                (pbyBitStoneStatus[0]) |= 2;
                            else if (((pbyBitStoneStatus[0]) & 8) != 0)
                                (pbyBitStoneStatus[0]) |= 2;
                            else
                                (pbyBitStoneStatus[0]) |= 8;
                        } else {
                            //byMainWeight -= (2 - bySurStoneWeight);
                            byMainWeight = (byte)((byMainWeight & 0xff) -
                                    (2 - (bySurStoneWeight[0] & 0xff)));
                            if (((bySurSEPs[0] & 0xff) >= 3) && (bySurStoneWeight[0] == 3)) {
                                if (((pbyBitStoneStatus[0]) & 8) != 0)
                                    (pbyBitStoneStatus[0]) |= 2;
                                else
                                    (pbyBitStoneStatus[0]) |= 8;
                            }
                        }
                    } else
                        //byMainWeight += byDistanceScore;
                        byMainWeight = (byte)((byMainWeight & 0xff) + (byDistanceScore & 0xff));
                }

                bySideStoneProperty[0] = 0;

                if ((byte)bySurStoneWeight[0] < 4)
                    bySideStoneProperty[0] = 0x32;

                SideStoneScreening(nSurCount, bySurStoneWeight, bySideStoneProperty);
            }
//#endif

        } while (++nSurCount < 4);

        byDistanceScore = 3;
        out:
        do {
            nResultFlag = SurStoneExistColor(nSurCount, pbyBitStoneStatus, bySurSEPs,
                    bySurStoneWeight);

            if (nResultFlag == -1)
                continue;
            DiagResult:
            do {
                if (nResultFlag == 1) {
                    if ( (byte) bySurStoneWeight[0] <= -5) {
                        if ( ( (byte) bySurStoneWeight[0] < -5) &&
                                (m_Engine.m_byPotentialWallPos[nSurCount] == 0))
                            //byMainWeight -= byDistanceScore;
                            byMainWeight = (byte)((byMainWeight & 0xff) - (byDistanceScore & 0xff));
                        continue out;
                    }

                    if (m_Engine.m_byPotentialWallPos[nSurCount] >= 0x40)
                        break DiagResult;
                    if ( (m_Engine.m_byPotentialWallPos[nSurCount]) != 0) {
                        if ((bySurSEPs[0] & 0xff) < 3)
                            break DiagResult;
                        if (((m_Engine.m_byPotentialWallPos[nSurCount] & 0x10)) == 0) {
                            if ( (bySurStoneWeight[0]) != 0)
                                break DiagResult;
                            if ( ((byMainStoneLayer & 0xff) < 2) &&
                                    ( (m_Engine.m_byPotentialWallPos[nSurCount] & 2) != 0))
                                break DiagResult;
                        }
                        pbyBitStoneStatus[0] |= 0x40;
                        //byMainWeight += 2;
                        byMainWeight = (byte)((byMainWeight & 0xff) + 2);
                        if ( (pbyBitStoneStatus[0] & 4) != 0)
                            pbyBitStoneStatus[0] |= 1;
                        else
                            pbyBitStoneStatus[0] |= 4;
                        break DiagResult;
                    } else {
                        pbyBitStoneStatus[0] |= 0x40;
                        //byMainWeight += byDistanceScore;
                        byMainWeight = (byte)((byMainWeight & 0xff) + (byDistanceScore & 0xff));
                        if ( (byte) bySurStoneWeight[0] > -3) {
                            if ((bySurSEPs[0] & 0xff) >= 3)
                                pbyBitStoneStatus[0] |= 1;
                            else if ( (pbyBitStoneStatus[0] & 4) != 0)
                                pbyBitStoneStatus[0] |= 1;
                            else
                                pbyBitStoneStatus[0] |= 4;
                            break DiagResult;
                        } else {
                            //byMainWeight += (2 + bySurStoneWeight[0]);
                            byMainWeight = (byte)((byMainWeight & 0xff) + (2 + (bySurStoneWeight[0] & 0xff)));
                            if ( (bySurSEPs[0] >= 3) && ((byte) bySurStoneWeight[0] == -3)) {
                                if ( (pbyBitStoneStatus[0] & 4) != 0)
                                    pbyBitStoneStatus[0] |= 1;
                                else
                                    pbyBitStoneStatus[0] |= 4;
                            }
                            break DiagResult;
                        }
                    }
                } else {
                    if ((byte) bySurStoneWeight[0] >= 5) {
                        if (((byte) bySurStoneWeight[0] > 5) &&
                                (m_Engine.m_byPotentialWallPos[nSurCount] == 0))
                            //byMainWeight += byDistanceScore;
                            byMainWeight = (byte)((byMainWeight & 0xff) + (byDistanceScore & 0xff));
                        continue out;
                    }
                    if (m_Engine.m_byPotentialWallPos[nSurCount] >= 0x40)
                        break DiagResult;
                    if (m_Engine.m_byPotentialWallPos[nSurCount] != 0) {
                        if ((bySurSEPs[0] & 0xff) < 3)
                            break DiagResult;
                        if ( (m_Engine.m_byPotentialWallPos[nSurCount] & 0x10) == 0) {
                            if (bySurStoneWeight[0] != 0)
                                break DiagResult;
                            if (((byMainStoneLayer & 0xff) < 2) &&
                                    ((m_Engine.m_byPotentialWallPos[nSurCount] & 0x01) != 0))
                                break DiagResult;
                        }
                        pbyBitStoneStatus[0] |= 0x80;
                        //byMainWeight -= 2;
                        byMainWeight = (byte)((byMainWeight & 0xff) - 2);

                        if ( (pbyBitStoneStatus[0] & 0x08) != 0)
                            pbyBitStoneStatus[0] |= 0x02;
                        else
                            pbyBitStoneStatus[0] |= 0x08;
                        break DiagResult;
                    } else {
                        pbyBitStoneStatus[0] |= 0x80;
                        //byMainWeight -= byDistanceScore;
                        byMainWeight = (byte)((byMainWeight & 0xff) - (byDistanceScore & 0xff));
                        if ( (byte) bySurStoneWeight[0] < 3) {
                            if ((bySurSEPs[0] & 0xff) >= 3)
                                pbyBitStoneStatus[0] |= 0x02;
                            else if ( (pbyBitStoneStatus[0] & 0x08) != 0)
                                pbyBitStoneStatus[0] |= 0x02;
                            else
                                pbyBitStoneStatus[0] |= 0x08;
                            break DiagResult;
                        } else {
                            //byMainWeight -= 2;
                            byMainWeight = (byte)((byMainWeight & 0xff) - 2);
                            //byMainWeight += bySurStoneWeight[0];
                            byMainWeight = (byte)((byMainWeight & 0xff) + (bySurStoneWeight[0] & 0xff));
                            if (((bySurSEPs[0] & 0xff) >= 3) && ( (byte) bySurStoneWeight[0] == 3)) {
                                if ((pbyBitStoneStatus[0] & 8) != 0)
                                    pbyBitStoneStatus[0] |= 2;
                                else
                                    pbyBitStoneStatus[0] |= 8;
                            }
                            break DiagResult;
                        }
                    }
                }
            } while (false); //for DiagResult

            if ( (pbyBitStoneStatus[0] & 3) != 3) {
                Screening(nSurCount);
                continue;
            } else {
                m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = 0;
                return true;
            }
        } while (++nSurCount < 8);

        byDistanceScore = 2;
        do {
            nResultFlag = SurStoneExistColor(nSurCount, pbyBitStoneStatus, bySurSEPs, bySurStoneWeight);

            if (nResultFlag == -1)
                continue;
            if (nResultFlag == 1) {
                if ( (byte) bySurStoneWeight[0] != -5) {
                    if ((byte) bySurStoneWeight[0] < -5) {
                        if (m_Engine.m_byPotentialWallPos[nSurCount] == 0)
                            //byMainWeight -= 2;
                            byMainWeight = (byte)((byMainWeight & 0xff) - 2);
                        continue;
                    } else {
                        if ((m_Engine.m_byPotentialWallPos[nSurCount] <= 0x20) &&
                                ( (byte) bySurStoneWeight[0] >= -3)) {
                            //byMainWeight++;
                            byMainWeight = (byte)((byMainWeight & 0xff) + 1);
                            pbyBitStoneStatus[0] |= 0x40;
                            if ( (byte) bySurStoneWeight[0] > -2) {
                                //byMainWeight++;
                                byMainWeight = (byte)((byMainWeight & 0xff) + 1);
                                if ( (nSurCount < 0x0C) && ((bySurSEPs[0] & 0xff) >= 4) &&
                                        ( (pbyBitStoneStatus[0] & 2) == 0))
                                    pbyBitStoneStatus[0] |= 4;
                            }
                        }
                        Screening(nSurCount);
                    }
                }
            } else {
                if (bySurStoneWeight[0] != 5) {
                    if ( (byte) bySurStoneWeight[0] > 5) {
                        if (m_Engine.m_byPotentialWallPos[nSurCount] == 0)
                            //byMainWeight += 2;
                            byMainWeight = (byte)((byMainWeight & 0xff) + 2);
                    } else {
                        if ((m_Engine.m_byPotentialWallPos[nSurCount] <= 0x20) &&
                                ((byte) bySurStoneWeight[0] <= 3)) {
                            //byMainWeight--;
                            byMainWeight = (byte)((byMainWeight & 0xff) - 1);
                            pbyBitStoneStatus[0] |= 0x80;
                            if ( (byte) bySurStoneWeight[0] < 2) {
                                //byMainWeight--;
                                byMainWeight = (byte)((byMainWeight & 0xff) - 1);
                                if ((nSurCount < 0x0C) && ((bySurSEPs[0] & 0xff) >= 4) &&
                                        ((pbyBitStoneStatus[0] & 1) == 0))
                                    pbyBitStoneStatus[0] |= 8;
                            }

                        }
                        Screening(nSurCount);
                    }
                }
            }
        } while (++nSurCount < 0x14);

        do {
            nResultFlag = SurStoneExistColor(nSurCount, pbyBitStoneStatus, bySurSEPs,
                    bySurStoneWeight);

            if (nResultFlag == -1)
                continue;
            if (nResultFlag == 1) {
                if ((byte) bySurStoneWeight[0] != -5) {
                    if ((byte) bySurStoneWeight[0] < -5) {
                        if (m_Engine.m_byPotentialWallPos[nSurCount] == 0)
                            //byMainWeight--;
                            byMainWeight = (byte)((byMainWeight & 0xff) - 1);
                    } else {
                        if ((m_Engine.m_byPotentialWallPos[nSurCount] == 0) &&
                                ((byte) bySurStoneWeight[0] >= -1)) {
                            //byMainWeight++;
                            byMainWeight = (byte)((byMainWeight & 0xff) + 1);
                            pbyBitStoneStatus[0] |= 0x40;
                        }
                        Screening(nSurCount);
                    }
                }
            } else {
                if (bySurStoneWeight[0] != 5) {
                    if ( (byte) bySurStoneWeight[0] > 5) {
                        if (m_Engine.m_byPotentialWallPos[nSurCount] == 0)
                            //byMainWeight++;
                            byMainWeight = (byte)((byMainWeight & 0xff) + 1);
                    } else {
                        if ((m_Engine.m_byPotentialWallPos[nSurCount] == 0) &&
                                ((byte) bySurStoneWeight[0] <= 1)) {
                            //byMainWeight--;
                            byMainWeight = (byte)((byMainWeight & 0xff) - 1);
                            pbyBitStoneStatus[0] |= 0x80;
                        }
                        Screening(nSurCount);
                    }
                }
            }
        } while (++nSurCount < 0x24);

        //by Jong 2004/8/17
        if( m_Engine.m_nGameLevel > 2 )
        {
            do
            {
                if ((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) >= 3)
                    break;

                nSurCount = 0x30;

                do {
                    if (m_Engine.m_byPotentialWallPos[nSurCount] != 0)
                        continue;

                    nResultFlag = SurStoneExistColor(nSurCount, pbyBitStoneStatus,
                            bySurSEPs, bySurStoneWeight);

                    if (nResultFlag == -1)
                        continue;

                    if (nResultFlag == 1) {
                        if (bySurStoneWeight[0] == -6)
                            //byMainWeight--;
                            byMainWeight = (byte) ((byMainWeight & 0xff) - 1);
                        else if ((byte)bySurStoneWeight[0] > -1) {
                            pbyBitStoneStatus[0] |= 0x40;
                            //byMainWeight++;
                            byMainWeight = (byte) ((byMainWeight & 0xff) + 1);
                        }
                    } else {
                        if (bySurStoneWeight[0] == 6)
                            //byMainWeight++;
                            byMainWeight = (byte) ((byMainWeight & 0xff) + 1);
                        else if (bySurStoneWeight[0] < 1) {
                            pbyBitStoneStatus[0] |= 0x80;
                            //byMainWeight--;
                            byMainWeight = (byte) ((byMainWeight & 0xff) - 1);
                        }
                    }
                } while (++nSurCount < 0x38);
            } while(false);
        }

        if ((byte)byMainWeight > 0) {
            if ( (pbyBitStoneStatus[0] & 0x80) == 0)
                //byMainWeight += byMainStoneLayer;
                byMainWeight = (byte)((byMainWeight & 0xff) + (byMainStoneLayer & 0xff));
            if (((byte) byMainWeight < 2) || ( (pbyBitStoneStatus[0] & 2) != 0))
                byMainWeight = 0;
//#ifdef UPDATE
//
//#else
            else if ((pbyBitStoneStatus[0] & 0x10) != 0)
                byMainWeight = 2;
//#endif
            else {
                if ( (pbyBitStoneStatus[0] & 8) != 0) {
//#ifdef UPDATE
//                    byMainWeight--;
//#endif
                    //byMainWeight /= 2;
                    byMainWeight = (byte)((byMainWeight & 0xff) / 2);
                    if ((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) < 3) {
                        byMainWeight = 1;

                        if (SideOtherStone( (short) 1, (byte) 2, byOtherStoneCount, wOtherStoneCoord,
                                wAnOtherStoneCoord) == 0)
                            byMainWeight = 0;

                        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = byMainWeight;

                        return true;
                    }
                }
//#ifdef UPDATE
//                if ( ( (pbyBitStoneStatus[0] & 9) == 0) && ( (pbyBitStoneStatus[0] & 0x80) != 0)) {
//                    //byMainWeight++;
//                    byMainWeight = (byte)((byMainWeight & 0xff) + 1);
//                    byMainWeight = (byte)(byMainWeight & 0xff) / 2;
//                }
//#else
                if ((( pbyBitStoneStatus[0] & 5 ) == 0) &&
                        ( (m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) >= 5 ))
                    byMainWeight = (byte)((byMainWeight & 0xff) - 1);
//#endif
                if ((byte) byMainWeight < 2)
                    byMainWeight = 0;

                else if ((byte) byMainWeight > 2)
                    byMainWeight = 6;
            }
        } else if ( (byte) byMainWeight < 0) {
            if ( (pbyBitStoneStatus[0] & 0x40) == 0)
                //byMainWeight -= byMainStoneLayer;
                byMainWeight = (byte)((byMainWeight & 0xff) - (byMainStoneLayer & 0xff));
            if (((byte) byMainWeight > -2) || ( (pbyBitStoneStatus[0] & 1) != 0))
                byMainWeight = 0;
//#ifdef UPDATE
//#else
            else if ( (pbyBitStoneStatus[0] & 0x20) != 0 )
                byMainWeight = (byte)0xFE;
//#endif
            else {
                if ( (pbyBitStoneStatus[0] & 4) != 0) {
                    byMainWeight = (byte) - (byMainWeight & 0xff);
//#ifdef UPDATE
//                    byMainWeight--;
//#endif
                    //byMainWeight /= 2;
                    byMainWeight = (byte)((byMainWeight & 0xff) / 2);
                    byMainWeight = (byte) - (byMainWeight & 0xff);

                    if ((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) < 3) {
                        byMainWeight = (byte) 0xFF;

                        if (SideOtherStone( (short) 0, (byte) 2, byOtherStoneCount, wOtherStoneCoord,
                                wAnOtherStoneCoord) == 0)
                            byMainWeight = 0;

                        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = (byte) byMainWeight;

                        return true;
                    }
                }
//#ifdef UPDATE
//                if ( ( (pbyBitStoneStatus[0] & 6) == 0) && ( (pbyBitStoneStatus[0] & 0x40) == 0)) {
//                    //upversion
//                    //byMainWeight++;
//                    byMainWeight = (byte)((byMainWeight & 0xff) + 1);
//                    //byMainWeight /= 2;
//                    byMainWeight = (byte)((byMainWeight & 0xff) / 2);
//                }
//#else
                if (((pbyBitStoneStatus[0] & 0x0A) == 0) &&
                        ((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) >= 5))
                    //byMainWeight++;
                    byMainWeight = (byte)((byMainWeight & 0xff) + 1);
//#endif
                if ((byte) byMainWeight > -2)
                    byMainWeight = 0;
                else if ((byte) byMainWeight < -2)
                    byMainWeight = (byte) 0xFA;
            }
        }
        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = (byte) byMainWeight;

        if ( ( (byMainWeight == 2) || (byMainWeight == 0) || (byMainWeight == (byte) 0xFE)) &&
                ((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) >= 4))
            return false;
        return true;
    }

    boolean DiagInfluCalc(short nColor, byte[] pbyBitThatManyTwosIs, byte[] pnMainWeight) {
        byte byCountOfTwo[] = {0};
        short nSurCount, nDiagPos;
        byte cRealRemainOfTwo;

        pnMainWeight[0] = (byte)(((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) > 2) ? 4 : 2);

        for (nSurCount = 4; nSurCount < 8; nSurCount++) {
            nDiagPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSurCount]);

            if (ADiagInflu(nDiagPos, nColor, byCountOfTwo, pnMainWeight)) {
                if (nColor == 1)
                    pnMainWeight[0] = 1;
                else
                    pnMainWeight[0] = -1;

                return true;
            }
        }

        cRealRemainOfTwo = (byte) ((byte)pnMainWeight[0] - (byte)byCountOfTwo[0]);

        pnMainWeight[0] = (byte) Math.min(pnMainWeight[0], 2);

        if (cRealRemainOfTwo < (byte) (pnMainWeight[0]))
            pbyBitThatManyTwosIs[0] = 0x10; //Too Many Twos
        else
            pbyBitThatManyTwosIs[0] = 0; // Tiny Twos

        (pnMainWeight[0]) += 4;

        return false;
    }

    void AreaGridRead(byte byEndInfo[][]) {
        int pbyTmpAdrSave;
        short byWhiteBlackBit;
        short TmpLevel = m_Engine.m_nGameLevel;
        short nGroupNumber;
        short nGrpNumber;
        short nBoardX, nBoardY, i, j, nColor;
        short nSurX, nSurY, nSurPos;
        short nEmpCount;
        byte nTmpGrpNumberBoard[] = new byte[421];
        short nCount, nStringCount;
        short nExtendCount;

        short wWhiteTemp;
        short wBlackTemp;
        short nDif;

        m_Engine.m_nGameLevel = 6;

        m_Engine.m_nBoardPos = 0;

        Simulation();

        m_Engine.m_byNewStringNumber = (byte)0xff;

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] != INITVALUE) {
                if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] != 0)
                    m_Engine.m_cAreaBoard[m_Engine.m_nMainPosition] = 0;
                else
                    m_Engine.m_cAreaBoard[m_Engine.m_nMainPosition] = -1;
            }
        }

        m_Engine.m_nBoardPos = 0;
        m_Engine.nEvaluCount = 10;
        m_Engine.nBoardScoreCtrl = 1;

        BoardScoreCalc();

        m_Engine.m_nGameLevel = TmpLevel;

        m_Engine.m_bMoveDataFlag = false;

        m_Engine.m_pbyTmpBitGroupRelAdr = (m_Engine.m_nTotalGroupCount + 1) * 10 - 1;

        pbyTmpAdrSave = m_Engine.m_pbyTmpBitGroupRelAdr;
        m_Engine.m_nFuncControlFlag = 3; // Call  Of  OtherGrpCalc(pEngine)

        for (nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber--) {
            if (m_Engine.m_stGroup[nGroupNumber].nAliveDead > 0xe4) {
                if ((nGroupNumber & 0x01) == 0)
                    byWhiteBlackBit = (byte)0xaa;
                else
                    byWhiteBlackBit = 0x55;

                m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;

                InterrelGSearch( (byte) byWhiteBlackBit, (byte) nGroupNumber); //OtherGrpCalc(pEngine, ,)

                if (m_Engine.m_byHIResult == 0) {
                    if (m_Engine.m_bMoveDataFlag == false)
                        MoveDataSave();
                    m_Engine.m_stGroup[nGroupNumber].nAliveDead = 0xff;
                    m_Engine.m_stGroup[nGroupNumber].nImportance =
                            m_Engine.m_stGroup[nGroupNumber].nTotalSize;
                    KillStringInGroup( (byte) nGroupNumber);
                }
            } else
                m_Engine.m_pbyTmpBitGroupRelAdr -= 0x000a;
        }
        for (nGroupNumber = m_Engine.m_nTotalGroupCount; nGroupNumber > 0; nGroupNumber--) {

            if ( (m_Engine.m_stGroup[nGroupNumber].nAliveDead == 0xFF) ||
                    ( (m_Engine.m_stGroup[nGroupNumber].nAliveDead == 0xFE) &&
                            (m_Engine.m_stGroup[nGroupNumber].nTotalSize == m_Engine.m_stGroup[nGroupNumber].nSituation))) {
                if (m_Engine.m_bMoveDataFlag == false)
                    MoveDataSave();
                m_Engine.m_stGroup[nGroupNumber].nAliveDead = 0xff;
                m_Engine.m_stGroup[nGroupNumber].nImportance = m_Engine.m_stGroup[nGroupNumber].nTotalSize;
                KillStringInGroup( (byte) nGroupNumber);
            }
        }

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] == 0) {
                nStringCount = (short)(m_Engine.m_byBoard[m_Engine.m_nMainPosition] & 0xff);
                if (nStringCount != 0) {
                    if (m_Engine.m_bMoveDataFlag == false)
                        MoveDataSave();
                    m_Engine.m_wStatus[nStringCount] &= 0xfffb;
                    m_Engine.m_wStatus[nStringCount] |= 0x0400;

                }
            }
        }

        if (m_Engine.m_bMoveDataFlag != false) {

            wWhiteTemp = m_Engine.m_wWhiteTSize9;
            wBlackTemp = m_Engine.m_wBlackTSize9;
            nDif = m_Engine.m_nDifOfTwoT9;

            BoardWeightCalc();

            m_Engine.m_wBlackTSize9 = wBlackTemp;
            m_Engine.m_wWhiteTSize9 = wWhiteTemp;
            m_Engine.m_nDifOfTwoT9 = nDif;
        }

        for (i = 1; i < 128; i++) {
            if ( (m_Engine.m_wStatus[i] & 4) != 0)
                m_Engine.m_wStatus[i] = 0x01ff;
        }

        m_Engine.m_nTotalGroupCount = 0;
        MEMSET(m_Engine.m_byGroupBoard, 0);
        for (i = 0; i < m_Engine.m_stGroup.length; i ++ )
        {
            m_Engine.m_stGroup[i].setValue(0);
        }

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++)
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] != INITVALUE)
                ExpressOfGroup();

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == INITVALUE)
                continue;

            nBoardX = (short) (m_Engine.m_nMainPosition % 20 - 1);
            nBoardY = (short) (m_Engine.m_nMainPosition / 20 - 1);

            byEndInfo[nBoardY][nBoardX] = 0;
            if ( (nGrpNumber = (short)(m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] & 0xff)) == 0)
                continue;
            if (nGrpNumber > m_Engine.m_nTotalGroupCount)
                continue;
            if (m_Engine.m_stGroup[nGrpNumber].nTotalSize == 0)
                continue;
            if ( (m_Engine.m_stGroup[nGrpNumber].nAliveDead == 0xFF) ||
                    ( (m_Engine.m_stGroup[nGrpNumber].nAliveDead == 0xFE) &&
                            (m_Engine.m_stGroup[nGrpNumber].nTotalSize ==
                                    m_Engine.m_stGroup[nGrpNumber].nSituation))) {
                if (IsWhite(nGrpNumber))
                    byEndInfo[nBoardY][nBoardX] = 2;
                else
                    byEndInfo[nBoardY][nBoardX] = 1;
            } else {

                if (IsWhite(nGrpNumber))
                    byEndInfo[nBoardY][nBoardX] = 1;
                else
                    byEndInfo[nBoardY][nBoardX] = 2;
            }
        }

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == INITVALUE)
                continue;

            nBoardX = (short) (m_Engine.m_nMainPosition % 20 - 1);
            nBoardY = (short) (m_Engine.m_nMainPosition / 20 - 1);

            if (byEndInfo[nBoardY][nBoardX] != 0)
                continue;

            nColor = -1;

            nEmpCount = 0;
            NextCont:
            do {
                for (j = 0; j < 4; j++) {
                    nSurX = (short) (nBoardX + (short) m_Engine.AroundPointPosTable[j * 2]);
                    nSurY = (short) (nBoardY + (short) m_Engine.AroundPointPosTable[j * 2 + 1]);
                    if ( (nSurX < 0) || (nSurY < 0) ||
                            (nSurX >= m_Engine.m_nBoardSize) || (nSurY >= m_Engine.m_nBoardSize))
                        continue;
                    if ((nColor != -1) && (nColor == byEndInfo[nSurY][nSurX]))
                        continue;
                    if (nColor == -1) {
                        nColor = byEndInfo[nSurY][nSurX];
                        if (nColor == 0) {
                            nColor = -1;
                            nEmpCount++;
                        }
                        continue;
                    }
                    if (byEndInfo[nSurY][nSurX] == 0) {
                        nEmpCount++;
                        continue;
                    }
                    break NextCont;
                }
                if (nEmpCount == 0)
                    byEndInfo[nBoardY][nBoardX] = (byte) nColor;
            } while (false);
            continue;
        }
        MEMCPY(nTmpGrpNumberBoard, m_Engine.m_byGroupBoard, m_Engine.m_byGroupBoard.length - 1);

        for (nGrpNumber = m_Engine.m_nTotalGroupCount; nGrpNumber > 0; nGrpNumber--) {
            if ( (m_Engine.m_stGroup[nGrpNumber].nAliveDead == 0xFF) ||
                    ( (m_Engine.m_stGroup[nGrpNumber].nAliveDead == 0xFE) &&
                            (m_Engine.m_stGroup[nGrpNumber].nTotalSize ==
                                    m_Engine.m_stGroup[nGrpNumber].nSituation))) {
                nCount = 1;
                nExtendCount = 0;

                while (nCount > 0) {
                    nCount = 0;
                    nExtendCount++;
                    if (nExtendCount > 6)
                        break;
                    for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS;
                         m_Engine.m_nMainPosition++) {
                        if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == INITVALUE)
                            continue;

                        nBoardX = (short) (m_Engine.m_nMainPosition % 20 - 1);
                        nBoardY = (short) (m_Engine.m_nMainPosition / 20 - 1);

                        if (byEndInfo[nBoardY][nBoardX] != 0)
                            continue;

                        for (j = 0; j < 4; j++) {
                            nSurX = (short) (nBoardX + (short) m_Engine.AroundPointPosTable[j * 2]);
                            nSurY = (short) (nBoardY + (short) m_Engine.AroundPointPosTable[j * 2 + 1]);
                            nSurPos = (short) (m_Engine.m_nMainPosition + m_Engine.m_cAroundTable[j]);

                            if (m_Engine.m_byBoard[nSurPos] == INITVALUE)
                                continue;

                            if ((m_Engine.m_byGroupBoard[nSurPos] & 0xff) == nGrpNumber) {
                                nCount++;
                                if (IsWhite(nGrpNumber)) {
                                    byEndInfo[nBoardY][nBoardX] = 2;
                                    nTmpGrpNumberBoard[m_Engine.m_nMainPosition] = (byte) nGrpNumber;
                                } else {
                                    byEndInfo[nBoardY][nBoardX] = 1;
                                    nTmpGrpNumberBoard[m_Engine.m_nMainPosition] = (byte) nGrpNumber;
                                }
                                break;
                            }
                        }
                    }
                    MEMCPY(m_Engine.m_byGroupBoard, nTmpGrpNumberBoard, m_Engine.m_byGroupBoard.length - 1);
                }
            }
        }
        return;
    }

    boolean ADiagInflu(short nDiagPos, short nColor, byte[] pbyCountOfTwo, byte[] pnMainWeight) {
        byte byStrNberber;
        short wStatus;
        short n1stLayerPos;
        short n2ndLayerPos;
        short nSaved;
        short nNew1stLayerPos;
        byte cOtherStoneWeight;
        short nResultFlag;
        byte cDiagWeight;

        if (m_Engine.byStandardBoard[nDiagPos] != 0)
            return false;

        byStrNberber = m_Engine.m_byBoard[nDiagPos];

        if (byStrNberber == 0) {
            if ((m_Engine.m_byPosBoard[nDiagPos] & 0xff) < 2)
                return false;
            if ((m_Engine.m_byPosBoard[nDiagPos] & 0xff) == 2) {
                n1stLayerPos = nDiagPos;

                if (nDiagPos > m_Engine.m_nMainPos)
                    n1stLayerPos -= 20;
                else
                    n1stLayerPos += 20;

                n2ndLayerPos = nDiagPos;

                if (n1stLayerPos > m_Engine.m_nMainPos)
                    n2ndLayerPos--;
                else
                    n2ndLayerPos++;

                if (m_Engine.m_byPosBoard[n1stLayerPos] != 2) {
                    nSaved = n1stLayerPos;
                    n1stLayerPos = n2ndLayerPos;
                    n2ndLayerPos = nSaved;
                }

                byStrNberber = m_Engine.m_byBoard[n2ndLayerPos];

                if (byStrNberber != 0) {
                    if (!IsEqualColor(byStrNberber, (byte) nColor))
                        return false;

                    //   -W-6-
                    //	 -o- -   1st Layer

                    byStrNberber = m_Engine.m_byBoard[n1stLayerPos];

                    nNew1stLayerPos = (short) (nDiagPos + nDiagPos - n1stLayerPos);

                    if ((byStrNberber != 0) && IsEqualColor(byStrNberber, (byte) nColor)) {
                        //    -W-6-
                        //	  -o-W-   1st Layer

                        byStrNberber = m_Engine.m_byBoard[nNew1stLayerPos];

                        if ( (byStrNberber == 0) || (m_Engine.byStandardBoard[nNew1stLayerPos]) != 0)
                            return false;

                        if (IsEqualColor(byStrNberber, (byte) nColor)) {
                            //     -W-6-
                            //	 -W-o-W-   1st Layer
                            if ( (m_Engine.m_nStoneCount[byStrNberber] != 1) ||
                                    (m_Engine.m_byLiberties[byStrNberber] != 1))
                                return false;

                            //     -B-W-6-
                            //	 -B-W-o-W-   1st Layer
                            (pnMainWeight[0])--;

                            if (pnMainWeight[0] != 0)
                                return false;
                            return true;
                        }
                        //     -W-6-
                        //	 -B-o-W-   1st Layer
                        cOtherStoneWeight = m_Engine.m_cWeightBoard[nNew1stLayerPos];

                        if (cOtherStoneWeight < 0)
                            cOtherStoneWeight = (byte) - cOtherStoneWeight;

                        if (cOtherStoneWeight >= 6)
                            return false;

                        if ((m_Engine.m_byLiberties[byStrNberber & 0xff] & 0xff) < 3)
                            return false;
                        (pnMainWeight[0])--;
                        if (pnMainWeight[0] != 0)
                            return false;
                        return true;
                    }

                    //    -W-6-
                    //	  -o-b-   1st Layer

                    nResultFlag = StoneExistance(nNew1stLayerPos, nColor);

                    if (nResultFlag == 1)
                        return false;

                    if (nResultFlag == 0) {
                        //     -W-6-
                        //	  o-o-b-   1st Layer

                        nResultFlag = StoneExistance(n2ndLayerPos + nDiagPos - n1stLayerPos, nColor);

                        if (nResultFlag != -1) {
                            if ( (nResultFlag == 1) &&
                                    ((m_Engine.m_byLiberties[m_Engine.m_byBoard[n2ndLayerPos] & 0xff] & 0xff) > 3))
                                return false;

                            nResultFlag = StoneExistance(nDiagPos + 2 * (nDiagPos - n1stLayerPos), nColor);

                            if (nResultFlag != -1)
                                return false;
                        }
                    }
                    if (m_Engine.m_byBoard[m_Engine.m_nMainPos] == 0) {
                        byStrNberber = m_Engine.m_byBoard[n2ndLayerPos];

                        if ((m_Engine.m_byLiberties[byStrNberber & 0xff] & 0xff) <= 2) {
                            // The Surrounding Weights are 3,0xfd.????

                            if (m_Engine.m_byBoard[n1stLayerPos] == 0) {
                                if (nColor == 1)
                                    m_Engine.m_cWeightBoard[n1stLayerPos] = 1;
                                else
                                    m_Engine.m_cWeightBoard[n1stLayerPos] = -1;
                            }
                        }
                    }

                    (pnMainWeight[0])--;

                    if (pnMainWeight[0] != 0)
                        return false;
                    return true;
                }
            }
        }

        if (!IsWhite(nColor)) {
            if (byStrNberber == 0) {
                cDiagWeight = m_Engine.m_cWeightBoard[nDiagPos];

                if (cDiagWeight == -1)
                    return false;

                if (cDiagWeight < -2)
                    return false;

                if (cDiagWeight == -2) {
                    (pbyCountOfTwo[0])++;
                    return false;
                }

                (pnMainWeight[0])--;

                if (pnMainWeight[0] == 0)
                    return true;
                return false;
            }

            if (!IsWhite(byStrNberber))
                return false;
        } else {
            if (byStrNberber == 0) {
                cDiagWeight = m_Engine.m_cWeightBoard[nDiagPos];
                if (cDiagWeight == 1)
                    return false;

                if (cDiagWeight > 2)
                    return false;

                if (cDiagWeight == 2) {
                    //(pbyCountOfTwo[0])++;
                    pbyCountOfTwo[0] = (byte)((pbyCountOfTwo[0] & 0xff) + 1);
                    return false;
                }

                (pnMainWeight[0])--;
                if (pnMainWeight[0] == 0)
                    return true;
                return false;
            }

            if (IsWhite(byStrNberber))
                return false;
        }
        wStatus = m_Engine.m_wStatus[byStrNberber & 0xff];

        if ( (wStatus & 4) != 0)
            return false;

        if ( (wStatus & 0x400) == 0) {
            //(pnMainWeight[0])--;
            pnMainWeight[0] = (byte)((pnMainWeight[0] & 0xff) - 1);
            if (pnMainWeight[0] == 0)
                return true;
            return false;
        }

        (pnMainWeight[0]) -= 2;
        return ( (byte) (pnMainWeight[0]) > 0) ? false : true;
    }

    boolean IsEqualColor(byte byStringNumber1, byte byStringNumber2) {
        if ( (byStringNumber1 == 0) || (byStringNumber2 == 0))
            return false;
        return (((byStringNumber1 ^ byStringNumber2) & 1) == 0);
    }

    short StoneExistance(int nSurPos, short nColor) {
        /*
                     0:	No Stone,	Stone in Status 11
                     1:	OutSide,	Dead Stone,			Alive Stone of Equal Color
                     -1:	Alive Stone of Other Color
         */

        byte bySurStrNum = m_Engine.m_byBoard[nSurPos];

        if (m_Engine.byStandardBoard[nSurPos] != 0)
            return 1;

        if (bySurStrNum == 0)
            return 0;

        if ( (m_Engine.m_wStatus[bySurStrNum & 0xff] & 0x04) != 0)
            return 1;
        if ( (m_Engine.m_wStatus[bySurStrNum & 0xff] & 0x400) == 0)
            return 0;

        if (IsEqualColor(bySurStrNum, (byte) nColor))
            return 1;
        return -1;
    }

    short SideOtherStone(short nColor, int byStandard, byte[] pbyOtherStoneCount, short[] pwOtherStoneCoord,
                         short[] pwAnOtherStoneCoord) {
        short nSurCount;
        short nSurPos;
        byte bySideStrNum;

        pbyOtherStoneCount[0] = 0;

        for (nSurCount = 0; nSurCount < 4; nSurCount++) {
            nSurPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSurCount]);

            bySideStrNum = m_Engine.m_byBoard[nSurPos];

            if (m_Engine.byStandardBoard[nSurPos] != 0)
                continue;

            if (((bySideStrNum & 0xff) > 0) && IsEqualColor(bySideStrNum, (byte) (nColor + 2)))
                continue;

            if ( (pbyOtherStoneCount[0]) == 0) {
                pbyOtherStoneCount[0] = 1;
                pwOtherStoneCoord[0] = nSurPos;
            } else {
                (pbyOtherStoneCount[0])++;

                if ( (pbyOtherStoneCount[0] & 0xff) > (byStandard & 0xff))
                    return 0;
                else
                    pwAnOtherStoneCoord[0] = nSurPos;
            }
            continue;
        }

        if ((pbyOtherStoneCount[0] & 0xff) > (byStandard & 0xff))
            return 0;

        if ((pbyOtherStoneCount[0]) == byStandard)
            return -1;

        return 1;
    }

    void WhiteSideWeight(short nSidePos, byte[] pnMainWeight) {
        byte cSideWeight, nTemp;

        if (m_Engine.byStandardBoard[nSidePos] != 0)
            return;

        if (m_Engine.m_byBoard[nSidePos] != 0) {
            return;
        }

        cSideWeight = m_Engine.m_cWeightBoard[nSidePos];

        if (cSideWeight > 2)
            return;

        nTemp = (byte) ((cSideWeight > 0) ? 5 : 3);

        pnMainWeight[0] = (byte) Math.min(pnMainWeight[0], nTemp);
    }

    void BlackSideWeight(short nSidePos, byte[] pnMainWeight) {
        byte cSideWeight, nTemp;

        if (m_Engine.byStandardBoard[nSidePos] != 0)
            return;

        if (m_Engine.m_byBoard[nSidePos] != 0) {
            return;
        }
        cSideWeight = m_Engine.m_cWeightBoard[nSidePos];

        if (cSideWeight < -2)
            return;

        nTemp = (byte) ( (cSideWeight < 0x0) ? -5 : -3);

        pnMainWeight[0] = (byte) Math.max(pnMainWeight[0], nTemp);
    }

    void EyeBasedDataCalc(short nColor, byte byBitThatManyTwosIs, byte[] pnMainWeight) {
        byte byOtherStoneCount[] = {0};
        byte nWeight;

        short wSideStoneCoord[] = {0}
                , wNextSideStoneCoord[] = {0};
        short wOtherStoneCoord[] = {0}
                , wAnOtherStoneCoord[] = {0};

        byte cSideWeight, cNextSideWeight;
        short nSavedTempPos;
        short nResultFlag;
        short nNextSideStrNum;

        if (SideOtherStone(nColor, 1, byOtherStoneCount, wSideStoneCoord, wAnOtherStoneCoord) == 0)
            return;

        if (byOtherStoneCount[0] == 0) {
            if ( (pnMainWeight[0]) == 5) {
                if (byBitThatManyTwosIs == 0)
                    (pnMainWeight[0]) = 4;
                return;
            }

            (pnMainWeight[0])++;
            if (byBitThatManyTwosIs == 0)
                (pnMainWeight[0])++;
            return;

        }

        if (m_Engine.m_byBoard[wSideStoneCoord[0]] != 0)
            return;

        nSavedTempPos = m_Engine.m_nMainPos;

        m_Engine.m_nMainPos = wSideStoneCoord[0];

        cSideWeight = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos];

        nResultFlag = SideOtherStone(nColor, 2, byOtherStoneCount,
                wNextSideStoneCoord, wAnOtherStoneCoord);

        m_Engine.m_nMainPos = nSavedTempPos;

        if (nResultFlag == 0) {
            if ((pnMainWeight[0] & 0xff) < 6)
                return;

            if ( (cSideWeight < 3) && (cSideWeight > -3))
                (pnMainWeight[0]) = 4;

            return;
        }

        if (byOtherStoneCount[0] != 1) {
            if (wNextSideStoneCoord[0] == (short) m_Engine.m_nMainPos)
                wNextSideStoneCoord[0] = wAnOtherStoneCoord[0];

            cNextSideWeight = m_Engine.m_cWeightBoard[wNextSideStoneCoord[0]];

            if ( (cNextSideWeight >= 6) || (cNextSideWeight <= -6))
                return;
            if (m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0) {
                if ( (pnMainWeight[0]) == 5) {
                    if (byBitThatManyTwosIs == 0)
                        (pnMainWeight[0]) = 4;
                } else {
                    //(pnMainWeight[0])++;
                    pnMainWeight[0] = (byte)((pnMainWeight[0] & 0xff) + 1);
                    if (byBitThatManyTwosIs == 0)
                        //(pnMainWeight[0])++;
                        pnMainWeight[0] = (byte)((pnMainWeight[0] & 0xff) + 1);
                }
                return;
            }

            nNextSideStrNum = (short)(m_Engine.m_byBoard[wNextSideStoneCoord[0]] & 0xff);

            if (nNextSideStrNum != 0) {
                if ((m_Engine.m_byLiberties[nNextSideStrNum] & 0xff) > 2) {
                    if (pnMainWeight[0] != 5) {
                        if (byBitThatManyTwosIs == 0)
                            pnMainWeight[0] = 4;
                        else
                            pnMainWeight[0] = 5;
                    } else
                        pnMainWeight[0] = 3;
                } else if (m_Engine.m_byLiberties[nNextSideStrNum] == 2) {
                    if ( (pnMainWeight[0]) == 5)
                        return;
                    if (byBitThatManyTwosIs == 0)
                        pnMainWeight[0] = 4;
                    else
                        pnMainWeight[0] = 5;
                    return;
                } else if ((m_Engine.m_nStoneCount[nNextSideStrNum] & 0xff) >= 2) {
                    if ( (pnMainWeight[0]) == 5) {
                        if (byBitThatManyTwosIs == 0)
                            (pnMainWeight[0]) = 4;
                    } else {
                        //(pnMainWeight[0])++;
                        pnMainWeight[0] = (byte)((pnMainWeight[0] & 0xff) + 1);
                        if (byBitThatManyTwosIs == 0)
                            //(pnMainWeight[0])++;
                            pnMainWeight[0] = (byte)((pnMainWeight[0] & 0xff) + 1);
                    }
                } else if ( (pnMainWeight[0]) != 5) {
                    if (byBitThatManyTwosIs == 0)
                        pnMainWeight[0] = 4;
                    else
                        pnMainWeight[0] = 5;
                }
                return;
            }
            if (pnMainWeight[0] != 5) {
                if ( (cSideWeight > 3) || (cSideWeight < -3)) {
                    if (byBitThatManyTwosIs == 0)
                        //(pnMainWeight[0]) += 2;
                        (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 2);
                    else
                        //(pnMainWeight[0]) += 1;
                        (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 1);
                }
                return;
            }
            nSavedTempPos = m_Engine.m_nMainPos;

            m_Engine.m_nMainPos = wNextSideStoneCoord[0];

            nResultFlag = SideOtherStone(nColor, 2, byOtherStoneCount,
                    wOtherStoneCoord, wAnOtherStoneCoord);

            m_Engine.m_nMainPos = nSavedTempPos;

            if (nResultFlag == 1) {
                if ( (cNextSideWeight != 1) && (cNextSideWeight != -1))
                    return;

                if (m_Engine.m_byBoard[m_Engine.m_nMainPos] == 0) {
                    if (m_Engine.m_byBoard[wSideStoneCoord[0]] != 0) {
                        nWeight = 4;

                        if ( (nColor & 1) == 0)
                            nWeight = (byte) - nWeight;

                        m_Engine.m_cWeightBoard[wSideStoneCoord[0]] = nWeight;
                        return;
                    } else {
                        if (pnMainWeight[0] == 5)
                            return;
                        if (byBitThatManyTwosIs == 0)
                            (pnMainWeight[0]) += 2;
                        else
                            (pnMainWeight[0]) += 1;
                        return;
                    }
                } else {
                    if (m_Engine.m_byBoard[wSideStoneCoord[0]] == 0) {
                        if ( (pnMainWeight[0]) == 5)
                            pnMainWeight[0] = 4;
                        else {
                            if (byBitThatManyTwosIs == 0)
                                (pnMainWeight[0]) += 2;
                            else
                                (pnMainWeight[0]) += 1;
                        }
                        return;
                    } else {
                        if (pnMainWeight[0] == 5)
                            return;
                        if (byBitThatManyTwosIs == 0)
                            (pnMainWeight[0]) += 2;
                        else
                            (pnMainWeight[0]) += 1;
                        return;
                    }
                }
            } else {
                if ((nResultFlag == -1) &&
                        ((m_Engine.m_byPosBoard[wSideStoneCoord[0]] & 0xff) >= 3)) {
                    if ( (pnMainWeight[0]) != 5) {
                        //(pnMainWeight[0])++;
                        (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 1);
                        if (byBitThatManyTwosIs == 0)
                            //(pnMainWeight[0])++;
                            (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 1);

                        return;
                    } else {
                        if (byBitThatManyTwosIs == 0)
                            (pnMainWeight[0]) = 4;
                        return;
                    }
                }
                if ((pnMainWeight[0] & 0xff) < 6)
                    return;

                if ((cSideWeight < -3) || (cSideWeight > 3))
                    pnMainWeight[0] = 8;
//update
                else if ((cSideWeight == -3) || (cSideWeight == 3))
                    pnMainWeight[0] = 7;

                else if ((cSideWeight > -3) && (cSideWeight < 3))
                    pnMainWeight[0] = 4;

                return;
            }
        }
        if (m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0) {
            if ( (pnMainWeight[0]) != 5) {
                if (byBitThatManyTwosIs == 0)
                    //(pnMainWeight[0]) += 2;
                    (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 2);
                else
                    (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 1);

                return;
            } else {
                if (byBitThatManyTwosIs == 0)
                    pnMainWeight[0] = 4;
                else
                    pnMainWeight[0] = 5;

                return;
            }
        }

        if ( (cSideWeight == 1) || (cSideWeight == -1)) {
            if ((pnMainWeight[0]) == 5)
                pnMainWeight[0] = 3;

            else if (byBitThatManyTwosIs == 0)
                pnMainWeight[0] = 4;

            else
                pnMainWeight[0] = 5;

            return;
        }
        if ((pnMainWeight[0]) == 5)
            return;

        //(pnMainWeight[0])++;
        (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 1);

        if (byBitThatManyTwosIs == 0)
            //(pnMainWeight[0])++;
            (pnMainWeight[0]) = (byte)((pnMainWeight[0] & 0xff) + 1);

        return;
    }

    boolean SpecialValue(byte cValue) {
        if((cValue == 7) || (cValue == 4) || (cValue == 8))
            return false;

        return true;
    }

    byte AstonePosWeight(boolean bLayerFlag) {
        short nSurCount;
        short byStrNber;
        short nLayerNum;
        short nWeight = 0;
        short nStoneWeight;

        short byOtherStrNber;

        short nPos;
        short nSurStrNum;
        short wSurStatus;
        short nSurLayerNum;
        short nSurWeight;
        short ndX, ndY;
        boolean bExchangeFlag;
        short nOldWeight;
        try {

            m_Engine.m_nMainPos = m_Engine.m_nBoardPos;
            byStrNber = m_Engine.m_byBoard[m_Engine.m_nMainPos];
            nLayerNum = (short)(m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff);
            Last:
            do {
                if (bLayerFlag) {
                    if (m_Engine.m_nStoneCount[byStrNber] != 1) {
                        nWeight = 0;
                        break Last;
                    }
                    if (nLayerNum > 3)
                        nWeight = (short) (nLayerNum - 3);
                    else if (nLayerNum < 3) {
                        nWeight = 5;
                        if (m_Engine.byStandardBoard[m_Engine.m_nMainPos - 1] != 0) {
                            if ((m_Engine.m_byBoard[m_Engine.m_nMainPos + 1] == 0) &&
                                    ((byOtherStrNber = m_Engine.m_byBoard[m_Engine.m_nMainPos + 2]) != 0) &&
                                    (((byOtherStrNber ^ m_Engine.m_byNewStringNumber) & 1) == 0) &&
                                    ((m_Engine.m_wStatus[byOtherStrNber] & 8) == 0))
                                nWeight = 1;
                        } else if (m_Engine.byStandardBoard[m_Engine.m_nMainPos + 1] != 0) {
                            if ( (m_Engine.m_byBoard[m_Engine.m_nMainPos - 1] == 0) &&
                                    ( (byOtherStrNber = m_Engine.m_byBoard[m_Engine.m_nMainPos - 2]) != 0) &&
                                    ( ( (byOtherStrNber ^ m_Engine.m_byNewStringNumber) & 1) == 0) &&
                                    ( (m_Engine.m_wStatus[byOtherStrNber] & 8) == 0))
                                nWeight = 1;
                        } else if (m_Engine.byStandardBoard[m_Engine.m_nMainPos - 20] != 0) {
                            if ( (m_Engine.m_byBoard[m_Engine.m_nMainPos + 20] == 0) &&
                                    ( (byOtherStrNber = m_Engine.m_byBoard[m_Engine.m_nMainPos + 40]) != 0) &&
                                    ( ((byOtherStrNber ^ m_Engine.m_byNewStringNumber) & 1) == 0) &&
                                    ( (m_Engine.m_wStatus[byOtherStrNber] & 8) == 0))
                                nWeight = 1;
                        } else if (m_Engine.byStandardBoard[m_Engine.m_nMainPos + 20] != 0) {
                            if ( (m_Engine.m_byBoard[m_Engine.m_nMainPos - 20] == 0) &&
                                    ( (byOtherStrNber = m_Engine.m_byBoard[m_Engine.m_nMainPos - 40]) != 0) &&
                                    ( ( (byOtherStrNber ^ m_Engine.m_byNewStringNumber) & 1) == 0) &&
                                    ( (m_Engine.m_wStatus[byOtherStrNber] & 8) == 0))
                                nWeight = 1;
                        }
                    } else
                        nWeight = 2;

                } else {
                    if (nLayerNum < 3)
                        nWeight = 5;
                    else
                        nWeight = (short) ((byStrNber == m_Engine.m_byNewStringNumber) ? 5 : 2);
                }

                ExpressWallPos(m_Engine.m_nMainPos, m_Engine.m_byPotentialWallPos);

                for (nSurCount = 0; nSurCount < 20; nSurCount++) { //32
                    if (m_Engine.m_byPotentialWallPos[nSurCount] >= 0x40)
                        continue;

                    nPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSurCount]);

                    nSurStrNum = (short)(m_Engine.m_byBoard[nPos] & 0xff);

                    if (nSurStrNum < 1)
                        continue;

                    wSurStatus = m_Engine.m_wStatus[nSurStrNum];

                    if ( (wSurStatus & 4) != 0)
                        continue;
                    if (nSurCount < 20)
                        Screening(nSurCount);

                    if (nSurCount < 4)
                        continue;
                    if (((byStrNber ^ nSurStrNum) & 1) != 0)
                        continue;

                    nSurLayerNum = (short)(m_Engine.m_byPosBoard[nPos] & 0xff);
                    nStoneWeight = m_Engine.nConstSurStonePos[nSurCount];
                    if (nLayerNum <= 2) {
                        if (nSurLayerNum > 3) {
                            if (nStoneWeight != 0)
                                continue;
                            nStoneWeight = 3;
                        } else if (nSurLayerNum < 3) {
                            if (nStoneWeight == 0) {
                                nWeight = 0;
                                break Last;
                            }
                            if ((m_Engine.m_byLiberties[nSurStrNum] & 0xff) < 3)
                                continue;
                        }
                    } else if (nStoneWeight != 0) {
                        if (((nLayerNum == 3) && (nSurLayerNum == 4)) ||
                                ((nLayerNum == 4) && (nSurLayerNum == 3)))
                            nStoneWeight = 1;
                        else {
                            if ((nLayerNum == 4) && (nSurLayerNum == 4))
                                nStoneWeight = 0;
                            else if ( (nSurLayerNum < 3) &&
                                    ((m_Engine.m_byLiberties[nSurStrNum] & 0xff) < 3))
                                continue;
                        }
                    }

                    if (m_Engine.m_cAreaBoard[nPos] == 3) {
                        nSurWeight = m_Engine.m_cWeightBoard[nPos];
                        if ((byStrNber & 1) != 0)
                            nSurWeight = (short) - nSurWeight;
                        nStoneWeight = (short) Math.max(nStoneWeight, nSurWeight);
                    }
                    nWeight = (short) Math.min(nWeight, nStoneWeight);
                }

                if (nLayerNum < 3)
                    return ( (byte) nWeight);

                if (nLayerNum == 3) {

                    ndX = -1;
                    ndY = 20;
                    bExchangeFlag = false;
                    if (m_Engine.m_byPosBoard[m_Engine.m_nMainPos + ndX] != 2) {
                        ndX = (short) - ndX;
                        if (m_Engine.m_byPosBoard[m_Engine.m_nMainPos + ndX] != 2) {
                            bExchangeFlag = true;
                            if (m_Engine.m_byPosBoard[m_Engine.m_nMainPos + ndY] != 2) {
                                ndY = (short) - ndY;
                            }
                        }
                    }
                    return ( (byte) nWeight);
                }

                if ( (byStrNber & 1) != 0)
                    nWeight = (short) - nWeight;
            } while (false); //$Last:
            nOldWeight = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos];

            m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = (byte) nWeight;
            if (nOldWeight != nWeight) {
                m_Engine.m_nBoardPos = m_Engine.m_nMainPos;
                ExpressTempArea();
            }
        } catch (Exception e) {
            //System.out.println("Exception.");
            //e.printStackTrace();
        }
        return (byte) nWeight;
    }

    short ThreatDegree(short byStrNumbr) {
        short nSurCount;

        short nStoneWeight = 0;
        short nSubWeight;

        boolean bRet;

        for (nSurCount = 0; nSurCount < 4; nSurCount++) {
            if (IsLayColorLive(nSurCount, byStrNumbr)) {
                nSubWeight = 3;

                if (nSurCount == 3)
                    bRet = IsLayColorLive(0, byStrNumbr);
                else
                    bRet = IsLayColorLive(nSurCount + 1, byStrNumbr);

                if (bRet)
                    return 5;

                if (IsLayColorLive(nSurCount + 4, byStrNumbr))
                    nSubWeight++;
                if (nSurCount == 3)
                    bRet = IsLayColorLive(nSurCount + 1, byStrNumbr);
                else
                    bRet = IsLayColorLive(nSurCount + 5, byStrNumbr);

                if (bRet)
                    nSubWeight++;
                if (nSubWeight >= 5)
                    return 5;

                nStoneWeight = (short) Math.max(nStoneWeight, nSubWeight);
            }
        }
        return nStoneWeight;
    }

    boolean IsLayColorLive(int nSurroundingNumber, short byStrNumbr) {
        short nPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSurroundingNumber]);
        short wStatus;

        if (m_Engine.byStandardBoard[nPos] != 0)
            return false;
        if (((m_Engine.m_byPosBoard[nPos] & 0xff) <= 2) ||
                (!IsOtherColor(nPos, byStrNumbr)))
            return false;
        wStatus = m_Engine.m_wStatus[m_Engine.m_byBoard[nPos]];
        if ( ( (wStatus & 4) != 0) || ( (wStatus & 0x400) == 0))
            return false;
        return true;
    }

    boolean IsOtherColor(short nPos, short byStrNberber) {
        if (((m_Engine.m_byBoard[nPos] ^ byStrNberber) & 1) != 0)
            return true;
        else
            return false;
    }

    boolean IsFourDiagonalLinkable(byte[] pnFourDiagonalStatus, byte byStrNumbr) {
        byte byDiagStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPos + 19]; //m_Engine.m_byBoardY + 1][m_Engine.m_byBoardX - 1];

        if (byDiagStrNum != (byte)0xf0) {
            if ( (!IsOtherStone((short)(byDiagStrNum & 0xff), (short)(byStrNumbr & 0xff))) && (byDiagStrNum != 0) &&
                    ((m_Engine.m_byLiberties[byDiagStrNum & 0xff] & 0xff) >= 2) &&
                    (!DiagSidePos(19, pnFourDiagonalStatus, 0, (short)(byStrNumbr & 0xff))))
                return true;
            if (byDiagStrNum == 0) {
                if ( (!DiagSidePos(19, pnFourDiagonalStatus, 0, (short)(byStrNumbr & 0xff)))
                        && (pnFourDiagonalStatus[0] == 4))
                    return true;
                pnFourDiagonalStatus[0] = 0;
            }
        }
        byDiagStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPos - 21]; //m_Engine.m_byBoardY - 1][m_Engine.m_byBoardX - 1];

        if (byDiagStrNum != (byte)0xf0) {
            if ( (!IsOtherStone((short)(byDiagStrNum & 0xff), (short)(byStrNumbr & 0xff))) &&
                    (byDiagStrNum != 0) && (m_Engine.m_byLiberties[byDiagStrNum] >= 2) &&
                    (!DiagSidePos( -21, pnFourDiagonalStatus, 1, (short)(byStrNumbr & 0xff))))
                return true;
            if (byDiagStrNum == 0) {
                if ( (!DiagSidePos( -21, pnFourDiagonalStatus, 1, (short)(byStrNumbr & 0xff)))
                        && (pnFourDiagonalStatus[1] == 4))
                    return true;
                pnFourDiagonalStatus[1] = 0;
            }
        }
        byDiagStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPos - 19]; //m_Engine.m_byBoardY - 1][m_Engine.m_byBoardX + 1];
        if (byDiagStrNum != (byte)0xf0) {
            if ( (!IsOtherStone((short)(byDiagStrNum & 0xff), (short)(byStrNumbr & 0xff))) &&
                    (byDiagStrNum != 0) && ((m_Engine.m_byLiberties[byDiagStrNum & 0xff] & 0xff) >= 2) &&
                    (!DiagSidePos( -19, pnFourDiagonalStatus, 2, (short)(byStrNumbr & 0xff))))
                return true;
            if (byDiagStrNum == 0) {
                if ( (!DiagSidePos( -19, pnFourDiagonalStatus, 2, (short)(byStrNumbr & 0xff)))
                        && (pnFourDiagonalStatus[2] == 4))
                    return true;
                pnFourDiagonalStatus[2] = 0;
            }
        }
        byDiagStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPos + 21]; //m_Engine.m_byBoardY + 1][m_Engine.m_byBoardX + 1];
//	if((( m_Engine.m_byBoardY + 1 ) < m_Engine.m_byBoardSize )  && (( m_Engine.m_byBoardY + 1 ) < m_Engine.m_byBoardSize))
        if (byDiagStrNum != (byte)0xf0) {
            if ( (!IsOtherStone((short)(byDiagStrNum & 0xff), (short)(byStrNumbr & 0xff))) &&
                    (byDiagStrNum != 0) && ((m_Engine.m_byLiberties[byDiagStrNum & 0xff] & 0xff) >= 2) &&
                    (!DiagSidePos(21, pnFourDiagonalStatus, 3, (short)(byStrNumbr & 0xff))))
                return true;
            if (byDiagStrNum == 0) {
                if ( (!DiagSidePos(21, pnFourDiagonalStatus, 3, (short)(byStrNumbr & 0xff)))
                        && (pnFourDiagonalStatus[3] == 4))
                    return true;
                pnFourDiagonalStatus[3] = 0;
            }
        }
        return false;
    }

    boolean IsOtherStone(short nA, short nB) {
        if ( ( (nA ^ nB) & 1) != 0)
            return true;
        else
            return false;
    }

    boolean DiagSidePos(int nBias, byte[] byRet, int indexbyRet, short byStrNumbr) {
        byte byStrNberY; //= m_Engine.m_byBoard[m_Engine.m_nMainPos m_Engine.m_byBoardY+nYBias][m_Engine.m_byBoardX];
        byte byStrNberX; //= m_Engine.m_byBoard[m_Engine.m_nMainPos+nXBias];
        boolean bFlag1 = false;
        boolean bFlag2 = false;
        byte byBiasX, byBiasY;

        byte byStone1 = 0, byStone2 = 0;
        short byStrNber1, byStrNber2;
        try {
            if (nBias > 0) {
                byStrNberY = m_Engine.m_byBoard[m_Engine.m_nMainPos + 20];
                byBiasY = 20;
                if (nBias > 20) {
                    byStrNberX = m_Engine.m_byBoard[m_Engine.m_nMainPos + 1];
                    byBiasX = 1;
                } else {
                    byStrNberX = m_Engine.m_byBoard[m_Engine.m_nMainPos - 1];
                    byBiasX = (byte)0xff;
                }
            } else {
                byStrNberY = m_Engine.m_byBoard[m_Engine.m_nMainPos - 20];
                //byBiasY = (byte)0xE0;		//by Jong 2004/8/5	-20;
                byBiasY = -20;
                if (nBias > -20) {
                    byStrNberX = m_Engine.m_byBoard[m_Engine.m_nMainPos + 1];
                    byBiasX = 1;
                } else {
                    byStrNberX = m_Engine.m_byBoard[m_Engine.m_nMainPos - 1];
                    byBiasX = (byte)0xFF;		//by Jong 2004/8/5	-1;
                }
            }

            if (byStrNberY != 0) {
                bFlag1 = true;
                if ( (m_Engine.m_wStatus[byStrNberY & 0xff] & 4) != 0) {
                    byRet[indexbyRet] = 1;
                    return false;
                }
                if (m_Engine.m_byLiberties[byStrNberY & 0xff] == 1)
                    bFlag1 = false;
            }
            if (byStrNberX != 0) {
                bFlag2 = true;
                if ( (m_Engine.m_wStatus[byStrNberX & 0xff] & 4) != 0) {
                    byRet[indexbyRet] = 1;
                    return false;
                }
                if (m_Engine.m_byLiberties[byStrNberX & 0xff] == 1)
                    bFlag2 = false;
            }
            if ( (!bFlag1) && (!bFlag2)) {
                byRet[indexbyRet] = 1;

//		if ( (( m_Engine.m_byBoardY+2*nYBias ) < 0) || (( m_Engine.m_byBoardY+2*nYBias ) >= m_Engine.m_byBoardSize ) )
                if ((m_Engine.byStandardBoard[m_Engine.m_nMainPos + byBiasY * 2] & 0xff) > 0)
                    byStrNber2 = -1;
                else {
                    byStone2 = PositionSort(m_Engine.m_nMainPos + byBiasY * 2, byStrNumbr);
                    byStrNber2 = (short) (m_Engine.m_byBoard[m_Engine.m_nMainPos + byBiasY * 2] & 0xff);
                }

//		if ( ((m_Engine.m_byBoardX+2*nXBias) < 0) || ((m_Engine.m_byBoardX+2*nXBias) >= m_Engine.m_byBoardSize ) )
                if ((m_Engine.byStandardBoard[m_Engine.m_nMainPos + byBiasX * 2] & 0xff) > 0)
                    byStrNber1 = -1;
                else {
                    byStone1 = PositionSort(m_Engine.m_nMainPos + byBiasX * 2, byStrNumbr);
                    byStrNber1 = m_Engine.m_byBoard[m_Engine.m_nMainPos + 2 * byBiasX];
                }

                if ((byStone1 == 1) && (byStrNber1 != -1) && (byStone2 == 1) && (byStrNber2 != -1)
                        && ((IDist.getByte(m_Engine.m_byLiberties, byStrNber1) & 0xff) > 3) &&
                        ((IDist.getByte(m_Engine.m_byLiberties, byStrNber2) & 0xff) > 3))

//upversion
//(m_Engine.m_byLiberties[byStrNber1] > 2)&&(m_Engine.m_byLiberties[byStrNber2] > 2)***StringStatus[]
                    byRet[indexbyRet] = 4;

                return false;
            }

            if (bFlag1 && bFlag2) {
                byRet[indexbyRet] = 3;
                return true;
            }

            if (!bFlag1) {
//		if ( ( ( m_Engine.m_byBoardX-nXBias ) < 0 ) || ( ( m_Engine.m_byBoardX - nXBias ) >= m_Engine.m_byBoardSize ) ||
//				( ( m_Engine.m_byBoardY + nYBias ) < 0 ) || ( ( m_Engine.m_byBoardY + nYBias ) >= m_Engine.m_byBoardSize ) )
                if ((m_Engine.byStandardBoard[m_Engine.m_nMainPos - byBiasX + byBiasY] & 0xff) > 0) {
                    byStone1 = (byte) ( ( (1 ^ byStrNumbr) & 1) + 1);
                    byStrNber1 = -1;
//upversion
//
//
                } else {
                    byStone1 = PositionSort(m_Engine.m_nMainPos - byBiasX + byBiasY, byStrNumbr);
                    byStrNber1 = (short)(m_Engine.m_byBoard[m_Engine.m_nMainPos - byBiasX + byBiasY] & 0xff);
                }

//		if ( ((m_Engine.m_byBoardY+2*nYBias) < 0) || ((m_Engine.m_byBoardY+2*nYBias) >= m_Engine.m_byBoardSize ) )
                if ( ((m_Engine.byStandardBoard[m_Engine.m_nMainPos + byBiasY] & 0xff) > 0) ||
                        ((m_Engine.byStandardBoard[m_Engine.m_nMainPos + 2 * byBiasY] & 0xff) > 0)) {
                    byStone2 = (byte) (((1 ^ byStrNumbr) & 1) + 1);
                    byStrNber2 = -1;
                } else {
                    byStone2 = PositionSort(m_Engine.m_nMainPos + 2 * byBiasY, byStrNumbr);
                    byStrNber2 = (short) (m_Engine.m_byBoard[m_Engine.m_nMainPos + 2 * byBiasY] & 0xff);
                }
            } else {
//		if ( ((m_Engine.m_byBoardX+nXBias) < 0) || ((m_Engine.m_byBoardX+nXBias) >= m_Engine.m_byBoardSize ) ||
//				((m_Engine.m_byBoardY-nYBias)<0) || ((m_Engine.m_byBoardY-nYBias)>=m_Engine.m_byBoardSize) )
                if ((m_Engine.byStandardBoard[m_Engine.m_nMainPos + byBiasX - byBiasY] & 0xff) > 0) {
                    byStone1 = (byte) (((1 ^ byStrNumbr) & 1) + 1);
                    byStrNber1 = -1;
                } else {
                    byStone1 = PositionSort(m_Engine.m_nMainPos + byBiasX - byBiasY, byStrNumbr);
                    byStrNber1 = (short)(m_Engine.m_byBoard[m_Engine.m_nMainPos + byBiasX - byBiasY] & 0xff);
                }

//		if ( ((m_Engine.m_byBoardX+2*nXBias) < 0) || ((m_Engine.m_byBoardX+2*nXBias) >= m_Engine.m_byBoardSize ) )
                if ( ((m_Engine.byStandardBoard[m_Engine.m_nMainPos + byBiasX] & 0xff) > 0) ||
                        ((m_Engine.byStandardBoard[m_Engine.m_nMainPos + 2 * byBiasX] & 0xff) > 0)) {
                    byStone2 = (byte)(((1 ^ byStrNumbr) & 1) + 1);
                    byStrNber2 = -1;
                } else {
                    byStone2 = PositionSort(m_Engine.m_nMainPos + 2 * byBiasX, byStrNumbr);
                    //HJ_Debug>>
                    //System.out.println("m_Engine.m_nMainPos + 2 * byBiasX" + (m_Engine.m_nMainPos + 2 * byBiasX));
                    //<<
                    byStrNber2 = (short) (m_Engine.m_byBoard[m_Engine.m_nMainPos + 2 * byBiasX] & 0xff);
                }
            }
            if ((byStone1 == 2) && ((IDist.getByte(m_Engine.m_byLiberties, byStrNber1) & 0xff) > 2)) {
                byRet[indexbyRet] = 2;
                return true;
            }
            if ( (byStone2 == 2) && ((IDist.getByte(m_Engine.m_byLiberties, byStrNber2) & 0xff) > 2)) {
                byRet[indexbyRet] = 2;
                return true;
            }
            if ((byStone1 != 1) && (byStrNber1 != -1) && (byStone2 != 1) && (byStrNber2 != -1)) {
                byRet[indexbyRet] = 2;
                return true;
            } else {
                byRet[indexbyRet] = 1;
                return false;
            }
        } catch (Exception e) {
            //System.out.println("Exception.");
            //e.printStackTrace();
        }
        return false; //for dummy
    }

    byte PositionSort(int nPos, short byStrNberber) {
        if (m_Engine.m_byBoard[nPos] == 0)
            return 0;
        if (((m_Engine.m_byBoard[nPos] ^ (byte)(byStrNberber & 0xff)) & 1) != 0)
            return 2;
        else
            return 1;
    }

    short SurStoneExistColor(int nSurCount, byte[] pbyBitStoneStatus, byte[] pbySurEmptyPosCount,
                             byte[] pbySurStoneWeight) {
        short nPos;
        byte byStrNberber;
        //HJ_Debug>>
        //nPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSurCount]);
        //<<
        try {
            if (m_Engine.m_byPotentialWallPos[nSurCount] == 0xff)
                return -1;

            nPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSurCount]);
            byStrNberber = m_Engine.m_byBoard[nPos];

            if ((byStrNberber & 0xff) < 1)
                return -1;

            pbySurEmptyPosCount[0] = (byte) m_Engine.m_byLiberties[byStrNberber & 0xff];
            pbySurStoneWeight[0] = (byte) m_Engine.m_cWeightBoard[nPos];

            if ( (m_Engine.m_nStoneCount[byStrNberber & 0xff] != 1) || (pbySurEmptyPosCount[0] < 4) ||
                    ( ((m_Engine.m_byPosBoard[m_Engine.m_nMainPos] & 0xff) - 1) < (pbySurEmptyPosCount[0] & 0xff)) ||
                    (nSurCount >= 0x24) || (nSurCount < 8) || ( ( (pbyBitStoneStatus[0]) & 0x3) != 0) ||
                    (byStrNberber != m_Engine.m_byNewStringNumber) ||
                    (m_Engine.m_byPotentialWallPos[nSurCount] != 0))
                return (short) (IsWhite(byStrNberber) ? 1 : 0);

            if (IsWhite(m_Engine.m_byNewStringNumber)) {
                if (pbySurStoneWeight[0] == 0) { //|| (pbySurEmptyPosCount[0] < 4))
                    (pbyBitStoneStatus[0]) |= 1;
                    return 1;
                }
                if ( (byte)(pbySurStoneWeight[0]) < -2)
                    return 1;
                else {
                    (pbyBitStoneStatus[0]) |= 4;
                    return 1;
                }
            } else {
                if (pbySurStoneWeight[0] == 0) {
                    (pbyBitStoneStatus[0]) |= 2;
                    return 0;
                }
                if ((pbySurStoneWeight[0] & 0xff) >= 3)
                    return 0;
                else {
                    (pbyBitStoneStatus[0]) |= 8;
                    return 0;
                }
            }
        } catch (Exception e) {
            //System.out.println("Exception.");
            //HJ_Debug>>
//            System.out.println("m_Engine.m_nMainPos" + m_Engine.m_nMainPos);
//            System.out.println("m_Engine.m_cAroundTable[" + nSurCount + "] = " +
//                               m_Engine.m_cAroundTable[nSurCount]);
//            System.out.println("nPos = " + nPos);
            //<<
            //e.printStackTrace();
        }
        return 0; //for dummy
    }

    void SideStoneScreening(short nSurCount, byte[] bySurStoneWeight, byte[] bySideStoneProperty) {
        short nPos = (short) (m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSurCount]);
        short[] pn;
        int indexpn = 0;

        if ((m_Engine.m_byPosBoard[nPos] & 0xff) < 3) {
            pn = m_Engine.pnScreeningPoint[nSurCount];
            while (pn[indexpn] != 0) {
                m_Engine.m_byPotentialWallPos[pn[indexpn]] |= 0x40;
                indexpn++;
            }
            return;
        }

        if (bySurStoneWeight[0] == 0) {
            bySideStoneProperty[0] &= 0x23;
            if (m_Engine.m_byPosBoard[nPos] != 3)
                bySideStoneProperty[0] = 0x20;
        }

        //Start Screening();

        pn = m_Engine.pnScreeningPoint[nSurCount];
        indexpn = 0;
        while (pn[indexpn] != 0) {
            m_Engine.m_byPotentialWallPos[pn[indexpn]] |= 0x40;
            indexpn++;
        }

        //END Screening();

        bySurStoneWeight[0] = bySideStoneProperty[0];
        bySurStoneWeight[0] &= 03;
        bySideStoneProperty[0] &= 0x30;

        indexpn++;
        if (m_Engine.m_byPotentialWallPos[pn[indexpn]] != 0xFF) {
            m_Engine.m_byPotentialWallPos[pn[indexpn]] |= (short) (bySurStoneWeight[0] & 0xff);
            m_Engine.m_byPotentialWallPos[pn[indexpn]] += (short) (bySideStoneProperty[0] & 0xff);
        }

        indexpn++;
        if (m_Engine.m_byPotentialWallPos[pn[indexpn]] != 0xFF) {
            m_Engine.m_byPotentialWallPos[pn[indexpn]] |= (short) (bySurStoneWeight[0] & 0xff);
            m_Engine.m_byPotentialWallPos[pn[indexpn]] += (short) (bySideStoneProperty[0] & 0xff);
        }
        return;
    }

    void Screening(short nSurCount) {
        short[] pn = m_Engine.pnScreeningPoint[nSurCount];
        int indexpn = 0;

        while (pn[indexpn] != 0) {
            m_Engine.m_byPotentialWallPos[pn[indexpn]] |= 0x40;
            indexpn++;
        }
    }

    void MoveData() {
        MEMCPY(m_Engine.m_cTempWeightBoard, m_Engine.m_cWeightBoard, m_Engine.m_cWeightBoard.length);
        MEMCPY(m_Engine.m_byTempGroupBoard, m_Engine.m_byGroupBoard, m_Engine.m_byGroupBoard.length);
        MEMCPY(m_Engine.m_stTempGroup, m_Engine.m_stGroup, m_Engine.m_stGroup.length);
        MEMCPY(m_Engine.m_byTempBitGroupRelInfo, m_Engine.m_byBitGroupRelInfo,
                m_Engine.m_byBitGroupRelInfo.length);
        MEMCPY(m_Engine.m_wTempStatus, m_Engine.m_wStatus, m_Engine.m_wStatus.length);
        m_Engine.m_byTempWhiteGroupCount = m_Engine.m_byWhiteGroupCount;
        m_Engine.m_byTempBlackGroupCount = m_Engine.m_byBlackGroupCount;
        m_Engine.m_nTempDifOfTerritory = m_Engine.m_nDifOfTerritory;
        m_Engine.m_wTempWhiteTSize = m_Engine.m_wWhiteTSize;
        m_Engine.m_wTempBlackTSize = m_Engine.m_wBlackTSize;
        m_Engine.m_nTempGroupCount = m_Engine.m_nTotalGroupCount;
        m_Engine.m_cComAverageWeight = 0;
    }

    short ToWeight2(short Weight1) {
        if (Weight1 == 1)
            return 0;
        return (++Weight1);
    }

    short GetMoveFromSimul(short[] pwPoint) {
        short wTemp, wAttackPt, wDefensePt;
        short byStr;
        short nAttackResult[] = new short[4], nDefenseResult[] = new short[4];
        short nScore, nLocalScore;
        short nCount, nCount1, nStnsOfRelStrs;
        byte cPreStatus, cStatusFirst, cStatusSecond;
        int pnMove, pnMove1;
        int pnResult;
        short wPoint;

        m_Engine.m_nHuboScore = -1;
        m_Engine.m_wHuboPoint = 0;
        m_Engine.m_byWhereCall = 0;
        try {
            for (byStr = 1; byStr < MAX_STRINGCOUNT; byStr++) {
                if (((byStr ^ (byte)m_Engine.m_nComStoneColor) & 1) == 0)
                    wTemp = m_Engine.m_wResultInFirst[byStr];
                else
                    wTemp = m_Engine.m_wResultInSecond[byStr];
                if (wTemp == (short) 0xffff)
                    continue;

                pnResult = wTemp;
                //((NPMOVE)(pResult + 1))->cStatus
                if (m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT + 2] <= 0)
                    continue;

                pnResult = m_Engine.m_wResultInSecond[byStr];

                wAttackPt = (short) (((m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT + 1] & 0xffff) << 8) |
                        (m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT] & 0xff));
                m_Engine.m_byTurnColor = ((byStr & 1) != 0) ? IS_BLACK : IS_WHITE;
                if ( (m_Engine.m_byTurnColor == (byte) m_Engine.m_nComStoneColor) &&
                        (wAttackPt == (short) m_Engine.m_nPaePos))
                    continue;

                m_Engine.m_nBoardPos = wAttackPt;
                nAttackResult[1] = (short)Math.max(PatternScore(m_Engine.m_byTurnColor), 0);
                nAttackResult[1] = (short) ((nAttackResult[1] + 1) / 2);

                m_Engine.m_byStrNum = byStr;
//		ScoreInSecond((NPshort) &nAttackResult[0], (NPshort) &nAttackResult[2]);
                m_Engine.m_nAttachedStrs = 0;
                AliveNeighborsOnMyDead(byStr);
                nCount = m_Engine.m_nProfitStrs;

                m_Engine.m_nStnsOfRelStrs = 0;
                StatusOfRelStrs(byStr, wAttackPt);

                m_Engine.m_nPaePos = 0;
                m_Engine.m_nBoardPos = wAttackPt;
                SetStone2(m_Engine.m_byTurnColor);

                if (m_Engine.m_byNewLiberties == 1) {
                    if (m_Engine.m_nPaePos != 0)
                        m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xff] &= 0xfe01;
                    else
                        m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xff] &= 0x01ff;
                }

                m_Engine.m_byStrNum = (short)(m_Engine.m_byNewStringNumber & 0xff);
                nAttackResult[0] = ScoreOfNewStone(m_Engine.m_byNewStringNumber);
                m_Engine.m_byStrNum = byStr;

                if (m_Engine.m_byTurnColor != m_Engine.m_nComStoneColor)
                    nCount = 0;
                nScore = (short) ( (m_Engine.m_byTurnColor == IS_WHITE) ? m_Engine.m_cWhiteCountChange :
                        m_Engine.m_cBlackCountChange);
                if (nScore < 0)
                    nScore = 0;
                nAttackResult[2] = (short) ( (nScore + nCount) * 2);

                pnResult = m_Engine.m_wResultInFirst[byStr];
                nCount = m_Engine.m_pResultArea[pnResult];
                pnMove = pnResult + sizeofSIMULRESULT;
                cPreStatus = -1;

                m_Engine.m_byTurnColor ^= 3;
                nStnsOfRelStrs = m_Engine.m_nStnsOfRelStrs;

                for (; nCount > 0; nCount--, pnMove += sizeofSIMULMOVE) {
                    wPoint = (short) (((m_Engine.m_pResultArea[pnMove + 1] & 0xffff) << 8) |
                            (m_Engine.m_pResultArea[pnMove] & 0xff));
                    if ( (m_Engine.m_byTurnColor == (byte) m_Engine.m_nComStoneColor) &&
                            (wPoint == (short) m_Engine.m_nPaePos))
                        continue;
                    if ( (cPreStatus > 0) && (m_Engine.m_pResultArea[pnMove + 2] <= 0))
                        continue;

                    wDefensePt = wPoint;
                    cPreStatus = (byte) (m_Engine.m_pResultArea[pnMove + 2] & 0xff);
//			ScoInFirstAndSelectHubo(byStr, nAttackResult);
                    m_Engine.m_nAttachedStrs = 0;
                    m_Engine.m_wStatus[byStr] = (short) 0xff01;
                    StatusOfRelStrs(byStr, wDefensePt);

//			ScoreInFirst(wDefensePt, nDefenseResult);
                    wTemp = m_Engine.m_nPaePos;
                    m_Engine.m_nPaePos = 0;
                    m_Engine.m_nBoardPos = wDefensePt;
                    SetStone2(m_Engine.m_byTurnColor);
                    if ((m_Engine.m_byNewLiberties & 0xff) <= 0) {
                        m_Engine.m_nPaePos = wTemp;
                        nDefenseResult[0] = 0;
                        nDefenseResult[1] = 0;
                        nDefenseResult[2] = 0;
                        nDefenseResult[3] = -1;
                    } else {
                        nDefenseResult[3] = m_Engine.m_nDeadStoneCount;
                        if (m_Engine.m_byLiberties[byStr] == 1) {
                            m_Engine.m_nPaePos = m_Engine.m_nTempPaePos;
                            m_Engine.m_nDeadStoneCount = m_Engine.m_nTempDeadStoneCount;
                            MEMCPY(m_Engine.m_byBoard, m_Engine.m_byTempBoard, m_Engine.m_byBoard.length);
                            MEMCPY(m_Engine.m_byLiberties, m_Engine.m_byTempLiberties,
                                    m_Engine.m_byLiberties.length);
                            MEMCPY(m_Engine.m_nStoneCount, m_Engine.m_nTempStoneCount,
                                    m_Engine.m_nStoneCount.length);
                            MEMCPY(m_Engine.m_byLocalPattern, m_Engine.m_byTempLocalPattern,
                                    m_Engine.m_byLocalPattern.length);
                            nDefenseResult[0] = 0;
                            nDefenseResult[1] = 0;
                            nDefenseResult[2] = 0;
                        } else {
                            m_Engine.m_byNewStringNumber = (byte) byStr;
                            nDefenseResult[0] = ScoreOfNewStone(byStr);
                            m_Engine.m_byStrNum = byStr;

                            nDefenseResult[1] = (short)((PatternScore(m_Engine.m_byTurnColor) + 1) / 2);
                            nDefenseResult[2] = (m_Engine.m_byTurnColor == IS_WHITE) ?
                                    m_Engine.m_cWhiteCountChange : m_Engine.m_cBlackCountChange;
                            nDefenseResult[2] = (short) (Math.max(nDefenseResult[2], 0) * 2);
                        }
                    }

                    nScore = (short) (nAttackResult[0] + nDefenseResult[0]);
                    if (nScore >= 0) {
                        nLocalScore = (short) ((m_Engine.m_nStoneCount[byStr] * 2 +
                                m_Engine.m_nStnsOfRelStrs) / 2);
                        if (nLocalScore >= 6)
                            nDefenseResult[1] += 2;
                        else if (nLocalScore >= 3)
                            nDefenseResult[1] += 1;
                        nScore += nLocalScore / 2;

                        if (nScore > 1) {

                            nLocalScore = (short) Math.max(nDefenseResult[2] + nAttackResult[1],
                                    nAttackResult[2] + nDefenseResult[1]);
                            if (nLocalScore < 0)
                                nLocalScore = 0;

                            cStatusSecond = (byte) ((m_Engine.m_pResultArea[m_Engine.m_wResultInSecond[byStr] +
                                    sizeofSIMULRESULT + 2]) & 0xff);
                            pnMove1 = m_Engine.m_wResultInFirst[byStr] + sizeofSIMULRESULT;
                            nCount1 = m_Engine.m_pResultArea[m_Engine.m_wResultInFirst[byStr]];

                            wPoint = (short) ( ((m_Engine.m_pResultArea[pnMove1 + 1] & 0xffff) << 8) |
                                    (m_Engine.m_pResultArea[pnMove1] & 0xff));
                            while ( (wPoint != wDefensePt) && (nCount1 > 0)) {
                                pnMove1 += sizeofSIMULMOVE;
                                nCount1--;
                            }
                            cStatusFirst = (byte) m_Engine.m_pResultArea[pnMove1 + 2];

                            if (m_Engine.m_pResultArea[m_Engine.m_wResultInSecond[byStr] + 1] != 0)
                                nLocalScore += 3;
                            else
                                nLocalScore += 2;

                            if (cStatusSecond != 1) {
                                if (cStatusSecond == 2)
                                    nLocalScore -= 2;
                                else
                                    nLocalScore -= 3;
                            }
                            if (cStatusFirst != 1) {
                                if (cStatusFirst == 2)
                                    nLocalScore -= 2;
                                else
                                    nLocalScore -= 3;
                            }

                            if (nScore <= 0xff)
                                nScore = ScoreCollected(nScore, nLocalScore, (short) (cStatusSecond & 0x0f));
                            else {
                                nScore &= 0xff;
                                nScore = ScoreCollected( (short) (nScore + 3), nLocalScore,
                                        (short) (cStatusSecond & 0x0f));
                                nScore +=
                                        ScoreCollected( (short) - 3, nLocalScore, (short) (cStatusSecond & 0x0f));
                            }
                        }

                        if (m_Engine.m_nHuboScore < nScore) {
                            m_Engine.m_nHuboScore = nScore;
                            if (((byStr ^ (byte)m_Engine.m_nComStoneColor) & 1) != 0)
                                m_Engine.m_wHuboPoint = wAttackPt;
                            else
                                m_Engine.m_wHuboPoint = wDefensePt;
                        }
                    }
                    m_Engine.m_nStnsOfRelStrs = nStnsOfRelStrs;
                }
            }

            pwPoint[0] = m_Engine.m_wHuboPoint;
            m_Engine.m_nAttachedStrs = 0;
        } catch (Exception e) {
            //System.out.println("GetMoveFromSimul");
        }
        return m_Engine.m_nHuboScore;
    }

    short ScoreOfNewStone(short nStr) {
        short nMyScore[] = {0}
                , t, i;
        short nStrNum = (short)(m_Engine.m_byNewStringNumber & 0xff);
        short nNewSEP = (short)(m_Engine.m_byNewLiberties & 0xff);
        short nOldSEP = (short)(m_Engine.m_byTempLiberties[nStrNum] & 0xff);
        short nSCount = m_Engine.m_nSCount;
        boolean bAtari;

        m_Engine.m_nPos1 = m_Engine.m_nBoardPos;
        m_Engine.m_nPos2 = m_Engine.m_nPos3 = 0;
        m_Engine.m_nOldDeadCount = 0;

        if (nNewSEP < 2) {
            if (m_Engine.m_nPaePos == 0) {
                m_Engine.m_wStatus[nStr] = 0x01ff;
                m_Engine.m_nScoreBase = OldBoardScoreCalc();
                t = m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
                nMyScore[0] = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
                m_Engine.m_nNewTerritory = t;
                if (nMyScore[0] > 0) {
                    short temp[] = {m_Engine.m_nPos2};
                    GetEmptyPos(m_Engine.m_byBoard[m_Engine.m_nBoardPos], (short) 1, temp);
                    m_Engine.m_nPos2 = temp[0];
                    m_Engine.m_nBoardPos = m_Engine.m_nPos2;
                    m_Engine.m_nIniScore = nMyScore[0];
                    if (IsEnableTo(nMyScore))
                        nMyScore[0] = (short) (nMyScore[0] * 3 / 2);
                    else
                        nMyScore[0] = (short) (m_Engine.m_nIniScore / 2 + 1);
                }
            } else {
                bAtari = false;
                for (i = 0; i < m_Engine.m_nDCount; i++) {
                    if (m_Engine.m_byDifferLiberties[i] == 1)
                        break;
                }
                if (i < m_Engine.m_nDCount) {
                    bAtari = true;
                    m_Engine.m_wStatus[nStr] = (short) 0xff01;
                } else
                    m_Engine.m_wStatus[nStr] = 0x0101;

                m_Engine.m_nScoreBase = OldBoardScoreCalc();
                m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
                nMyScore[0] = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
                if ( (bAtari) && (nMyScore[0] > 0))
                    nMyScore[0] = (short) (nMyScore[0] * 5 / 4);
            }
            LoadData();
            return nMyScore[0];
        }
        if (nNewSEP < 4) {
            if ( (m_Engine.m_wStatus[nStr] & 0x08) == 0) {
                if ( (IfDeadByGroup(nStr, m_Engine.m_nBoardPos) == true) || (nNewSEP == 3) ||
                        (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] >= 3)) {
                    m_Engine.m_wStatus[nStr] = (short) 0xff01;
                    nMyScore[0] = ScoreOnManySEP();
                    if (nMyScore[0] > 0)
                        nMyScore[0] += nSCount;
                    LoadData();
                    m_Engine.m_nBoardPos = m_Engine.m_nPos1;
                    return nMyScore[0];
                }
            }
            m_Engine.m_nScoreBase = OldBoardScoreCalc();
            m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
            nMyScore[0] = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
            LoadData();
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            return nMyScore[0];
        }
        ;

        m_Engine.m_wStatus[nStr] = (short) 0xff01;
        nMyScore[0] = ScoreOnManySEP();

        if ((nMyScore[0] <= -2) && (nNewSEP > nOldSEP))
            nMyScore[0] = -1;

        LoadData();
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        return nMyScore[0];
    }

    boolean IsEnableTo(short[] pnMyScore) {
//	ASSERT(m_Engine.m_nPos2 == m_Engine.m_nBoardPos);
        m_Engine.m_nScoreBase = m_Engine.m_nDeadStoneCount;
        pnMyScore[0] = m_Engine.m_nScoreBase;

        if (SetStone2( (byte) (m_Engine.m_byTurnColor ^ 3)) < 0)
            return false;

        m_Engine.m_byTurnColor ^= 3;
        m_Engine.m_byNewStringNumber = (byte) 0xff;
        OldBoardScoreCalc();
        m_Engine.m_byTurnColor ^= 3;

        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        if (m_Engine.m_nChangedTSize <= 0) {
            pnMyScore[0] = m_Engine.m_nIniScore;
            return true;
        }
        m_Engine.m_nChangedTSize -= m_Engine.m_nNewTerritory;
        if (m_Engine.m_nChangedTSize > 0) { //??????? if(m_Engine.m_nChangedTSize <= 0)
            if (m_Engine.m_nChangedTSize < 12)
                pnMyScore[0] = -1;
            else
                pnMyScore[0] = -2;
            return false;
        }
        m_Engine.m_nChangedTSize = (short) - m_Engine.m_nChangedTSize;
        m_Engine.m_nDeadStoneCount = (short) (m_Engine.m_nScoreBase - m_Engine.m_nDeadStoneCount);
        m_Engine.m_nPos3 = 0;
        pnMyScore[0] = ResultGain(m_Engine.m_byWhereCall, (short) 0, m_Engine.m_nChangedTSize);
        if (pnMyScore[0] < 0) {
            pnMyScore[0] = -1;
            return false;
        }
        if (m_Engine.m_nIniScore < 0) {
            pnMyScore[0] = -1;
            return false;
        }
        pnMyScore[0] = (short) Math.min( ( (pnMyScore[0]) * 3 / 2), m_Engine.m_nIniScore);
        return true;
    }

    short ScoreCollected(short nScore, short nAction, short nRound) {
        short i, m, n;

        if ( (nScore == 0) || (nAction == 0))
            return nScore;

        if (nAction < 0) {
            n = (short) (nScore / 4);
            if (nAction == -1)
                return (short) (nScore - (n + 1) / 2);
            if (nAction == -2)
                return (short) (nScore - (nScore + 1) / 4);
            if (nAction == -3)
                return (short) (nScore - (3 * n + 1) / 2);
            m = (short) ( -nAction / 2);
            if ( (nAction & 1) != 0)
                nScore -= (n + 1) / 2;
            for (i = 1; i < m; i++)
                nScore = (short) ( (nScore + nRound) / 2);
            return nScore;
        }

        n = nScore;
        if (nAction > 9) {
            nScore += (12 * n) / 4;
            if (nAction >= 13)
                nScore += n / 8;
            return nScore;
        }

        m = (short) (nAction / 2);
        if ( (nAction & 1) != 0)
            n += nScore / 4;
        if (m == 0)
            nScore = n;
        else if (m == 1)
            nScore = (short) (n + (nScore + 1) / 2);
        else if (m == 2)
            nScore += n;
        else if (m == 3)
            nScore += (n + (nScore + 1) / 2);
        else
            nScore += n * 2;
        return nScore;
    }

    void GetMainScore() {
        short nScore;

        m_Engine.m_byWhereCall = (byte) PS_POS;
        m_Engine.g_byTwoPat = 0;

        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 0x80000000;

        if (m_Engine.nEvaluCount > 16) {
            nScore = GetScore(m_Engine.m_nComStoneColor);
            if ( m_Engine.m_bStop )
                return;

            if (m_Engine.g_bFlag) {
                m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = -1;
                m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = -1;
                return;
            }
            if (m_Engine.m_nComStoneColor == IS_BLACK) {
                m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = nScore;

                if (nScore < 0)
                    m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = -1;
                else
                    m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = 0;
            } else {
                if (nScore < 0)
                    m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = -1;
                else
                    m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = 0;

                m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = nScore;
            }

            if (m_Engine.nEvaluCount < 30)
                m_Engine.m_byExpressBoard[m_Engine.m_nBoardPos] = 2;
            else
                m_Engine.m_byExpressBoard[m_Engine.m_nBoardPos] = 1;

            return;
        }
        nScore = GetScore(BLACK);
        if ( m_Engine.m_bStop )
            return;

        if (m_Engine.g_bFlag) {
            m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = -1;
            m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = -1;
            return;
        }
        m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = nScore;

        nScore = GetScore(WHITE);
        if ( m_Engine.m_bStop )
            return;

        if (m_Engine.g_bFlag) {
            m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = -1;
            m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = -1;
            return;
        }

        m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = nScore;

        m_Engine.m_byExpressBoard[m_Engine.m_nBoardPos] = 3;

    }

    short GetScore(short nColor) {
        short nSCount;
        long nBitControl;
        short nScore;

        m_Engine.m_nPos1 = m_Engine.m_nBoardPos;
        m_Engine.m_nPos2 = m_Engine.m_nPos3 = 0;
        m_Engine.m_nOldDeadCount = 0;
        m_Engine.m_byTurnColor = (byte) nColor;

        m_Engine.g_bFlag = false;
        if (m_Engine.m_nPaePos == m_Engine.m_nPos1) {
            m_Engine.g_bFlag = true;
            return -1;
        }
        m_Engine.m_byStrNum = 0xff;
        if ( SetStone2(m_Engine.m_byTurnColor) < 0 )
        {
            LoadData();

            if ((m_Engine.m_byNewLiberties & 0xff) < 1) {
//		m_Engine.g_bFlag = TRUE;
                return -1;
            }
            m_Engine.m_bStop = true;
            return -1;
        }
        m_Engine.m_byStrNum = (short)(m_Engine.m_byNewStringNumber & 0xff);

        nSCount = m_Engine.m_nSCount;
        nBitControl = m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] & 0x0c;

        if (m_Engine.m_byNewLiberties == 1)
            nScore = ScoreOnOneSEP((m_Engine.m_nPaePos != 0));
        else if ( (nBitControl & 0xc) != 0) {
            nColor = 1;
            if (nBitControl != 4) {
                nColor = 2;
            }
            nScore = ScoreOnCrisisPos(nColor);
        } else if ((m_Engine.m_byNewLiberties & 0xff) < 4) {
            nScore = ScoreOnLittleSEP();
        } else {

            m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xff] = (short) 0xff01;
            nScore = ScoreOnManySEP();
        }

        LoadData();
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        return nScore;
    }

    void GetShapeScore(short nPos, short[] pnScoreCom, short[] pnScoreHuman) {
        long nBit;
        try {

            GetComHumanScore(nPos, pnScoreCom, pnScoreHuman);

            nBit = ( (m_Engine.m_lBitBoard[nPos] & 0x7FFFFFFF) >> 12) & 0x0f;

            if (pnScoreCom[0] > 0)
                pnScoreCom[0] = (short) (pnScoreCom[0] * (m_Engine.MulValue[(int)nBit]) / 10);
            if (pnScoreHuman[0] > 0)
                pnScoreHuman[0] = (short) (pnScoreHuman[0] * (m_Engine.MulValue[(int)nBit]) / 10);
        } catch (Exception e) {
            //System.out.println("here");
        }
    }

    void GetCollectedScore(short nScore1, short nScore2, short[] pnScore1, short[] pnScore2) {
        short nFlag;
        short nAppend1, nAppend2;
        short nAppend3, nAppend4;
        short wTemp;
        short nTemp;
        short nWeight;

        nFlag = 0;
        m_Engine.m_byWhereCall = (byte) 0xff;
        if ( (m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] & 0xf000) != 0) {
            nAppend1 = nAppend2 = 0;
        } else if ( (m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] & 0x0e) != 0) {

            if( m_Engine.m_nGameLevel > 2 )
                wTemp = PatternScore_Both(m_Engine.m_nComStoneColor, (byte) 0);
            else
                wTemp = 0;
            nAppend1 = (short) (byte) LOBYTE(wTemp);
            nAppend2 = (short) (byte) HIBYTE(wTemp);
        } else {
            nAppend1 = (short) (- GetDiffer());
            if ( (m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] & 0x40) != 0)
                nAppend1 -= 2;
            if( m_Engine.m_nGameLevel > 2 )
                wTemp = PatternScore_Both(m_Engine.m_nComStoneColor, (byte) nAppend1);
            else
                wTemp = 0;

            nAppend1 = (short) (byte) LOBYTE(wTemp);
            nAppend2 = (short) (byte) HIBYTE(wTemp);
            nWeight = m_Engine.m_cWeightBoard[m_Engine.m_nBoardPos];

            nTemp = (short) ( (nWeight > 0) ? nWeight : -nWeight);

            if (nTemp < 5)
                nFlag = 1;
            else {
                if (nWeight > 0) {
                    nAppend4 = 0;
                    nAppend3 = (short) ( (nWeight == 5) ? 1 : 2);
                    if (m_Engine.m_cAverageWeight > 0)
                        nAppend3 >>= m_Engine.m_cAverageWeight;
                } else {
                    nAppend3 = 0;
                    nAppend4 = (short) ( (nWeight == -5) ? 1 : 2);
                    if (m_Engine.m_cAverageWeight < 0)
                        nAppend4 >>= ( -m_Engine.m_cAverageWeight);
                }

                if (m_Engine.m_nComStoneColor == IS_WHITE) {
                    nTemp = nAppend3;
                    nAppend3 = nAppend4;
                    nAppend4 = nTemp;
                }

                nAppend1 -= nAppend3;
                nAppend2 -= nAppend4;
            }
            nAppend1 -= m_Engine.m_cComAverageWeight;
            nAppend2 += m_Engine.m_cComAverageWeight;
        }
        pnScore1[0] = ChangeScore(nScore1, nAppend1, nFlag);
        pnScore2[0] = ChangeScore(nScore2, nAppend2, nFlag);
    }

    short ChangeScore(short nScore, short nAppend, short nFlag) {
        long nBit;// long is 4 bytes of data type int C, 8 bytes in Java.
        short nTemp, i;

        nBit = m_Engine.m_lBitBoard[m_Engine.m_nBoardPos];

        if ( (nBit & 0x0e) != 0) {
            if (nAppend < 0)
                nAppend = 0;
            else if ( ( (nBit & 0x0c) == 0x08) || ( (nBit & 0x0c) == 0x04))
                nAppend++;
        }

        if (nScore < 0) {
            if (nAppend > 0)
                nScore *= (nAppend + 4) / 4;
            return nScore;
        }
        if ( (nScore == 0) || (nAppend == 0))
            return (nScore);

        nTemp = nScore;
        if (nAppend < 0) {
            nAppend = (short) - nAppend;
            if ( (nAppend & 1) != 0) {
                nAppend >>= 1;
                nTemp = (short) (nTemp >> 2);
                if (nAppend == 1)
                    nScore -= nTemp;
                nTemp = (short) ( (nTemp + 1) >> 1);
                nScore -= nTemp;
                if (nAppend < 2)
                    return (nScore);
            } else {
                nAppend >>= 1;
                if (nAppend == 1) {
                    nTemp = (short) ( (nTemp + 1) >> 2);
                    nScore -= nTemp;
                    return (nScore);
                }
            }
            for (i = 0; i < nAppend - 1; i++)
                nScore = (short) ( (nScore + nFlag) >> 1);
            return (nScore);
        }

        if (nAppend >= 9) { //\uFFFDf\uFFFD^\uFFFDE\uFFFD\uFFFD\uFFFD`
            nScore *= 4;
            if (nAppend == 9) //\uFFFDf\uFFFD^\uFFFDE\uFFFD\uFFFD\uFFFD`
                nScore -= nTemp / 2;
            return (nScore);
        }
        if ( (nAppend & 1) != 0) {
            nAppend >>= 1;
            nTemp += (nScore / 4);
        } else
            nAppend >>= 1;

        if (nAppend >= 4)
            return (short) (nTemp * 2 + nScore);

        if (nAppend >= 2)
            nTemp += nScore;
        if ( (nAppend == 1) || (nAppend == 3))
            nTemp += ( (nScore + 1) / 2);

        return nTemp;
    }

    short PatternScore_Both(short nColor, byte cBaseScore) {
        m_Engine.m_cBaseScore = cBaseScore;
        return GetScorePattern(nColor);
    }

    short GetScorePattern(short nColor)
    {
        byte	cMyScore, cOppScore, cScore1, cScore2;
        byte[]	pPattern;

        m_Engine.m_nMainPosi = m_Engine.m_nBoardPos;
        m_Engine.m_nPosCode = (short)(m_Engine.m_byPosBoard[m_Engine.m_nMainPosi] & 0xff);

        pPattern = m_Engine.m_byLocalPattern[m_Engine.m_nMainPosi];

        //memcpy(&m_wNearby, ((BYTE*)pPattern), sizeof(WORD));
        m_Engine.m_wNearby = MAKEWORD((pPattern[0] & 0xff), (pPattern[1] & 0xff));
        m_Engine.m_byAttach = pPattern[0];
        m_Engine.m_byKosumi = pPattern[1];

        //memcpy(&m_wKeima, ((BYTE*)pPattern + 3), sizeof(WORD));
        m_Engine.m_wKeima = MAKEWORD((pPattern[3] & 0xff), (pPattern[4] & 0xff));
        m_Engine.m_wKeima = rolw2(m_Engine.m_wKeima);
        m_Engine.m_byKeima1 = LOBYTE(m_Engine.m_wKeima);
        m_Engine.m_byKeima2 = HIBYTE(m_Engine.m_wKeima);
        m_Engine.m_byIKen = pPattern[2];
        m_Engine.m_byDKosumi = pPattern[8];
        m_Engine.m_wIKenDKos = MAKEWORD((m_Engine.m_byIKen & 0xff),
                (m_Engine.m_byDKosumi & 0xff));
        m_Engine.m_byNiKen = pPattern[5];
        //memcpy(&m_wOKeima, ((BYTE*)pPattern + 6), sizeof(WORD));
        m_Engine.m_wOKeima = MAKEWORD((pPattern[6] & 0xff), (pPattern[7] & 0xff));
        m_Engine.m_wOKeima = rolw2(m_Engine.m_wOKeima);
        if (m_Engine.m_byWhereCall == 1)
        {
            if (nColor == 1)
                cMyScore  = BiasPattern_White();
            else
                cMyScore  = BiasPattern_Black();
            return MAKEWORD((cMyScore & 0xff), 0);
        }

        EvenPattern();

        if (nColor == 1)
        {
            cOppScore = (byte)(m_Engine.m_cBaseScore + BiasPattern_Black());
            cMyScore  = (byte)BiasPattern_White();
        }
        else
        {
            cOppScore = (byte)(m_Engine.m_cBaseScore + BiasPattern_White());
            cMyScore  = BiasPattern_Black();
        }
        if (m_Engine.m_nPosCode >= 3) cOppScore = AdjustScore(cOppScore);

        cScore1 = (byte)(cMyScore / 4 + cOppScore);
        cScore2 = (byte)(cMyScore / 2 + cOppScore);

        if (cScore1 > 10) cScore1 = (byte)((cScore1 - 10) / 2 + 10);
        if (cScore2 > 10) cScore2 = (byte)((cScore2 - 10) / 2 + 10);

        return MAKEWORD((cScore1 & 0xff), (cScore2 & 0xff));
    }

    /*
        short GetScorePattern(short nColor) {
            byte cMyScore, cOppScore, cScore1, cScore2;
            byte[] pPattern;

            m_Engine.m_nMainPosi = m_Engine.m_nBoardPos;
            m_Engine.m_nPosCode = (short) m_Engine.m_byPosBoard[m_Engine.m_nMainPosi];

            pPattern = m_Engine.m_byLocalPattern[m_Engine.m_nMainPosi];

            m_Engine.m_wNearby = (short) (pPattern[0] | pPattern[1] << 8);

            m_Engine.m_wKeima = (short) (pPattern[3] | pPattern[4] << 8);
            m_Engine.m_wKeima = rolw2(m_Engine.m_wKeima);

            m_Engine.m_byIKen = pPattern[2];
            m_Engine.m_byDKosumi = pPattern[8];
            m_Engine.m_wIKenDKos = MAKEWORD(m_Engine.m_byIKen, m_Engine.m_byDKosumi);

            m_Engine.m_byNiKen = pPattern[5];

            m_Engine.m_wOKeima = (short) (pPattern[6] | pPattern[7] << 8);
            m_Engine.m_wOKeima = rolw2(m_Engine.m_wOKeima);

            if (m_Engine.m_byWhereCall == 1) {
                cMyScore = BiasPattern(nColor);
                return MAKEWORD(cMyScore, 0);
            }

            EvenPattern();

            cOppScore = (byte) (m_Engine.m_cBaseScore + BiasPattern( (short) (nColor ^ 3)));
            cMyScore = BiasPattern(nColor);

            if (m_Engine.m_nPosCode >= 3)
                cOppScore = AdjustScore(cOppScore);

            cScore1 = (byte) (cMyScore / 4 + cOppScore);
            cScore2 = (byte) (cMyScore / 2 + cOppScore);

            if (cScore1 > 10)
                cScore1 = (byte) ( (cScore1 - 10) / 2 + 10);
            if (cScore2 > 10)
                cScore2 = (byte) ( (cScore2 - 10) / 2 + 10);

            return MAKEWORD(cScore1, cScore2);
        }
    */
    short SelectOptimalCandi(short nControl, short[] pnWeight2, short[] nNumber) {
        short i, j;

        j = -1;
        for (i = 0; i < MAXCANDINUM; i++)
            if (m_Engine.m_Candi[i].Prop != (byte) 0xff) {
                if ( (j == -1) || (m_Engine.m_Candi[i].Weight1 > m_Engine.m_Candi[j].Weight1) ||
                        ((m_Engine.m_Candi[i].Weight1 == m_Engine.m_Candi[j].Weight1)
                                && ((m_Engine.m_Candi[i].Weight2 & 0xff) > (m_Engine.m_Candi[j].Weight2 & 0xff))
                                && ((m_Engine.m_Candi[i].Weight2 & 0xff) > 0))) {
                    j = i;
                }
            }
        if (j != -1) {
            m_Engine.m_nComStonePos = m_Engine.m_Candi[j].nPos;
            m_Engine.m_nComStoneWeight1 = m_Engine.m_Candi[j].Weight1;
            pnWeight2[0] = (short) (m_Engine.m_Candi[j].Weight2 & 0xFF);
            nNumber[0] = j;
            return (short) (m_Engine.m_Candi[j].Prop & 0x0f);
        } else {
            m_Engine.m_nComStonePos = 0;
            m_Engine.m_nComStoneWeight1 = -1;
            pnWeight2[0] = 0;
            nNumber[0] = -1;
            return 0;
        }
    }

    void RegisterCandi(short nProperty, short[] pnWeight2) {
        int i;

//	ASSERT ( IsInBoard( m_Engine.m_nComStonePos, m_Engine.m_nComStonePosY ));
        if (nProperty != -1) {
            for (i = MAXCANDINUM - 1; i > 2; i--) {
                if (m_Engine.m_Candi[i].Prop == (byte) 0xff)
                    continue;
                if (m_Engine.m_Candi[i].Weight1 > m_Engine.m_nComStoneWeight1)
                    break;
                if ( (m_Engine.m_Candi[i].Weight1 == m_Engine.m_nComStoneWeight1) &&
                        (pnWeight2[0] > (m_Engine.m_Candi[i].Weight2 & 0xff)))
                    break;
                //m_Engine.m_Candi[i + 1] = m_Engine.m_Candi[i];
                m_Engine.m_Candi[i+1].nPos = m_Engine.m_Candi[i].nPos;
                m_Engine.m_Candi[i+1].Weight1 = m_Engine.m_Candi[i].Weight1;
                m_Engine.m_Candi[i+1].Weight2 = m_Engine.m_Candi[i].Weight2;
                m_Engine.m_Candi[i+1].Prop = m_Engine.m_Candi[i].Prop;
            }
            i++;
            if (m_Engine.m_Candi[i].nPos != m_Engine.m_nComStonePos) {
                m_Engine.m_Candi[i].nPos = m_Engine.m_nComStonePos;
                m_Engine.m_Candi[i].Weight1 = m_Engine.m_nComStoneWeight1;
                m_Engine.m_Candi[i].Weight2 = (byte)(pnWeight2[0]);
                m_Engine.m_Candi[i].Prop = (byte) nProperty;
            }
        }
        if (m_Engine.m_Candi[MAXCANDINUM - 1].Prop == (byte) 0xff) {
            m_Engine.m_nComStonePos = 0;
            m_Engine.m_nComStoneWeight1 = -1;
            pnWeight2[0] = 0;
        } else {
            m_Engine.m_nComStonePos = m_Engine.m_Candi[MAXCANDINUM - 1].nPos;
            m_Engine.m_nComStoneWeight1 = m_Engine.m_Candi[MAXCANDINUM - 1].Weight1;
            pnWeight2[0] = (short) (m_Engine.m_Candi[MAXCANDINUM - 1].Weight2 & 0xFF);
        }
    }

    void LoadData() {
        LoadMainData();
        MEMCPY(m_Engine.m_byLocalPattern, m_Engine.m_byTempLocalPattern, m_Engine.m_byLocalPattern.length);
    }

    void LoadMainData() {
        MEMCPY(m_Engine.m_cWeightBoard, m_Engine.m_cTempWeightBoard, m_Engine.m_cWeightBoard.length);
        MEMCPY(m_Engine.m_byBoard, m_Engine.m_byTempBoard, m_Engine.m_byBoard.length);
        MEMCPY(m_Engine.m_byLiberties, m_Engine.m_byTempLiberties, m_Engine.m_byLiberties.length);
        MEMCPY(m_Engine.m_nStoneCount, m_Engine.m_nTempStoneCount, m_Engine.m_nStoneCount.length);
        MEMCPY(m_Engine.m_wStatus, m_Engine.m_wTempStatus, m_Engine.m_wStatus.length);
        m_Engine.m_byWhiteGroupCount = m_Engine.m_byTempWhiteGroupCount;
        m_Engine.m_byBlackGroupCount = m_Engine.m_byTempBlackGroupCount;
        m_Engine.m_nDifOfTerritory = m_Engine.m_nTempDifOfTerritory;
        m_Engine.m_wWhiteTSize = m_Engine.m_wTempWhiteTSize;
        m_Engine.m_wBlackTSize = m_Engine.m_wTempBlackTSize;
        m_Engine.m_nPaePos = m_Engine.m_nTempPaePos;
        m_Engine.m_nDeadStoneCount = m_Engine.m_nTempDeadStoneCount;
    }

    void TestAroundPoints() {
        short nScoreCom[] = {0}
                , nScoreHuman[] = {0};
        short wTempCandiPos[] = new short[5];
        short i, j, k;
        short nPos, nPos1, nPos2;
        short nPoints[] = {D1, L1, U1, R1, D1};

        MEMSET(wTempCandiPos, 0);
        wTempCandiPos[0] = m_Engine.m_nBoardPos;
        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 0x20;
        m_Engine.m_byControlFlag = 3;
        for (i = 0; i < 2; i++) {
            GetShapeScore(m_Engine.m_nBoardPos, nScoreCom, nScoreHuman);
            if ( (nScoreCom[0] == 1) && (nScoreHuman[0] == -2))
                break;
            short temp1[] = {m_Engine.m_nComStoneWeight1};
            short temp2[] = {m_Engine.m_nComStoneWeight2};
            GetGravityScore(nScoreCom[0], nScoreHuman[0], temp1, temp2);
            m_Engine.m_nComStoneWeight1 = temp1[0];
            m_Engine.m_nComStoneWeight2 = temp2[0];
            for (j = L1; j <= R1D1; j++) {
                nPos = (short) (m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[j]);
                if ( (nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
                    continue;

                for (k = 3; k < MAXCANDINUM; k++) {
                    if (m_Engine.m_Candi[k].Prop == (byte) 0xff)
                        continue;
                    if (nPos == m_Engine.m_Candi[k].nPos)
                        break;
                }
                if (k < MAXCANDINUM)
                    continue;

                if (j >= L1D1) {
                    nPos1 = (short) (m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nPoints[j - L1D1]]);
                    nPos2 = (short) (m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nPoints[j - D1]]);
                    if ( (m_Engine.m_byBoard[nPos1] != 0) && (m_Engine.m_byBoard[nPos2] != 0))
                        continue;
                }
                TestPos(nPos);
            }
            if (i == 0)
                m_Engine.m_byControlFlag = 2;
            m_Engine.m_nBoardPos = m_Engine.m_nComStonePos;
        }

        wTempCandiPos[1] = m_Engine.m_nComStonePos;
        if (wTempCandiPos[0] == wTempCandiPos[1]) {
            wTempCandiPos[1] = 0;
        }
    }

    void GetGravityScore(short nScoreCom, short nScoreHuman, short[] pnScore1, short[] pnScore2) {
        short nScore;
        if (nScoreHuman == -2)
            nScoreHuman = -1;
        //m_Engine.m_byAttentionColor = (BYTE) m_Engine.m_nComStoneColor;
        GetCollectedScore(nScoreCom, nScoreHuman, pnScore1, pnScore2);
        (pnScore1[0])++;
        (pnScore2[0])++;
        if ((m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] & 0xff) <= 2) {
            pnScore1[0] *= 2;
            pnScore2[0] *= 2;
        } else {
            pnScore1[0] = (short) (2 * (pnScore1[0]) + Math.min(5, (pnScore1[0]) >> 1));
            pnScore2[0] = (short) (2 * (pnScore2[0]) + Math.min(5, (pnScore2[0]) >> 1));
        }
        nScore = pnScore1[0];
        pnScore1[0] = (short) ((pnScore1[0] << (m_Engine.m_byControlFlag & 0xff)) + pnScore2[0]);
        pnScore2[0] = nScore;
        if (pnScore2[0] > 0xff)
            pnScore2[0] = -1; //%%%%%%%%%%%%%%%%%%%%%%%
    }

    void TestPos(short nPos) {
        long lBitControlValue;
        short nScoreCom[] = {0}
                , nScoreHuman[] = {0};
        short nScore1[] = {0}
                , nScore2[] = {0};
        short nTemp;

        lBitControlValue = m_Engine.m_lBitBoard[nPos];
        if ( (m_Engine.m_byBoard[nPos] != 0) || (nPos == m_Engine.m_nPaePos) ||
                ( (lBitControlValue & 0x20) != 0))
            return;
        m_Engine.m_lBitBoard[nPos] |= 0x20;
        lBitControlValue |= 0x20;
        if ( (lBitControlValue & 0x0f) == 0) {
            m_Engine.m_lBitBoard[nPos] |= 0x01;
            lBitControlValue |= 0x01;

            nTemp = m_Engine.m_nBoardPos;
            m_Engine.m_nBoardPos = nPos;
            GetMainScore();
            m_Engine.m_nBoardPos = nTemp;
        } while (true) {
            GetShapeScore(nPos, nScoreCom, nScoreHuman);
            if (nScoreCom[0] == -2)
                return;
            if ( (nScoreCom[0] == 1) && (nScoreHuman[0] == -2))
                return;
            nTemp = m_Engine.m_nBoardPos;
            m_Engine.m_nBoardPos = nPos;
            GetGravityScore(nScoreCom[0], nScoreHuman[0], nScore1, nScore2);
            if ( (nScore1[0] < m_Engine.m_nComStoneWeight1) ||
                    ( (nScore1[0] == m_Engine.m_nComStoneWeight1) && (nScore2[0] <= m_Engine.m_nComStoneWeight2))) {
                m_Engine.m_nBoardPos = nTemp;
                return;
            }
            if ( (m_Engine.m_lBitBoard[nPos] & 0x10) == 0) {
                m_Engine.m_nBoardPos = nTemp;
                break;
            }
            GetMainScoreOfTest();
            m_Engine.m_nBoardPos = nTemp;
        }
        m_Engine.m_nComStoneWeight1 = nScore1[0];
        m_Engine.m_nComStonePos = nPos;
    }

    void GetComHumanScore(short nPos, short[] pnScoreCom, short[] pnScoreHuman) {
        if (m_Engine.m_nComStoneColor == IS_BLACK) {
            pnScoreCom[0] = m_Engine.m_nBlackStoneBoard[nPos];
            pnScoreHuman[0] = m_Engine.m_nWhiteStoneBoard[nPos];
        } else {
            pnScoreCom[0] = m_Engine.m_nWhiteStoneBoard[nPos];
            pnScoreHuman[0] = m_Engine.m_nBlackStoneBoard[nPos];
        }

    }

    short GetPosForLast() {
        short nPos, i;

        m_Engine.m_byWhereCall = (byte) PS_SEL;
        m_Engine.m_nPos1 = m_Engine.m_nBoardPos;
        m_Engine.m_nPos2 = m_Engine.m_nPos3 = 0;
        m_Engine.m_byTurnColor = (byte) m_Engine.m_nComStoneColor;
        m_Engine.m_nOldDeadCount = 0;
        if (SetStone2(m_Engine.m_byTurnColor) < 0) {
            LoadData();
            return 0;
        }
        if ((m_Engine.m_byNewLiberties & 0xff) < 2) {
            nPos = GetPosOnOneSEP();
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            LoadData();
            return nPos;
        }

        do {
            if ( (m_Engine.m_nSCount == 0) && (m_Engine.m_byNewLiberties == 2)) {
                nPos = GetPosOnManySEPs();
                break;
            }
            if ( (m_Engine.m_nSCount != 0) && ((m_Engine.m_byNewLiberties & 0xff) <= 3)) {
                for (i = 0; i < m_Engine.m_nSCount; i++)
                    if ( (m_Engine.m_wTempStatus[m_Engine.m_bySameBuf[i] & 0xff] & 0x8000) == 0)
                        break;
                if (i >= m_Engine.m_nSCount) {
                    nPos = GetPosOnManySEPs();
                    break;
                }
            }
            ResetTempArea();
            nPos = 0;
        } while (false);
        LoadData();
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        return nPos;
    }

    short GetPosOnManySEPs() {
        byte byStrNum = m_Engine.m_byNewStringNumber;
        short nSCount = m_Engine.m_nSCount;
        short nNewSEP = (short)(m_Engine.m_byNewLiberties & 0xff);
        byte cSecondSimul = SpecialSimulOnOutCall(byStrNum, m_Engine.m_nPos1);
        byte cFirstSimul;
        short nPos;

        m_Engine.m_nPos2 = m_Engine.m_nBoardPos;

        if (cSecondSimul != 0) {
            if (cSecondSimul < 0)
                return 0;
            byStrNum = cSecondSimul;
            KillString(byStrNum);
            m_Engine.m_nBoardPos = m_Engine.m_nPos2;
            m_Engine.m_byNewStringNumber = (byte) 0xff;
            m_Engine.m_nScoreBase = OldBoardScoreCalc();
            m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
            if (m_Engine.m_nScoreBase > 0)
                m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
            else
                m_Engine.m_nIniScore = m_Engine.m_nScoreBase;
            if (m_Engine.m_nIniScore <= 0)
                return m_Engine.m_nPos2;
        }
        KillString(byStrNum);
        m_Engine.m_nBoardPos = m_Engine.m_nPos2;
        m_Engine.m_byNewStringNumber = (byte) 0xff;
        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        if (m_Engine.m_nScoreBase > 0)
            m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
        else
            m_Engine.m_nIniScore = m_Engine.m_nScoreBase;
        if (m_Engine.m_nIniScore > 0)
            if (GetScoreOfLying() > 0)
                return 0;
        if ( (nSCount == 0) && (nNewSEP >= 3))
            return 0;
        cFirstSimul = SimulInFirstOnOutCall(byStrNum);
        m_Engine.m_nPos2 = m_Engine.m_nBoardPos;
        if (cFirstSimul > 0) {
            if (SetStone1(m_Engine.m_byTurnColor) == IS_OK)
                if (m_Engine.m_nSCount > 0)
                    return m_Engine.m_nPos2;
            return 0;
        }
        nPos = m_Engine.m_nBoardPos;
        nPos = AnotherInStrChain(nPos, m_Engine.m_byTurnColor);
        if (nPos != 0)
            nPos &= 0x7fff;
        return nPos;
    }

    void KillString(byte byStrNum) {
        short nSavePos = m_Engine.m_nBoardPos;

        byte byTable[] = new byte[80];
        short i, nCount = 0;
        //assert byStrNum >= 0;
        //byStrNum &= 0x7f;

        MEMSET(byTable, 0); //H.Joon

        m_Engine.m_wStatus[byStrNum & 0xff] = 0x01ff;
        for (m_Engine.m_nBoardPos = 21; m_Engine.m_nBoardPos < 400; m_Engine.m_nBoardPos++) {
            //HJ_Debug>>
            //System.out.println("KillString : m_nBoardPos = " + m_Engine.m_nBoardPos);
            //<<
            byte byDNum = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
            if ( (byDNum == 0) || (byDNum == byStrNum) ||
                    (IsSameString(byStrNum) == false) || (byDNum == (byte)0xf0)) // New addition-2007/04/18
                continue;

            for (i = 0; i < nCount; i++)
                if (byTable[i] == byDNum)
                    break;
            if (i < nCount)
                continue;
            byTable[nCount] = byDNum;
            //HJ_Debug>>
            //System.out.println("byDNum = " + byDNum);
            //<<
            if ( (m_Engine.m_wStatus[byDNum & 0xff] & 8) == 0)
                m_Engine.m_wStatus[byDNum & 0xff] = (short) 0xff01;
            nCount++;
        }

        m_Engine.m_nBoardPos = nSavePos;
    }

    byte SpecialSimulOnOutCall(byte byStr, short wPlayed) {
        byte cStatus = SimulInSecondOnOutCall(byStr);
        short wPos = m_Engine.m_nBoardPos;
        short wPoint1[] = new short[2], wPoint2[] = new short[2];
        byte cRelStatus;

        if (cStatus > 0)
            return 0;
        if (cStatus == 0)
            cStatus = -8; //E@\uFFFDE
        //m_pCurrUnit->byCandis == 0
        if ( (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] == 0) ||
                (m_Engine.m_byLiberties[byStr & 0xff] != 2) )
            return cStatus;

        SetPaePoint();
        GetLibs(byStr, m_Engine.m_wEmptyPoint);
        GetTwoPoints(m_Engine.m_wEmptyPoint[0], wPoint1, wPoint2, 0);
        GetTwoPoints(m_Engine.m_wEmptyPoint[1], wPoint1, wPoint2, 1);

        if ( (wPoint1[0] == 0) && (wPoint1[1] == 0)) {
            m_Engine.m_nBoardPos = wPos;
            return cStatus;
        }

        cRelStatus = -1;

        if (wPoint1[0] != 0) {
            m_Engine.m_wPoint1 = wPoint1[0];
            m_Engine.m_wPoint2 = wPoint2[0];
            cRelStatus = SimulOfOtherStrs();
            if ( (wPlayed != 0) && (m_Engine.m_byBoard[wPlayed] == 0)) {
                m_Engine.m_nBoardPos = wPlayed;
                SetStone2( (byte) ((m_Engine.m_byColor & 0xff) ^ 3));
            }
        }

        if ( (cRelStatus <= 0) && (wPoint1[1] == 0)) {
            m_Engine.m_nBoardPos = wPos;
            return cStatus;
        }

        if ( (cRelStatus <= 0) && (wPoint1[1] != 0)) {
            SetPaePoint();
            m_Engine.m_wPoint1 = wPoint1[1];
            m_Engine.m_wPoint2 = wPoint2[1];
            cRelStatus = SimulOfOtherStrs();

            if ( (wPlayed != 0) && (m_Engine.m_byBoard[wPlayed] == 0)) {
                m_Engine.m_nBoardPos = wPlayed;
                SetStone2( (byte) (m_Engine.m_byColor ^ 3));
            }
            if (cRelStatus <= 0) {
                m_Engine.m_nBoardPos = wPos;
                return cStatus;
            }
        }

        m_Engine.m_nBoardPos = m_Engine.m_wPoint1;
        return (byte) m_Engine.m_byStr1;
    }

    short GetLibs(short byStr, short[] wPoint) {
        short i, n = 0;
        short nLibs = (short) Math.min(m_Engine.m_byLiberties[byStr], MAX_LIBERTIES);

        for (i = STARTPOS; i < ENDPOS; i++) {
            if (m_Engine.m_byBoard[i] == 0) {
                if (IsSameStringg(i, (byte)byStr)) {
                    wPoint[n] = i;
                    n++;
                    if (n >= nLibs)
                        break;
                }
            }
        }
        return n;
    }

    boolean IsSameStringg(short nPos, byte byStr) {
        if (nPos < 20)
            return false;
        // assert nPos >= 20 : "nPos less than 20"; // by kWJ : commented 2007-04-19
        // assert byStr >= 0 : "bystr is negative"; // by KWJ : commented 2007-04-19
        try {
            if ( (m_Engine.m_byBoard[nPos - 20] == byStr) ||
                    (m_Engine.m_byBoard[nPos + 20] == byStr) ||
                    (m_Engine.m_byBoard[nPos - 1] == byStr) ||
                    (m_Engine.m_byBoard[nPos + 1] == byStr) )
                return true;
        } catch (Exception e) {
            //System.out.println("IsSameStringg");
        }
        return false;
    }

    void SetPaePoint() {
        if (m_Engine.m_byColor != m_Engine.m_nComStoneColor) {
            m_Engine.m_nPaePos = 0;
            m_Engine.m_wBackPaePos = 0;
        } else {
            m_Engine.m_nPaePos = m_Engine.m_nTempPaePos;
            m_Engine.m_wBackPaePos = m_Engine.m_nTempPaePos;
        }
    }

    byte SimulInSecondOnOutCall(byte byStr) {
        short nLibs;
        byte cStatus;

        m_Engine.m_nBoardPos = 0;
        m_Engine.m_byStrNum = (short)(byStr & 0xff);
        m_Engine.m_byColor = ( (m_Engine.m_byStrNum & 1) != 0) ? IS_BLACK : IS_WHITE;

        nLibs = (short) (m_Engine.m_byLiberties[byStr & 0xFF] & 0xFF);
        if (nLibs < 1)
            return 1;
        if (nLibs > 4)
            return -1;

        PrepareOnOutCall();

        if (nLibs == 1)
            cStatus = SimulInSecondOfOSStr();
        else
            cStatus = SimulInSecondOfMSStr();

        RestorStrDatas(CHILD_BACKUP);

        if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] > 0) {

            m_Engine.m_nBoardPos =
                    (short) (((m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT + 1] & 0xffff) << 8) +
                            (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT] & 0xff));
        } else
            m_Engine.m_nBoardPos = 0;
        return cStatus;
    }

    byte SimulOfOtherStrs() {
        short wPaePos = m_Engine.m_nPaePos;
        byte byStr;
        int i, n;

        m_Engine.m_nBoardPos = m_Engine.m_wPoint1;
        SetTestStone(m_Engine.m_byColor);
        m_Engine.m_nPaePos = wPaePos;

        n = m_Engine.m_nDCount;

        for (i = m_Engine.m_nDCount - 1; i >= 0; i--) {
            byStr = m_Engine.m_byDifferBuf[i];
            if (((byStr & 0xff) != m_Engine.m_byStrNum) &&
                    ((m_Engine.m_byDifferLiberties[i] & 0xff) > 0) &&
                    ((m_Engine.m_byDifferLiberties[i] & 0xff) <= 3)) {
                if ( (m_Engine.m_nOutCall == 0) ||
                        ( (m_Engine.m_wStatus[byStr & 0xff] & 0xff00) == 0) ||
                        ( (m_Engine.m_wStatus[byStr & 0xff] & 0x0800) != 0)) {
                    if (IsSameStringg(m_Engine.m_wPoint2, byStr) == false)
                        continue;
                }
            }
            if (i < n - 1) {
                m_Engine.m_byDifferBuf[i] = m_Engine.m_byDifferBuf[n - 1];
                m_Engine.m_byDifferLiberties[i] = m_Engine.m_byDifferLiberties[n - 1];
            }
            n--;
        }

        if (n == 0)
            return -1;
        if (n > 1) {
            if ((m_Engine.m_byDifferLiberties[0] & 0xff) > (m_Engine.m_byDifferLiberties[1] & 0xff)) {
                byStr = m_Engine.m_byDifferBuf[1];
                m_Engine.m_byDifferBuf[1] = m_Engine.m_byDifferBuf[0];
                m_Engine.m_byDifferBuf[0] = byStr;
                i = m_Engine.m_byDifferLiberties[1] & 0xff;
                m_Engine.m_byDifferLiberties[1] = m_Engine.m_byDifferLiberties[0];
                m_Engine.m_byDifferLiberties[0] = (byte) i;
            }
        }
        m_Engine.m_byStr1 = m_Engine.m_byDifferBuf[0];
        m_Engine.m_byStr2 = m_Engine.m_byDifferBuf[n - 1];

        return PlayTwoStnsAndSimul();
    }

    byte PlayTwoStnsAndSimul() {
        short byStrNumStored;
        byte cRelStatus;
        short wSimulEnd;

        m_Engine.m_nBoardPos = m_Engine.m_wPoint1;
        m_Engine.m_byStoneColor = m_Engine.m_byColor;
        SetSimulStone();
        m_Engine.m_nBoardPos = m_Engine.m_wPoint2;
        m_Engine.m_byStoneColor = (byte) (m_Engine.m_byColor ^ 3);
        SetSimulStone();

        byStrNumStored = m_Engine.m_byStrNum;
        cRelStatus = -1;

        BackupStrDatas(CHILD_BACKUP);
        m_Engine.m_byStrNum = (short)(m_Engine.m_byStr1 & 0xff);

        while (true) {
            if ( ((m_Engine.m_byLiberties[m_Engine.m_byStrNum] & 0xff) > 0) &&
                    ((m_Engine.m_byLiberties[m_Engine.m_byStrNum] & 0xff) < 4)) {
                m_Engine.m_wCurrEnd = 0;
                PrepareSet( (byte) 0);

                if ((m_Engine.m_byLiberties[m_Engine.m_byStrNum] & 0xff) > 1)
                    cRelStatus = SimulInSecondOfMSStr();
                else
                    cRelStatus = SimulInSecondOfOSStr();
                m_Engine.m_cSimulStatus = cRelStatus;

                if ( (m_Engine.m_wPreSimulEnd != (short) 0xffff) && (m_Engine.m_nOutCall == 0)) {
                    wSimulEnd = m_Engine.m_wSimulEnd;
                    if (SaveSimulDatas() == 0)
                        m_Engine.m_wSimulEnd = m_Engine.m_wPreSimulEnd;
                    else {
                        m_Engine.m_pSimulArea[wSimulEnd] = (short) (m_Engine.m_wSimulEnd & 0xff);
                        m_Engine.m_pSimulArea[wSimulEnd + 1] = (short) ( ((m_Engine.m_wSimulEnd & 0xFFFF) >> 8) & 0xff);
                    }
                }
                if (cRelStatus > 0)
                    break;
            }
            if (m_Engine.m_byStrNum == (m_Engine.m_byStr2 & 0xff))
                break;
            m_Engine.m_byStrNum = (short)(m_Engine.m_byStr2 & 0xff);
        }

        RestorStrDatas(PARENT_BACKUP);
        BackupStrDatas(CHILD_BACKUP);

        if (m_Engine.m_nOutCall == 1)
            MEMCPY(m_Engine.m_byLocalPattern, m_Engine.m_byTempLocalPattern, m_Engine.m_byLocalPattern.length);

        if ( (m_Engine.m_byStr1 != m_Engine.m_byStr2) &&
                (m_Engine.m_byStrNum == (m_Engine.m_byStr2 & 0xff))) {
            byte byStr = m_Engine.m_byStr2;
            m_Engine.m_byStr1 = m_Engine.m_byStr2;
            m_Engine.m_byStr1 = byStr;
        }
        m_Engine.m_byStrNum = byStrNumStored;
        return cRelStatus;
    }

    void SetSimulStone() {

        short wStatus[] = {m_Engine.m_byStoneColor};
        byte byAround = 0, byStr = 0, byTemp, byStringBuf[] = new byte[4];
        short nCount, i, i0, j, k;

        m_Engine.m_nSCount = 0;
        m_Engine.m_nDCount = 0;
        m_Engine.m_byNewLiberties = 0;
        m_Engine.m_byNewStringNumber = 0;
        try {

            m_Engine.m_nBoardPos -= 20;
            if (LookAbout(wStatus)) {
                byAround |= UP_MASK;
                m_Engine.m_byNewLiberties++;
            }

            m_Engine.m_nBoardPos += 40;
            if (LookAbout(wStatus)) {
                byAround |= DOWN_MASK;
                m_Engine.m_byNewLiberties++;
            }

            m_Engine.m_nBoardPos -= 21;
            if (LookAbout(wStatus)) {
                byAround |= LEFT_MASK;
                m_Engine.m_byNewLiberties++;
            }

            m_Engine.m_nBoardPos += 2;
            if (LookAbout(wStatus)) {
                byAround |= RIGHT_MASK;
                m_Engine.m_byNewLiberties++;
            }

            m_Engine.m_nBoardPos--;
            m_Engine.m_nDeadStoneCount = 0;
            i = m_Engine.m_nDCount;

            while (i > 0) {
                i--;
                byStr = m_Engine.m_byDifferBuf[i];
                nCount = (short)(m_Engine.m_byDifferLiberties[i] & 0xff);
                if (nCount != 0)
                    m_Engine.m_byLiberties[byStr & 0xFF] = (byte) nCount;
                else {
                    for (j = STARTPOS; j < ENDPOS; j++) {
                        if (m_Engine.m_byBoard[j] != byStr)
                            continue;

                        m_Engine.m_nPaePos = j;
                        m_Engine.m_byBoard[j] = 0;
                        m_Engine.m_nDeadStoneCount++;

                        for (i0 = 0, k = 0; k < 4; k++) {
                            byTemp = m_Engine.m_byBoard[j + m_Engine.nNeighbor[k]];
                            if ( (byTemp == INITVALUE) || (byTemp == 0) || (byTemp == byStr))
                                continue;

                            for (nCount = 0; nCount < i0; nCount++) {
                                if (byStringBuf[nCount] == byTemp)
                                    break;
                            }
                            if (nCount == i0) {
                                byStringBuf[i0] = byTemp;
                                i0++;
                                m_Engine.m_byLiberties[byTemp & 0xff]++;
                            }
                        }
                    }

                    m_Engine.m_nStoneCount[byStr & 0xff] = 0;
                    m_Engine.m_byLiberties[byStr & 0xff] = 0;
                    m_Engine.m_wStatus[byStr & 0xff] = (short) 0xff00;
                }
            }

            PLACEOK:
            do {

                if (m_Engine.m_nSCount == 0) {
                    if (m_Engine.m_nDeadStoneCount != 1)
                        m_Engine.m_nPaePos = 0;
                    NOTPLACE:
                    do {
                        if (m_Engine.m_byNewLiberties != 0) {
                            if (m_Engine.m_byNewLiberties != 1)
                                m_Engine.m_nPaePos = 0;
                            byStr = m_Engine.m_byStoneColor;

                            while (true) {
                                if ((byStr & 0xff) >= MAX_STRINGCOUNT)
                                    break NOTPLACE;
                                if (m_Engine.m_byLiberties[byStr & 0xff] == 0)
                                    break;
                                byStr += 2;
                            }
                            break PLACEOK;
                        }
                    } while (false); //            $NOTPLACE:
                    i = m_Engine.m_nDCount;
                    while (i > 0) {
                        i--;
                        m_Engine.m_byLiberties[m_Engine.m_byDifferBuf[i] & 0xff]++;
                    }
                    return;
                }

                m_Engine.m_nPaePos = 0;
                if (m_Engine.m_nSCount == 1) {
                    byStr = m_Engine.m_bySameBuf[0];
                    m_Engine.m_byNewLiberties += m_Engine.m_byLiberties[byStr & 0xFF] - 1;

                    if (m_Engine.m_byNewLiberties == 0) {
                        i = m_Engine.m_nDCount;
                        while (i > 0) {
                            i--;
                            m_Engine.m_byLiberties[m_Engine.m_byDifferBuf[i] & 0xFF]++;
                        }
                        return;
                    }

                    if ( (byAround & UP_MASK) != 0) {
                        if (IsSameStringg( (short) (m_Engine.m_nBoardPos - 20), byStr))
                            m_Engine.m_byNewLiberties--;
                    }
                    if ( (byAround & DOWN_MASK) != 0) {
                        if (IsSameStringg( (short) (m_Engine.m_nBoardPos + 20), byStr))
                            m_Engine.m_byNewLiberties--;
                    }
                    if ( (byAround & LEFT_MASK) != 0) {
                        if (IsSameStringg( (short) (m_Engine.m_nBoardPos - 1), byStr))
                            m_Engine.m_byNewLiberties--;
                    }
                    if ( (byAround & RIGHT_MASK) != 0) {
                        if (IsSameStringg( (short) (m_Engine.m_nBoardPos + 1), byStr))
                            m_Engine.m_byNewLiberties--;
                    }
                    break PLACEOK;
                }

                for (i = 0; i < m_Engine.m_nSCount; i++) {
                    m_Engine.m_byNewLiberties += m_Engine.m_bySameLiberties[i];
                    m_Engine.m_byNewLiberties--;
                }

                if (m_Engine.m_byNewLiberties == 0) {
                    i = m_Engine.m_nDCount;
                    while (i > 0) {
                        i--;
                        m_Engine.m_byLiberties[m_Engine.m_byDifferBuf[i] & 0xFF]++;
                    }
                    return;
                }

                byStr = m_Engine.m_bySameBuf[0];
                i = m_Engine.m_nSCount;
                while (i > 1) {
                    i--;
                    byTemp = m_Engine.m_bySameBuf[i];
                    for (i0 = STARTPOS; i0 < ENDPOS; i0++) {
                        if (m_Engine.m_byBoard[i0] == byTemp)
                            m_Engine.m_byBoard[i0] = (byte) byStr;
                    }
                    m_Engine.m_nStoneCount[byStr & 0xFF] += m_Engine.m_nStoneCount[byTemp & 0xFF];
                    m_Engine.m_nStoneCount[byTemp & 0xFF] = 0;
                    m_Engine.m_byLiberties[byTemp & 0xFF] = 0;
                    m_Engine.m_wStatus[byTemp & 0xFF] = (short) 0xff00;
                }

                m_Engine.m_byNewLiberties = 0;
                m_Engine.m_byBoard[m_Engine.m_nBoardPos] = (byte) byStr;
                for (i = STARTPOS; i < ENDPOS; i++) {
                    if ( (m_Engine.m_byBoard[i] == 0) && IsSameStringg(i, byStr))
                        m_Engine.m_byNewLiberties++;
                }
            } while (false); //        $PLACEOK:
            m_Engine.m_nStoneCount[byStr & 0xFF]++;
            //HJ_Debug>>
//            System.out.println("byStr = " + byStr);
//            System.out.println("m_nBoardPos = " + m_Engine.m_nBoardPos);
            //<<
            m_Engine.m_byLiberties[byStr & 0xFF] = m_Engine.m_byNewLiberties;
            m_Engine.m_byBoard[m_Engine.m_nBoardPos] = (byte) byStr;
            m_Engine.m_byNewStringNumber = (byte) byStr;
        } catch (Exception e) {
            //e.printStackTrace();
        }
    }

    short SaveSimulDatas() {
        short wNewEnd;
        short pSrc = 0;
        short pDst;
        if ( (MAXSIMULDATAS - 1 - (m_Engine.m_wSimulEnd & 0xFFFF) < sizeofWORD) ||
                ( (MAXSIMULDATAS - 1 - (m_Engine.m_wCurrEnd & 0xFFFF)) < (sizeofWORD + m_Engine.m_wSimulEnd))) {
            m_Engine.m_pSimulArea[m_Engine.m_wSimulEnd & 0xFFFF] = 0;
            m_Engine.m_pSimulArea[(m_Engine.m_wSimulEnd & 0xFFFF) + 1] = 0;
            return 0;
        }

        wNewEnd = (short)(m_Engine.m_wSimulEnd + m_Engine.m_wCurrEnd);
        m_Engine.m_wMoveDis = m_Engine.m_wSimulEnd;
        m_Engine.m_pSimulArea[wNewEnd & 0xFFFF] = 0;
        m_Engine.m_pSimulArea[(wNewEnd & 0xFFFF) + 1] = 0;

        pDst = m_Engine.m_wSimulEnd;
        if (m_Engine.m_wSimulEnd == m_Engine.m_wPreSimulEnd) {
            pDst += sizeofWORD;
            pSrc += sizeofWORD;
        }

        m_Engine.m_pSimulArea[pDst] = (short) (wNewEnd & 0xff);
        m_Engine.m_pSimulArea[pDst + 1] = (short) (((wNewEnd & 0xFFFF) >> 8) & 0xff);
        m_Engine.m_pSimulArea[pDst + 2] = m_Engine.m_pTempArea[pSrc + 2];
        m_Engine.m_pSimulArea[pDst + 3] = m_Engine.m_pTempArea[pSrc + 3];
        pDst += sizeofSIMULSET;
        pSrc += sizeofSIMULSET;

        MoveSimulDatas(pDst, pSrc);
        m_Engine.m_wSimulEnd = wNewEnd;
        return 1;
    }

    void MoveSimulDatas(int pDst, int pSrc) {
        short nCandis, nUnits;
        short wParent;
        short wChildUnit;
        short wSrcChildUnit;
        try {
            //MEMCPY(&m_Engine.m_pSimulArea[pDst], &m_Engine.m_pTempArea[pSrc], sizeofSIMULUNIT);
            System.arraycopy(m_Engine.m_pTempArea, pSrc, m_Engine.m_pSimulArea, pDst, sizeofSIMULUNIT);

            wParent = (short) (((m_Engine.m_pSimulArea[pDst + 1] & 0xffff) << 8) |
                    (m_Engine.m_pSimulArea[pDst] & 0xff));
            if (wParent != 0) {
                wParent += m_Engine.m_wMoveDis;
                m_Engine.m_pSimulArea[pDst] = (short) (wParent & 0xff);
                m_Engine.m_pSimulArea[pDst + 1] = (short) ( (wParent >> 8) & 0xff);
            }

            nCandis = m_Engine.m_pSimulArea[pDst + 3];
            nUnits = m_Engine.m_pSimulArea[pDst + 4];
            pDst += sizeofSIMULUNIT;
            pSrc += sizeofSIMULUNIT;

            if (nCandis == 0)
                return;
            if (nUnits != 0)

                while (nCandis > 0) {
                    //MEMCPY(&m_Engine.m_pSimulArea[pDst], &m_Engine.m_pTempArea[pSrc], sizeof(SIMULPOINT));
                    System.arraycopy(m_Engine.m_pTempArea, pSrc, m_Engine.m_pSimulArea, pDst,
                            sizeofSIMULPOINT);
                    wChildUnit = (short) (((m_Engine.m_pSimulArea[pDst + 3] & 0xffff) << 8) |
                            (m_Engine.m_pSimulArea[pDst + 2] & 0xff));
                    if (wChildUnit == 0) {
                        pDst += sizeofSIMULUNIT;
                        pSrc += sizeofSIMULUNIT;
                        nCandis--;
                        break;
                    }

                    wChildUnit += m_Engine.m_wMoveDis;
                    m_Engine.m_pSimulArea[pDst + 2] = (short) (wChildUnit & 0xff);
                    m_Engine.m_pSimulArea[pDst + 3] = (short) (((wChildUnit & 0xFFFF) >> 8) & 0xff);
                    wSrcChildUnit = (short) (((m_Engine.m_pTempArea[pSrc + 3] & 0xffff) << 8) |
                            (m_Engine.m_pTempArea[pSrc + 2] & 0xff));
                    MoveSimulDatas(wChildUnit, wSrcChildUnit);
                    nCandis--;
                    nUnits--;
                    pDst += sizeofSIMULPOINT;
                    pSrc += sizeofSIMULPOINT;
                    if (nUnits == 0)
                        break;
                }

            while (nCandis > 0) {
                //MEMCPY(&m_Engine.m_pSimulArea[pDst], &m_Engine.m_pTempArea[pSrc], sizeof(SIMULPOINT));
                System.arraycopy(m_Engine.m_pTempArea, pSrc, m_Engine.m_pSimulArea, pDst, sizeofSIMULPOINT);
                pDst += sizeofSIMULPOINT;
                pSrc += sizeofSIMULPOINT;
                nCandis--;
            }
        } catch (Exception e) {
            //System.out.println("Exception occur at MoveSimulDatas");
        }
    }

    void PrepareSet(byte pbyTemp) {
        m_Engine.m_pTempArea[pbyTemp] = 0;
        m_Engine.m_pTempArea[pbyTemp + 1] = 0;
        m_Engine.m_pTempArea[pbyTemp + 2] = m_Engine.m_byStrNum;
        m_Engine.m_pTempArea[pbyTemp + 3] = (short) (m_Engine.m_byColor & 0xff);
        m_Engine.m_wCurrEnd += sizeofSIMULSET;

        m_Engine.m_nCurrUnit = (pbyTemp + sizeofSIMULSET);
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 1] = 0;

        m_Engine.m_wAssignLimit = (short) (m_Engine.m_wCurrEnd + m_Engine.m_wMemOfSet);
        m_Engine.m_wCurrLimit = m_Engine.m_wAssignLimit;

        m_Engine.m_nDepth = 0;
        InitGoodTimes();
    }

    void InitGoodTimes() {
        if (m_Engine.m_nDepth >= 4)
            return;
        //MEMSET(m_Engine.m_cGoodTimes, 4, 400);
        for (int i = 0; i < 400; i++)
            m_Engine.m_cGoodTimes[i] = 4;
    }

    void BackupStrDatas(short nPlace) {
        if (nPlace == PARENT_BACKUP) {
            m_Engine.m_nTempPaePos = m_Engine.m_nPaePos;
            m_Engine.m_nTempDeadStoneCount = m_Engine.m_nDeadStoneCount;
            MEMCPY(m_Engine.m_byTempBoard, m_Engine.m_byBoard, m_Engine.m_byBoard.length);
            MEMCPY(m_Engine.m_byTempLiberties, m_Engine.m_byLiberties, m_Engine.m_byLiberties.length);
            MEMCPY(m_Engine.m_nTempStoneCount, m_Engine.m_nStoneCount, m_Engine.m_nStoneCount.length);
            MEMCPY(m_Engine.m_wTempStatus, m_Engine.m_wStatus, m_Engine.m_wStatus.length);
        } else {
            m_Engine.m_wBackPaePos = m_Engine.m_nPaePos;
            m_Engine.m_nBackDeadStoneCount = m_Engine.m_nDeadStoneCount;
            MEMCPY(m_Engine.m_byBackBoard, m_Engine.m_byBoard, m_Engine.m_byBoard.length);
            MEMCPY(m_Engine.m_byBackLibs, m_Engine.m_byLiberties, m_Engine.m_byLiberties.length);
            MEMCPY(m_Engine.m_nBackStns, m_Engine.m_nStoneCount, m_Engine.m_nStoneCount.length);
            MEMCPY(m_Engine.m_wBackStatus, m_Engine.m_wStatus, m_Engine.m_wStatus.length);
        }
    }

    byte SimulInSecondOfOSStr() {
        byte cStatus;
        short wTemp;
        int pnUnit;
        int pnPoint;
        short byStrNumStored;

        cStatus = TestSEP();

        m_Engine.m_nCurrUnit = m_Engine.m_wCurrEnd;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = (short) (cStatus & 0xff);
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = 1;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] = 0;

        pnPoint = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        m_Engine.m_pTempArea[pnPoint] = (short) (m_Engine.m_wEmptyPoint[0] & 0xff);
        m_Engine.m_pTempArea[pnPoint + 1] = (short) (((m_Engine.m_wEmptyPoint[0] & 0xffff) >> 8));
        m_Engine.m_pTempArea[pnPoint + 2] = 0;
        m_Engine.m_pTempArea[pnPoint + 3] = 0;
        wTemp = m_Engine.m_wCurrEnd;
        m_Engine.m_wCurrEnd += sizeofSIMULUNIT + sizeofSIMULPOINT;

        if (cStatus != 0) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
            m_Engine.m_pTempArea[pnPoint + 2] = (short) (m_Engine.m_wCurrEnd & 0xff);
            m_Engine.m_pTempArea[pnPoint + 3] = (short) (((m_Engine.m_wCurrEnd & 0xffff) >> 8) & 0xff);

            pnUnit = m_Engine.m_wCurrEnd;
            m_Engine.m_pTempArea[pnUnit] = (short) (wTemp & 0xff);
            m_Engine.m_pTempArea[pnUnit + 1] = (short) ( ((wTemp & 0xffff) >> 8) & 0xff);
            m_Engine.m_pTempArea[pnUnit + 2] = (short) (cStatus & 0xff);
            m_Engine.m_pTempArea[pnUnit + 3] = 0;
            m_Engine.m_pTempArea[pnUnit + 4] = 0;
            m_Engine.m_wCurrEnd += sizeofSIMULUNIT;
            return cStatus;
        }

        m_Engine.m_pTempArea[pnPoint + 2] = (short) (m_Engine.m_wCurrEnd & 0xff);
        m_Engine.m_pTempArea[pnPoint + 3] = (short) (((m_Engine.m_wCurrEnd & 0xffff) >> 8) & 0xff);
        pnUnit = m_Engine.m_nCurrUnit;
        m_Engine.m_nCurrUnit = m_Engine.m_wCurrEnd;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit] = (short) (wTemp & 0xff);
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 1] = (short) ( ((wTemp & 0xffff) >> 8) & 0xff);
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = 1;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] = 0;

        m_Engine.m_nBoardPos = m_Engine.m_wEmptyPoint[0];
        m_Engine.m_byStoneColor = m_Engine.m_byColor;
        SetSimulStone();
        GetLibs(m_Engine.m_byNewStringNumber, m_Engine.m_wEmptyPoint);

        pnPoint = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        m_Engine.m_pTempArea[pnPoint] = (short) (m_Engine.m_wEmptyPoint[0] & 0xff);
        m_Engine.m_pTempArea[pnPoint + 1] = (short) ( ((m_Engine.m_wEmptyPoint[0] & 0xffff) >> 8) & 0xff);
        wTemp = m_Engine.m_wCurrEnd;
        m_Engine.m_wCurrEnd += sizeofSIMULUNIT + sizeofSIMULPOINT;
        m_Engine.m_pTempArea[pnPoint + 2] = (short) (m_Engine.m_wCurrEnd & 0xff);
        m_Engine.m_pTempArea[pnPoint + 3] = (short) ( ((m_Engine.m_wCurrEnd & 0xFFFF) >> 8) & 0xff);

        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd] = (short) (wTemp & 0xff);
        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 1] = (short) ( ((wTemp & 0xffff) >> 8) & 0xff);
        m_Engine.m_nBoardPos = m_Engine.m_wEmptyPoint[0];
        m_Engine.m_byColor ^= 3;
        m_Engine.m_byStoneColor = m_Engine.m_byColor;
        SetSimulStone();

        byStrNumStored = m_Engine.m_byStrNum;
        m_Engine.m_byStrNum = (short)(m_Engine.m_byNewStringNumber & 0xff);
        cStatus = CallReflexRoutine(SIMUL_INSECOND_MANYSEP);
        if (cStatus != -8)
            cStatus = (byte) - cStatus;
        m_Engine.m_byStrNum = byStrNumStored;

        RestorStrDatas(PARENT_BACKUP);
        m_Engine.m_nCurrUnit = pnUnit;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = (short) (cStatus & 0xff);
        return cStatus;
    }

    byte CallReflexRoutine(short nRoutine) {
        byte cStatus = 0;

        m_Engine.m_byColor ^= 3;
        m_Engine.m_nDepth += 1;
        switch (nRoutine) {
            case SIMUL_INSECOND_MANYSEP:
                cStatus = SimulInSecondOfMSStr();
                break;
            case SIMUL_INFIRST_ONESEP:
                cStatus = SimulInFirstOfOSStr_Reflex();
                break;
            case SIMUL_INFIRST_MANYSEP:
                cStatus = SimulInFirstOfMSStr();
        }

        if (cStatus != -8)
            cStatus = (byte) - cStatus;
        m_Engine.m_byColor ^= 3;
        m_Engine.m_nDepth -= 1;
        return cStatus;
    }

    byte SimulInFirstOfMSStr() {
//	ExecuteCommand();

        short wCurrLimitStored = m_Engine.m_wCurrLimit;
        int pnCurrUnitStored = m_Engine.m_nCurrUnit;
        short wStatusStored;
        short wPoint;
        short nLibs;
        short nTemp;
        byte byPos[] = new byte[3];
        byte[] pbyte = byPos;
        byte cStatus;
        int pnSimulPt;

        m_Engine.m_wCurrLimit = m_Engine.m_wAssignLimit;
        m_Engine.m_nCurrUnit = m_Engine.m_wCurrEnd;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] = 0;
        m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

        m_Engine.m_nScoredPoints = 0;
        wStatusStored = m_Engine.m_wTempStatus[m_Engine.m_byStrNum & 0xff];
        m_Engine.m_wStatus[m_Engine.m_byStrNum & 0xff] = (short) 0xff01;
        m_Engine.m_wTempStatus[m_Engine.m_byStrNum & 0xff] = (short) 0xff01;

        nLibs = GetLibs(m_Engine.m_byStrNum, m_Engine.m_wEmptyPoint);
        if (nLibs > 3)
            nLibs = 3;

        for (nTemp = 0; nTemp < nLibs; nTemp++) {
            pbyte[nTemp] = 0;
            wPoint = m_Engine.m_wEmptyPoint[nTemp];
            if ((m_Engine.m_byBoard[wPoint - 1] & 0xff) == m_Engine.m_byStrNum)
                (pbyte[nTemp]) |= 0x10;
            if ((m_Engine.m_byBoard[wPoint - 20] & 0xff) == m_Engine.m_byStrNum)
                (pbyte[nTemp]) |= 0x20;
            if ((m_Engine.m_byBoard[wPoint + 1] & 0xff) == m_Engine.m_byStrNum)
                (pbyte[nTemp]) |= 0x40;
            if ((m_Engine.m_byBoard[wPoint + 20] & 0xff) == m_Engine.m_byStrNum)
                (pbyte[nTemp]) |= 0x80;
        }

        if (nLibs == 2) {
            if (0 == TwoSEPsInFirst(m_Engine.m_wEmptyPoint[0], byPos[0], m_Engine.m_wEmptyPoint[1], byPos[1])) {
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[0], byPos[0]);
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[1], byPos[1]);
            }
        } else {
            byte byFailedPairs = 0;
            if (0 == TwoSEPsInFirst(m_Engine.m_wEmptyPoint[0], byPos[0], m_Engine.m_wEmptyPoint[1], byPos[1]))
                byFailedPairs |= 1;
            if (0 == TwoSEPsInFirst(m_Engine.m_wEmptyPoint[0], byPos[0], m_Engine.m_wEmptyPoint[2], byPos[2]))
                byFailedPairs |= 2;
            if ( (byFailedPairs != 0) &&
                    (0 == TwoSEPsInFirst(m_Engine.m_wEmptyPoint[1], byPos[1], m_Engine.m_wEmptyPoint[2], byPos[2])))
                byFailedPairs |= 4;

            if (byFailedPairs == 7) {
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[0], byPos[0]);
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[1], byPos[1]);
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[2], byPos[2]);
            }
            if (byFailedPairs == 3)
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[0], byPos[0]);
            if (byFailedPairs == 5)
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[1], byPos[1]);
            if (byFailedPairs == 6)
                OneSEPPlusNeighbors(m_Engine.m_wEmptyPoint[2], byPos[2]);
        }

//	if (m_nDepth <= 1) RegRestSEPsInFirst();

        GetPeriStrs(m_Engine.m_byStrNum, (byte) 3);
        RegPtsOnMSPeris( (byte) - 1);
        if (m_Engine.m_nOneLibStrs > 0)
            RegPtsOnOSPerisInFirst();

        FixupCandis();

        m_Engine.m_wStatus[m_Engine.m_byStrNum & 0xff] = wStatusStored;
        m_Engine.m_wTempStatus[m_Engine.m_byStrNum & 0xff] = wStatusStored;

        if (m_Engine.m_nDepth > 0) {
            m_Engine.m_pTempArea[m_Engine.m_wCurrEnd] = 0;
            m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 1] = 0;
            m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 2] = 0;
            m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 3] = 0;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]++;
            m_Engine.m_wCurrEnd += sizeofSIMULPOINT;
        }

        nLibs = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3];
        if (nLibs == 0) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -1;
            m_Engine.m_wCurrLimit = wCurrLimitStored;
            m_Engine.m_nCurrUnit = pnCurrUnitStored;
            return -1;
        }
        if (nLibs > m_Engine.m_nMaxSimulPoints) {
            nLibs = m_Engine.m_nMaxSimulPoints;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = nLibs;
            m_Engine.m_wCurrEnd = (short) (m_Engine.m_nCurrUnit + sizeofSIMULUNIT + nLibs * sizeofSIMULPOINT);
        }

        if (IsStopOfSimul(nLibs)) {
            m_Engine.m_wCurrLimit = wCurrLimitStored;
            m_Engine.m_nCurrUnit = pnCurrUnitStored;
            return -8;
        }

        nTemp = m_Engine.m_nLibsLimit;
        pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;

        while (true) {
            cStatus = PlayStnAndSimulInSecond(pnSimulPt);
            m_Engine.m_nLibsLimit = nTemp;
            nLibs--;
            pnSimulPt += sizeofSIMULPOINT;
            if ( (cStatus == 1) || (nLibs <= 0) || (AssignMemory(nLibs) == 0))
                break;
        }
        cStatus = GetUnitStatus();

        m_Engine.m_wCurrLimit = wCurrLimitStored;
        m_Engine.m_nCurrUnit = pnCurrUnitStored;
        return cStatus;
    }

    void RegPtsOnOSPerisInFirst() {
        byte byStr, byOtherStr;
        int i, j;
        short wEmptyPt[] = {0};

        for (i = m_Engine.m_nOneLibStrs - 1; i >= 0; i--) {
            byStr = m_Engine.m_byPeriStr[i];
            GetLibs(byStr, wEmptyPt);

            if (m_Engine.m_nStoneCount[byStr & 0xff] == 1) {
                if (wEmptyPt[0] == (short) m_Engine.m_nPaePos)
                    j = 4;
                else { // nIsPae = InvokePae(byStr, wEmptyPt);
                    for (j = 0; j < 4; j++) {
                        byOtherStr = m_Engine.m_byBoard[(wEmptyPt[0] & 0xffff) + m_Engine.nNeighbor[j]];
                        if (byOtherStr != INITVALUE) {
                            if ( (byOtherStr == 0) ||
                                    ( (byOtherStr != byStr) && (m_Engine.m_byLiberties[byOtherStr & 0xff] == 1)) ||
                                    ( ( (byOtherStr ^ byStr) & 1) != 0))
                                break;
                        }
                    }
                }
                if (j >= 4) {
                    RegInLastPlace(wEmptyPt[0]);
                    continue;
                }
            }

            if ( (m_Engine.m_byLiberties[m_Engine.m_byStrNum & 0xff] == 1) || (m_Engine.m_nDepth >= 1))
                RegInFirstPlace(wEmptyPt[0]);
            else
                RegInSomePlace(wEmptyPt[0]);
        }
    }

    void RegInFirstPlace(short wPoint) {
        short nPlace = IsInUnit(wPoint);
        int pnFirstPoint;
        int pnTempUnit;
        short wChildUnit;

        pnFirstPoint = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        if (nPlace == 0)
            return;
        if (nPlace < 0) {
            if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] == 0)
                AddSimulPoint(wPoint);
            else {
                RightShiftSimulPoints(pnFirstPoint,
                        (pnFirstPoint +
                                (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] - 1) *
                                        sizeofSIMULPOINT));

                m_Engine.m_pTempArea[pnFirstPoint] = (short) (wPoint & 0xff);
                m_Engine.m_pTempArea[pnFirstPoint + 1] = (short)(((wPoint & 0xffff) >> 8));
                m_Engine.m_pTempArea[pnFirstPoint + 2] = 0;
                m_Engine.m_pTempArea[pnFirstPoint + 3] = 0;
                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]++;
                m_Engine.m_wCurrEnd += sizeofSIMULPOINT;
            }
        } else {
            wChildUnit = (short) (((m_Engine.m_pTempArea[pnFirstPoint + nPlace*sizeofSIMULPOINT + 3] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnFirstPoint + nPlace*sizeofSIMULPOINT + 2] & 0xff));
            pnTempUnit = m_Engine.m_pTempArea[wChildUnit];
            RightShiftSimulPoints(pnFirstPoint, pnFirstPoint + (nPlace - 1) * sizeofSIMULPOINT);
            m_Engine.m_pTempArea[pnFirstPoint] = (short) (wPoint & 0xff);
            m_Engine.m_pTempArea[pnFirstPoint + 1] = (short) ( ((wPoint & 0xffff) >> 8) & 0xff);
            m_Engine.m_pTempArea[pnFirstPoint + 2] = (short) (pnTempUnit & 0xff);
            m_Engine.m_pTempArea[pnFirstPoint + 3] = (short) ( (pnTempUnit >> 8) & 0xff);
        }
    }

    short IsInUnit(short wPoint) {
        short n, nCandis = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3];
        int pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        for (n = 0; n < nCandis; n++) {
            short wTempPoint;
            wTempPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
            if (wTempPoint == wPoint)
                break;
            pnSimulPt += sizeofSIMULPOINT;
        }
        if (n >= nCandis)
            return -1;
        return n;
    }

    void AddSimulPoint(short wPoint) {
        int pnSimulPt = m_Engine.m_wCurrEnd;
        m_Engine.m_pTempArea[pnSimulPt] = (short) (wPoint & 0xff);
        m_Engine.m_pTempArea[pnSimulPt + 1] = (short) (((wPoint & 0xffff) >> 8));
        m_Engine.m_pTempArea[pnSimulPt + 2] = 0;
        m_Engine.m_pTempArea[pnSimulPt + 3] = 0;

        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]++;
        m_Engine.m_wCurrEnd += sizeofSIMULPOINT;
    }

    void RightShiftSimulPoints(int pnFirst, int pnLast) {
        int pnSimulPt = pnLast;
        try {
            while (pnSimulPt != (pnFirst - sizeofSIMULPOINT)) {
                m_Engine.m_pTempArea[pnSimulPt + sizeofSIMULPOINT] = m_Engine.m_pTempArea[pnSimulPt];
                m_Engine.m_pTempArea[pnSimulPt + sizeofSIMULPOINT + 1] = m_Engine.m_pTempArea[pnSimulPt + 1];
                m_Engine.m_pTempArea[pnSimulPt + sizeofSIMULPOINT + 2] = m_Engine.m_pTempArea[pnSimulPt + 2];
                m_Engine.m_pTempArea[pnSimulPt + sizeofSIMULPOINT + 3] = m_Engine.m_pTempArea[pnSimulPt + 3];
                pnSimulPt -= sizeofSIMULPOINT;
                if (pnSimulPt < 0)
                    break;
            }
        } catch (Exception e) {
            //System.out.println("RightShiftSimulPoints");
        }
    }

    void RegInSomePlace(short wPoint) {
        short nPlace;
        int pnFirstPoint;
        short nScore;
        short wCurrEndStored;

        if (m_Engine.m_nScoredPoints >= MAX_SCOREDPOINTS)
            return;
        nPlace = IsInUnit(wPoint);
        pnFirstPoint = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;

        if ( (nPlace >= 0) && (nPlace <= m_Engine.m_nScoredPoints - 1))
            return;
        nScore = GetScoreByNeighbors(wPoint);
        if (nScore <= 0)
            return;

        if (nPlace >= 0) {
            if (nPlace > m_Engine.m_nScoredPoints)
                RightShiftSimulPoints(pnFirstPoint + m_Engine.m_nScoredPoints * sizeofSIMULPOINT,
                        pnFirstPoint + (nPlace - 1) * sizeofSIMULPOINT);
        } else {
            if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] > m_Engine.m_nScoredPoints)
                RightShiftSimulPoints(pnFirstPoint + m_Engine.m_nScoredPoints * sizeofSIMULPOINT,
                        pnFirstPoint +
                                (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] - 1) * sizeofSIMULPOINT);
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]++;
            m_Engine.m_wCurrEnd += sizeofSIMULPOINT;
        }

        wCurrEndStored = m_Engine.m_wCurrEnd;
        m_Engine.m_wCurrEnd = (short) (pnFirstPoint + m_Engine.m_nScoredPoints*sizeofSIMULPOINT);
        RegByScore(wPoint, nScore);
        m_Engine.m_wCurrEnd = wCurrEndStored;
    }

    short GetScoreByNeighbors(short wPoint) {
        short nResult[] = new short[2], nScore = 0, nKilledStns = 0;
        short i, nIs = 0;
        byte byNeighborStr;
        short n;

        for (i = 0; i < 4; i++) {
            byNeighborStr = m_Engine.m_byBoard[(wPoint & 0xffff) + m_Engine.nNeighbor[i]];
            if (byNeighborStr == INITVALUE)
                continue;
            if ((byNeighborStr & 0xff) == m_Engine.m_byStrNum)
                nIs = 1;
            else {
//			ScoreInOneNeighbor(byNeighborStr, (NPWORD) nResult);
                if (byNeighborStr == 0) {
                    nResult[0] = 4;
                    nResult[1] = 0;
                } else if (((byNeighborStr ^ m_Engine.m_byStrNum) & 1) == 0) {
                    nResult[0] = (short) (((m_Engine.m_byLiberties[byNeighborStr & 0xff] & 0xff) - 1) * 4 + 2);
                    nResult[1] = 0;
                } else {
                    if ((m_Engine.m_byLiberties[byNeighborStr & 0xff] & 0xff) >= 2) {
                        nResult[0] = 0;
                        nResult[1] = 0;
                    } else {
                        nResult[0] = (short) ((m_Engine.m_nStoneCount[byNeighborStr & 0xff] - 1) * 4 + 7);
                        nResult[1] = m_Engine.m_nStoneCount[byNeighborStr & 0xff];
                    }
                }
                nScore += nResult[0];
                nKilledStns += nResult[1];
            }
        }
        if (nScore == 0)
            return 0;

        if (nIs == 0)
            nScore = (short) ( (nScore - 2) / 2);
        if (nKilledStns > 0)
            nIs = 12;
        else {
            n = (short) (m_Engine.m_byPosBoard[wPoint & 0xFFFF] & 0xFF);
            if (n < 3)
                nIs = (short) (n - 1);
            else if (n == 3)
                nIs = 8;
            else
                nIs = 12;
        }
        return (short) (nScore + nIs);
    }

    void RegByScore(short wPoint, short nScore) {
        int pnSimulPt = m_Engine.m_wCurrEnd;
        short nPlace = (short) (m_Engine.m_nScoredPoints - 1);
        try {
            while (nPlace >= 0) {
                if (m_Engine.m_nScore[nPlace] >= nScore)
                    break;
//                if (pnSimulPt < sizeofSIMULPOINT)
//                    break; //critical code by lci
                // assert pnSimulPt >= sizeofSIMULPOINT; // by KWJ : 2007-04-19

                m_Engine.m_nScore[nPlace + 1] = m_Engine.m_nScore[nPlace];
                m_Engine.m_pTempArea[pnSimulPt] = m_Engine.m_pTempArea[pnSimulPt - sizeofSIMULPOINT];
                m_Engine.m_pTempArea[pnSimulPt + 1] = m_Engine.m_pTempArea[pnSimulPt - sizeofSIMULPOINT + 1];
                m_Engine.m_pTempArea[pnSimulPt + 2] = m_Engine.m_pTempArea[pnSimulPt - sizeofSIMULPOINT + 2];
                m_Engine.m_pTempArea[pnSimulPt + 3] = m_Engine.m_pTempArea[pnSimulPt - sizeofSIMULPOINT + 3];

                pnSimulPt -= sizeofSIMULPOINT;
                nPlace--;
            }
            m_Engine.m_pTempArea[pnSimulPt] = (short) (wPoint & 0xff);
            m_Engine.m_pTempArea[pnSimulPt + 1] = (short)(((wPoint & 0xffff) >> 8) & 0xff);
            m_Engine.m_pTempArea[pnSimulPt + 2] = 0;
            m_Engine.m_pTempArea[pnSimulPt + 3] = 0;
            m_Engine.m_nScore[nPlace + 1] = nScore;
            m_Engine.m_nScoredPoints++;
            m_Engine.m_wCurrEnd += sizeofSIMULPOINT;
        } catch (Exception e) {
            //System.out.println("Occur exception at RegByScore");
        }
    }

    void RegInLastPlace(short wPoint) {
        if (IsInUnit(wPoint) >= 0)
            return;
        AddSimulPoint(wPoint);
    }

    short GetPeriStrs(short byStr, short nMaxLibs) {
        byte byPeriStr, byStr1, byStr2;
        short nContact = 0;
        short nPeriStrs, nOneLibStrs;
        short i, k;
        short wPos1, wPos2;

        nPeriStrs = 0;
        nOneLibStrs = 0;

        for (i = STARTPOS; i < ENDPOS; i++) {
            if ( (byPeriStr = m_Engine.m_byBoard[i]) != 0) {
                if ((byPeriStr == INITVALUE) || ((byPeriStr & 0xff) == byStr) ||
                        ((m_Engine.m_byLiberties[byPeriStr & 0xff] & 0xff) > nMaxLibs) ||
                        (!IsSameStringg(i, (byte)byStr)))
                    continue;
                nContact = 1;
            } else {
                if (nMaxLibs == 1)
                    continue;
                for (k = 0; k < 2; k++) {
                    byStr1 = m_Engine.m_byBoard[i + m_Engine.nNeighbor[k]];
                    byStr2 = m_Engine.m_byBoard[i + m_Engine.nNeighbor[k + 2]];
                    if ( (byStr1 == INITVALUE) || (byStr1 == 0) ||
                            (byStr2 == INITVALUE) || (byStr2 == 0) ||
                            ( ( (byStr1 ^ byStr2) & 1) == 0))
                        continue;

                    if ((byStr1 & 0xff) == byStr)
                        byPeriStr = byStr2;
                    else if ((byStr2 & 0xff) == byStr)
                        byPeriStr = byStr1;
                    else
                        continue;

                    nContact = 0;
                    break;
                }
                if ( (k >= 2) || ((m_Engine.m_byLiberties[byPeriStr & 0xff] & 0xff) > nMaxLibs))
                    continue;
            }

            for (k = 0; k < nPeriStrs; k++) {
                if (m_Engine.m_byPeriStr[k] == byPeriStr)
                    break;
            }

            if (k < nPeriStrs) {
                if ( (nContact == 1) && (m_Engine.m_byLiberties[byPeriStr & 0xff] == 1))
                    m_Engine.m_byTemp1[k] += 1;
                continue;
            }

            if ((m_Engine.m_byLiberties[byPeriStr & 0xff] & 0xff) >= 2)
                m_Engine.m_byPeriStr[nPeriStrs++] = byPeriStr;
            else {
                m_Engine.m_byTemp1[nOneLibStrs] = (byte) nContact;
                if (nPeriStrs > nOneLibStrs)
                    m_Engine.m_byPeriStr[nPeriStrs] = m_Engine.m_byPeriStr[nOneLibStrs];
                m_Engine.m_byPeriStr[nOneLibStrs] = byPeriStr;
                nOneLibStrs++;
                nPeriStrs++;
            }
            if (nPeriStrs >= MAX_PERISTRS - 1)
                break;
        }

        if (nOneLibStrs > 1) {
            for (i = 0; i < nOneLibStrs - 1; i++) {
                k = i;
                wPos1 = m_Engine.m_byTemp1[i];
                for (wPos2 = (short) (i + 1); wPos2 < nOneLibStrs; wPos2++) {
                    if (m_Engine.m_byTemp1[wPos2 & 0xffff] > wPos1) {
                        k = wPos2;
                        wPos1 = m_Engine.m_byTemp1[wPos2 & 0xffff];
                    }
                }
                byStr1 = m_Engine.m_byPeriStr[k];
                m_Engine.m_byPeriStr[k] = m_Engine.m_byPeriStr[i];
                m_Engine.m_byPeriStr[i] = byStr1;

                m_Engine.m_byTemp1[k] = m_Engine.m_byTemp1[i];
                m_Engine.m_byTemp1[i] = (byte) wPos1;
            }
        }

        m_Engine.m_byPeriStr[nPeriStrs] = 0;
        m_Engine.m_nOneLibStrs = nOneLibStrs;
        return nPeriStrs;
    }

    void FixupCandis() {
        short nCount = (short) m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3];
        int pnSimulPt, pnTemp;
        short wPaePos, wPoint;
        short n;
        SIMULPOINT TempSimulPt = new SIMULPOINT();

        if (nCount == 0)
            return;

        if (m_Engine.m_nDepth > m_Engine.m_nDepthCrit)
            m_Engine.m_nLibsLimit = 3;
        else
            m_Engine.m_nLibsLimit = 4;

        pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        wPaePos = m_Engine.m_nPaePos;
        while (nCount > 0) {
            wPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
            if ( (wPoint == 0) || (wPoint == wPaePos)) {
                nCount--;
                pnSimulPt += sizeofSIMULPOINT;
                continue;
            }

            m_Engine.m_nBoardPos = wPoint;
            SetTestStone(m_Engine.m_byColor);
            m_Engine.m_nPaePos = wPaePos;

            if (m_Engine.m_byNewStringNumber == 0) {
                m_Engine.m_wCurrEnd -= sizeofSIMULPOINT;
                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]--;
                if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] == 0)
                    break;
            } else {

                if ((m_Engine.m_byNewStringNumber & 0xff) != m_Engine.m_byStrNum) {
                    nCount--;
                    pnSimulPt += sizeofSIMULPOINT;
                    continue;
                }

                if ((m_Engine.m_byNewLiberties & 0xff) >= 2) {
                    if ( (m_Engine.m_nDepth <= 1) || ((m_Engine.m_byNewLiberties & 0xff) < m_Engine.m_nLibsLimit)) {
                        nCount--;
                        pnSimulPt += sizeofSIMULPOINT;
                        continue;
                    }
                    //System.arraycopy(m_Engine.m_pTempArea, pnSimulPt, TempSimulPt, 0, sizeofSIMULPOINT);
                    TempSimulPt.getData(m_Engine.m_pTempArea, pnSimulPt);
                    pnTemp = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
                    System.arraycopy(m_Engine.m_pTempArea, pnTemp, m_Engine.m_pTempArea, pnSimulPt,
                            sizeofSIMULPOINT);
                    System.arraycopy(TempSimulPt.getShorts(), 0, m_Engine.m_pTempArea, pnTemp,
                            sizeofSIMULPOINT);
                    break;
                }

                m_Engine.m_wCurrEnd -= sizeofSIMULPOINT;
                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]--;
                if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] == 0)
                    break;
            }

            nCount--;
            n = nCount;
            pnTemp = pnSimulPt;
            while (n > 0) {
                m_Engine.m_pTempArea[pnTemp] = m_Engine.m_pTempArea[pnTemp + sizeofSIMULPOINT];
                m_Engine.m_pTempArea[pnTemp + 1] = m_Engine.m_pTempArea[pnTemp + sizeofSIMULPOINT + 1];
                m_Engine.m_pTempArea[pnTemp + 2] = m_Engine.m_pTempArea[pnTemp + sizeofSIMULPOINT + 2];
                m_Engine.m_pTempArea[pnTemp + 3] = m_Engine.m_pTempArea[pnTemp + sizeofSIMULPOINT + 3];
                n--;
                pnTemp += sizeofSIMULPOINT;
            }
        }
//	if (m_pCurrUnit->byCandis == 0) m_pCurrUnit->cStatus = -1;
    }


    byte GetUnitStatus() {
        int pnSimulPt;
        byte cStatus = 0;
        byte cStatus1;
        short n, m;
        short nUnits;
        SIMULPOINT TempSimulPt = new SIMULPOINT();
        short wChildUnit;

        if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] == 0) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -1;
            return -1;
        }
        try {
            pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
            wChildUnit = (short) (((m_Engine.m_pTempArea[pnSimulPt + 3] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt + 2] & 0xff));
            cStatus = (byte) m_Engine.m_pTempArea[wChildUnit + 2];
            //HJ_Debug>>
//            System.out.println("pnSimulPt = " + pnSimulPt);
//            System.out.println("m_nBoardPos = " + m_Engine.m_nBoardPos);
//            System.out.println("wChildUnit = " + wChildUnit);
//            System.out.println("cStatus = " + cStatus);
            //<<
            n = 1;
            m = 0;
            nUnits = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4];

            while (n < nUnits) {
                pnSimulPt += sizeofSIMULPOINT;
                wChildUnit = (short) (((m_Engine.m_pTempArea[pnSimulPt + 3] & 0xffff) << 8) |
                        (m_Engine.m_pTempArea[pnSimulPt + 2] & 0xff));
                cStatus1 = (byte) m_Engine.m_pTempArea[wChildUnit + 2];
                if (m_Engine.nStatusOrder[cStatus + 8] < m_Engine.nStatusOrder[cStatus1 + 8]) {
                    m = n;
                    cStatus = cStatus1;
                }
                n++;
            }

            pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT + m*sizeofSIMULPOINT;
            TempSimulPt.wPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
            TempSimulPt.wChildUnit = (short) ( ((m_Engine.m_pTempArea[pnSimulPt + 3] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt + 2] & 0xff));
            m_Engine.m_pTempArea[pnSimulPt] = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT];
            m_Engine.m_pTempArea[pnSimulPt + 1] = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit +
                    sizeofSIMULUNIT + 1];
            m_Engine.m_pTempArea[pnSimulPt + 2] = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit +
                    sizeofSIMULUNIT + 2];
            m_Engine.m_pTempArea[pnSimulPt + 3] = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit +
                    sizeofSIMULUNIT + 3];
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT] =
                    (short) (TempSimulPt.wPoint & 0xff);
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT + 1] =
                    (short) ((TempSimulPt.wPoint & 0xffff) >> 8);
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT + 2] =
                    (short) (TempSimulPt.wChildUnit & 0xff);
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT + 3] =
                    (short) ((TempSimulPt.wChildUnit & 0xffff) >> 8);

            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = (short) (cStatus & 0xff);
        } catch (Exception e) {
            //e.printStackTrace();
            //System.out.println("Exception : GetUnitStatus()");
        }
        return cStatus;
    }

    void RegPtsOnMSPeris(byte cCrit) {
        short wEmptyPt[] = new short[MAX_LIBERTIES];
        short nOneLibStrsStored = m_Engine.m_nOneLibStrs;
        short i = m_Engine.m_nOneLibStrs;
        short byStr = (short)(m_Engine.m_byPeriStr[i] & 0xff), byOtherStr = 0;

        byte byTest[] = new byte[2], byTemp;
        short n, i1, i2;
        short wPaePos, wPoint;
        int pnResult;
        int pnSet;

        try {

            wPaePos = m_Engine.m_nPaePos;
            out:
            while (byStr != 0) {
                WHILE_1:
                do {
                    if ((m_Engine.m_byLiberties[byStr] != 2) ||
                            (((m_Engine.m_wStatus[byStr] & 0x000c) != 0) &&
                                    (m_Engine.m_wSetInSecond[byStr] != (short) 0xffff)) ||
                            ((m_Engine.m_nDepth < 2) &&
                                    (m_Engine.m_wResultInSecond[byStr] != (short) 0xffff))) {
                        byStr = m_Engine.m_byPeriStr[++i];
                        continue out;
                    }
                    GetLibs(byStr, wEmptyPt);
                    if (cCrit >= 0) {
                        m_Engine.m_nPaePos = 0;
                        m_Engine.m_nBoardPos = wEmptyPt[0];
                        SetTestStone((byte) (m_Engine.m_byColor ^ 3));
                        if (m_Engine.m_byNewLiberties == 0) {
                            m_Engine.m_nPaePos = 0;
                            m_Engine.m_nBoardPos = wEmptyPt[1];
                            SetTestStone((byte) (m_Engine.m_byColor ^ 3));
                            if (m_Engine.m_byNewLiberties == 0)
                                break WHILE_1;
                        }
                    }

                    for (n = 0; n < 2; n++) {
                        wPoint = wEmptyPt[n];
                        byTest[n] = TestSEPOfPeri(wPoint);
                        if (byTest[n] != 0)
                            continue;
                        for (i1 = 0; i1 < 4; i1++) {
                            byOtherStr = m_Engine.m_byBoard[(wPoint & 0xffff) +
                                    m_Engine.nNeighbor[i1]];
                            if ((byOtherStr == (INITVALUE & 0xff)) || (byOtherStr == 0) ||
                                    (byOtherStr == byStr) ||
                                    (((byOtherStr ^ byStr) & 1) != 0))
                                continue;
                            i2 = 0;
                            while (m_Engine.m_byPeriStr[i2] != 0) {
                                if (byOtherStr == (m_Engine.m_byPeriStr[i2] & 0xff))
                                    break;
                                i2++;
                            }
                            if (m_Engine.m_byPeriStr[i2] != 0)
                                break;
                        }
                        if (i1 >= 4)
                            continue;

                        if (cCrit == 0)
                            RegInLastPlace(wPoint);
                        else if (cCrit > 0) {
                            if (m_Engine.m_byLiberties[byOtherStr] == 2)
                                RegInFirstPlace(wPoint);
                            else
                                RegInLastPlace(wPoint);
                        } else {
                            if (m_Engine.m_nDepth < 1)
                                RegInSomePlace(wPoint);
                            else {
                                if ((m_Engine.m_byLiberties[byOtherStr] == 2) ||
                                        (m_Engine.m_wStatus[byStr] != (short) 0xff01) ||
                                        (m_Engine.m_nStoneCount[byStr] != m_Engine.m_nTempStoneCount[byStr]) ||
                                        (m_Engine.m_byLiberties[byStr] != m_Engine.m_byTempLiberties[byStr]))
                                    RegInFirstPlace(wPoint);
                                else
                                    RegInLastPlace(wPoint);
                                m_Engine.m_wStatus[byStr] &= 0x00ff;
                                m_Engine.m_wStatus[byOtherStr] &= 0x00ff;
                            }
                        }

                        RegInLastPlace(wEmptyPt[1 - n]);
                        break WHILE_1;
                    }
                    if ((m_Engine.m_wTempStatus[byStr] == (short) 0xff01) &&
                            (m_Engine.m_byLiberties[byStr] == m_Engine.m_byTempLiberties[byStr]) &&
                            (m_Engine.m_nStoneCount[byStr] == m_Engine.m_nTempStoneCount[byStr])) {
                        for (n = STARTPOS; n < ENDPOS; n++) {
                            byTemp = m_Engine.m_byBoard[n];
                            if (byTemp != INITVALUE) {
                                if ((byTemp & 0xff)== byStr) {
                                    if ((m_Engine.m_byTempBoard[n] & 0xff) != byStr)
                                        break;
                                } else if ((m_Engine.m_byTempBoard[n] & 0xff) == byStr)
                                    break;
                            }
                        }
                        if (n >= ENDPOS)
                            break WHILE_1;
                    }
                    if ((byTest[0] == 0) && (byTest[1] == 0)) {
                        if (cCrit < 0) {
                            if (m_Engine.m_byPosBoard[wEmptyPt[1]] <
                                    m_Engine.m_byPosBoard[wEmptyPt[0]]) {
                                wPoint = wEmptyPt[0];
                                byTemp = byTest[0];
                                wEmptyPt[0] = wEmptyPt[1];
                                byTest[0] = byTest[1];
                                wEmptyPt[1] = wPoint;
                                byTest[1] = byTemp;
                            }
                            for (n = 0; n < 2; n++) {
                                if (m_Engine.m_nDepth == 0) {
                                    RegInSomePlace(wEmptyPt[n]);
                                    continue;
                                }
                                if (IsInUnit(wEmptyPt[n]) >= 0)
                                    continue;
                                RegInFirstPlace(wEmptyPt[n]);
                            }
                        } else {
                            if (m_Engine.m_byPosBoard[wEmptyPt[1] & 0xffff] >
                                    m_Engine.m_byPosBoard[wEmptyPt[0] & 0xffff]) {
                                wPoint = wEmptyPt[0];
                                wEmptyPt[0] = wEmptyPt[1];
                                wEmptyPt[1] = wPoint;
                            }
                            for (n = 0; n < 2; n++)
                                RegInLastPlace(wEmptyPt[n]);
                        }
                        break WHILE_1;
                    }

                    if ((byTest[0] != 0) && (byTest[1] != 0)) {
                        if ((cCrit >= 0) || (byTest[0] == byTest[1]))
                            break WHILE_1;
                        if (byTest[0] == 2) {
                            wPoint = wEmptyPt[0];
                            byTest[0] = 0;
                        } else {
                            wPoint = wEmptyPt[1];
                            byTest[1] = 0;
                        }

                        m_Engine.m_nPaePos = 0;
                        m_Engine.m_nBoardPos = wPoint;
                        SetTestStone(m_Engine.m_byColor);
                        if (m_Engine.m_nSCount > 0)
                            break WHILE_1;
                    }

                    if (byTest[0] == 0)
                        n = 1;
                    else
                        n = 0;

                    if ((byTest[n] == 2) ||
                            (m_Engine.m_nStoneCount[byStr] != 1) ||
                            (OppStrOrEmptyNearby((byte)byStr, wEmptyPt[n]) != 0)) {
                        if ((cCrit >= 0) || (m_Engine.m_nDepth >= 1))
                            RegInFirstPlace(wEmptyPt[n]);
                        else
                            RegInSomePlace(wEmptyPt[n]);
                    } else
                        RegInLastPlace(wEmptyPt[n]);
                } while (false); //   $WHILE_1:
                byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
            }
            i = nOneLibStrsStored;
            byStr = (short)(m_Engine.m_byPeriStr[i] & 0xff);
            while (byStr != 0) {
                if (((m_Engine.m_byLiberties[byStr] & 0xff) < 2) ||
                        (m_Engine.m_byLiberties[byStr] > m_Engine.m_byLiberties[m_Engine.m_byStrNum] + 1)) {
                    byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
                    continue;
                }
                if ( (m_Engine.m_wStatus[byStr] & 0x000C) == 0) {
                    if (m_Engine.m_nDepth >= 2) {
                        byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
                        continue;
                    }
                    if (cCrit < 0)
                        wPoint = m_Engine.m_wResultInSecond[byStr];
                    else
                        wPoint = m_Engine.m_wResultInFirst[byStr];
                    if (wPoint == (short) 0xffff) {
                        byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
                        continue;
                    }

                    pnResult = wPoint;
                    wPoint = (short) (((m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT + 1] & 0xffff) << 8) |
                            (m_Engine.m_pResultArea[pnResult + sizeofSIMULRESULT] & 0xff));
                    if (m_Engine.m_byBoard[wPoint & 0xffff] == 0) {
                        if (cCrit < 0) {
                            if (m_Engine.m_pResultArea[pnResult + 1] == 0)
                                m_Engine.m_wStatus[byStr] = 0x0004;
                            else {
                                m_Engine.m_wStatus[byStr] = 0;
                                m_Engine.m_wStatus[m_Engine.m_pResultArea[pnResult + 1]] = 0;
                            }
                        }
                        if ( (cCrit >= 0) || (m_Engine.m_nDepth >= 1))
                            RegInFirstPlace(wPoint);
                        else
                            RegInSomePlace(wPoint);
                        if (m_Engine.m_byLiberties[byStr] == 2) {
                            GetLibs(byStr, wEmptyPt);
                            RegInLastPlace(wEmptyPt[0]);
                            RegInLastPlace(wEmptyPt[1]);
                        }
                        byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
                        continue;
                    }
                } else {
                    if (m_Engine.m_wSetInSecond[byStr] == (short) 0xffff) {
                        if ( (m_Engine.m_nDepth >= 2) && (m_Engine.m_byLiberties[byStr] == 2)) {
                            byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
                            continue;
                        }
                    } else if ( (cCrit < 0) && (m_Engine.m_nDepth < 2)) {
                        pnSet = m_Engine.m_wSetInSecond[byStr];
                        if ((m_Engine.m_pSimulArea[pnSet + sizeofSIMULSET + 4] & 0xff) > 0) {
                            wPoint = (short) (((m_Engine.m_pSimulArea[pnSet + sizeofSIMULSET +
                                    sizeofSIMULUNIT + 1] & 0xffff) << 8) |
                                    (m_Engine.m_pSimulArea[pnSet + sizeofSIMULSET +
                                            sizeofSIMULUNIT] & 0xff));
                            if (m_Engine.m_byBoard[wPoint & 0xFFFF] == 0) {
                                if (m_Engine.m_nDepth == 1)
                                    RegInFirstPlace(wPoint);
                                else
                                    RegInSomePlace(wPoint);
                                byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
                                continue;
                            }
                        }
                    }
                }

                GetLibs(byStr, wEmptyPt);
                for (n = 0; n < (m_Engine.m_byLiberties[byStr] & 0xFF); n++) {
                    if (cCrit < 0) {
                        byTemp = TestSEPOfPeri(wEmptyPt[n]);
                        if (byTemp == 0) {
                            if (m_Engine.m_nDepth >= 1)
                                RegInFirstPlace(wEmptyPt[n]);
                            else
                                RegInSomePlace(wEmptyPt[n]);
                        } else if (byTemp == 2) {
                            RegInLastPlace(wEmptyPt[n]);
                        }
                    } else {
                        m_Engine.m_nBoardPos = wEmptyPt[n];
                        m_Engine.m_nPaePos = 0;
                        SetTestStone(m_Engine.m_byColor);
                        m_Engine.m_nPaePos = wPaePos;
                        if (m_Engine.m_nSCount >= 2)
                            m_Engine.m_byNewLiberties++;
                        if (m_Engine.m_byNewLiberties > m_Engine.m_byLiberties[byStr]) {
                            RegInLastPlace(wEmptyPt[n]);
                        }
                    }
                }
                byStr = (short)(m_Engine.m_byPeriStr[++i] & 0xff);
            }

            m_Engine.m_nPaePos = wPaePos;
            m_Engine.m_nOneLibStrs = nOneLibStrsStored;
        } catch (Exception e) {
            //System.out.println("RegPtsOnMSPeris");
        }
    }

    short OppStrOrEmptyNearby(byte byStr, short wPoint) {
        short i;
        byte byOtherStr;

        for (i = 0; i < 4; i++) {
            byOtherStr = m_Engine.m_byBoard[(wPoint & 0xffff) + m_Engine.nNeighbor[i]];
            if (byOtherStr != INITVALUE) {
                if ((byOtherStr == 0) || (((byOtherStr ^ byStr) & 1) != 0))
                    return 1;
            }
        }
        return 0;
    }

    byte TestSEPOfPeri(short wPoint) {
        int i, j = 0;
        short wPaePos = m_Engine.m_nPaePos;
        short wEmptyPoint[] = new short[2];

        m_Engine.m_nPaePos = 0;
        m_Engine.m_nBoardPos = wPoint;
        SetTestStone(m_Engine.m_byColor);
        m_Engine.m_nPaePos = wPaePos;

        if (m_Engine.m_byNewLiberties == 0)
            return 0x01;
        if ( ((m_Engine.m_byNewLiberties & 0xff) > 1) || (m_Engine.m_nDeadStoneCount > 0))
            return 0x00;

        if (m_Engine.m_nSCount > 0) {
            for (i = 0; i < m_Engine.m_nSCount; i++) {
                if (m_Engine.m_byLiberties[m_Engine.m_bySameBuf[i] & 0xff] != 2)
                    continue;
                GetLibs(m_Engine.m_bySameBuf[i], wEmptyPoint);
                if (wEmptyPoint[0] == wPoint)
                    j = wEmptyPoint[1];
                else
                    j = wEmptyPoint[0];
                break;
            }
        } else {
            for (i = 0; i < 4; i++) {
                j = (wPoint & 0xffff) + m_Engine.nNeighbor[i];
                // assert j >= 0 : "TestSEPOfPeri() :  index must be not less than 0."; // by KWJ : 2007-04-19
                if (m_Engine.m_byBoard[j] == 0)
                    break;
            }
        }

        for (i = 0; i < m_Engine.m_nDCount; i++) {
            if (((m_Engine.m_byDifferLiberties[i] & 0xff) >= 3) ||
                    (IsSameStringg((short) j, m_Engine.m_byDifferBuf[i]) == false))
                break;
        }

        if (i >= m_Engine.m_nDCount)
            return 0x00;
        return 0x02;
    }

    short PlaySimulStone(short wPoint) {
        short i;
        byte byStr;
        short wPaePos = m_Engine.m_nPaePos;

        if ((m_Engine.m_cGoodTimes.length > (wPoint & 0xffff)) &&
                (m_Engine.m_cGoodTimes[wPoint & 0xffff] <= 0)) {
            try {
                for (i = 0; i < 4; i++) {
                    byStr = m_Engine.m_byBoard[(wPoint & 0xffff) + m_Engine.nNeighbor[i]];
                    if ((byStr != INITVALUE) && (byStr != 0) &&
                            ((((byStr ^ (byte)m_Engine.m_byStrNum) & 1) == 0) ||
                                    ((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) < 2)))
                        break;
                }
                if (i >= 4)
                    return 2;
            } catch (ArrayIndexOutOfBoundsException e) {
                return 2;
            }
        }

        m_Engine.m_nBoardPos = wPoint;
        m_Engine.m_byStoneColor = m_Engine.m_byColor;
        SetSimulStone();

        if ((m_Engine.m_byNewLiberties & 0xff) <= 0) {
            m_Engine.m_nPaePos = wPaePos;
            return 1;
        }
        return 0;
    }

    byte PlayStnAndSimulInSecond(int pnSimulPt) {
        short wPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xffff) << 8) |
                (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
        int pnChildUnit = m_Engine.m_wCurrEnd;
        short nResult;
        short nLibs;

        m_Engine.m_pTempArea[pnChildUnit] = (short) m_Engine.m_nCurrUnit;
        m_Engine.m_pTempArea[pnChildUnit + 1] = (short) (m_Engine.m_nCurrUnit >> 8);
        m_Engine.m_pTempArea[pnSimulPt + 2] = (short) (pnChildUnit & 0xff);
        m_Engine.m_pTempArea[pnSimulPt + 3] = (short) ( (pnChildUnit >> 8) & 0xff);
        InitGoodTimes();

        if (wPoint != 0) {
            if (wPoint == (short) m_Engine.m_nPaePos) {
                m_Engine.m_pTempArea[pnChildUnit + 2] = -2;
                m_Engine.m_pTempArea[pnChildUnit + 3] = 0;
                m_Engine.m_pTempArea[pnChildUnit + 4] = 0;
                m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
                m_Engine.m_cGoodTimes[wPoint]--;
                return -2;
            }
            nResult = PlaySimulStone(wPoint);
            if (nResult != 0) {
                if (nResult == 1)
                    m_Engine.m_pTempArea[pnChildUnit + 2] = -1;
                else
                    m_Engine.m_pTempArea[pnChildUnit + 2] = -6;
                m_Engine.m_pTempArea[pnChildUnit + 3] = 0;
                m_Engine.m_pTempArea[pnChildUnit + 4] = 0;
                m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
                m_Engine.m_cGoodTimes[wPoint & 0xffff]--;
                return (byte) m_Engine.m_pTempArea[pnChildUnit + 2];
            }
        }

        nLibs = (short)(m_Engine.m_byLiberties[m_Engine.m_byStrNum] & 0xff);
        if (nLibs < 2) {
            m_Engine.m_pTempArea[pnChildUnit + 2] = -1;
            m_Engine.m_pTempArea[pnChildUnit + 3] = 0;
            m_Engine.m_pTempArea[pnChildUnit + 4] = 0;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
            m_Engine.m_wCurrEnd += sizeofSIMULUNIT;
            if (wPoint != 0) {
                m_Engine.m_cGoodTimes[wPoint & 0xffff]--;
                RecoverBoard(pnChildUnit);
            }
            return -1;
        }

        if (nLibs >= m_Engine.m_nLibsLimit) {
            m_Engine.m_pTempArea[pnChildUnit + 2] = 1;
            m_Engine.m_pTempArea[pnChildUnit + 3] = 0;
            m_Engine.m_pTempArea[pnChildUnit + 4] = 0;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
            m_Engine.m_wCurrEnd += sizeofSIMULUNIT;
            if (wPoint != 0) {
                m_Engine.m_cGoodTimes[wPoint & 0xffff]++;
                RecoverBoard(pnChildUnit);
            }
            return 1;
        }

        m_Engine.m_pTempArea[pnChildUnit + 2] = CallReflexRoutine(SIMUL_INSECOND_MANYSEP);
        if (wPoint != 0) {
            //HJ_Debug>>
//            System.out.println("m_nBoardPos = " + m_Engine.m_nBoardPos);
//            System.out.println("wPoint = " + wPoint);
//            System.out.println("pnChildUnit = " + pnChildUnit);
//            System.out.println("pnSimulPt = " + pnSimulPt);
            //<<
            if (m_Engine.m_pTempArea[pnChildUnit + 2] < 0)
                m_Engine.m_cGoodTimes[wPoint & 0xffff]--;
            else
                m_Engine.m_cGoodTimes[wPoint & 0xffff]++;
            RecoverBoard(pnChildUnit);
        }
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
        return (byte) m_Engine.m_pTempArea[pnChildUnit + 2];
    }

    void RecoverBoard(int pnEndUnit) {
        short byStrNumStored = m_Engine.m_byStrNum;

        short n = 0;
        int pnUnit = pnEndUnit;
        short wPoint;
        int pnSimulPt;
        int oldUnit;
        while ((((m_Engine.m_pTempArea[pnUnit + 1] & 0xffff) << 8) |
                (m_Engine.m_pTempArea[pnUnit] & 0xff)) != 0) {
            oldUnit = pnUnit;
            pnUnit = (short) (((m_Engine.m_pTempArea[pnUnit + 1] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnUnit] & 0xff));
            n++;
        }
        RestorStrDatas(CHILD_BACKUP);

        n--;
        if (n <= 0)
            return;
        m_Engine.m_byStrNum = m_Engine.m_pTempArea[pnUnit - sizeofSIMULSET + 2];
        m_Engine.m_byColor = (byte) m_Engine.m_pTempArea[pnUnit - sizeofSIMULSET + 3];

        while (n > 0) {
            // by KWJ
//            pnSimulPt = m_Engine.m_pTempArea[pnUnit + sizeofSIMULUNIT] +
//                        m_Engine.m_pTempArea[pnUnit + 4] & 0xff;
            pnSimulPt = pnUnit + sizeofSIMULUNIT +
                    (m_Engine.m_pTempArea[pnUnit + 4] & 0xff) * sizeofSIMULPOINT;
            wPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
            if (wPoint == 0)
                m_Engine.m_nPaePos = 0;
            else {
                m_Engine.m_nBoardPos = wPoint;
                m_Engine.m_byStoneColor = m_Engine.m_byColor;
                SetSimulStone();
            }
            n--;
            m_Engine.m_byColor ^= 3;
            pnUnit = (short) (((m_Engine.m_pTempArea[pnSimulPt + 3] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt + 2] & 0xff));
        }
        m_Engine.m_byStrNum = byStrNumStored;
    }

    boolean IsStopOfSimul(short nRegs) {
        // by KWJ : 2007-04-30
        if (System.currentTimeMillis() - m_dwTimeStart > m_dwLimitTime / 3) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -8;
            return true;
        }

        if ( ( (m_Engine.m_nDepth >= m_Engine.m_nMaxDepth) &&
                (m_Engine.m_byLiberties[m_Engine.m_byStrNum] > 1)) ||
                (m_Engine.m_wCurrLimit < m_Engine.m_wCurrEnd) || (AssignMemory(nRegs) == 0)) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -8;
            return true;
        }
        return false;
    }

    short AssignMemory(short nRemains) {
        short wRemainMem = (short) (m_Engine.m_wCurrEnd + sizeofSIMULUNIT);

        if (m_Engine.m_wCurrLimit < wRemainMem)
            return 0;

        wRemainMem = (short) (m_Engine.m_wCurrLimit - wRemainMem);
        if (wRemainMem < SIMULMEMORYOFONEUNIT)
            m_Engine.m_wAssignLimit = m_Engine.m_wCurrLimit;
        else {
            if (nRemains == 1)
                m_Engine.m_wAssignLimit = m_Engine.m_wCurrLimit;
            else if (nRemains == 2)
                m_Engine.m_wAssignLimit = (short) (m_Engine.m_wCurrLimit - wRemainMem / 3);
            else
                m_Engine.m_wAssignLimit = (short) (m_Engine.m_wCurrLimit - wRemainMem / 2);
        }
        return 1;
    }

    void OneSEPPlusNeighbors(short wPoint, byte byPos) {
        byte byTemp1, byTemp2;
        short wPoint1, wPoint2;
        byte byStr1, byStr2;

        if ((byPos & 0xf0) == 0xf0)
            return;

        byTemp1 = (byte) (byPos & 0x50);
        byTemp2 = (byte) (byPos & 0xa0);
        if (byTemp1 == 0) {
            if (byTemp2 != (byte)0xa0)
                ScoreAndArrange(wPoint);
            SeeAroundSEP(wPoint);
            return;
        }
        if (byTemp2 == 0) {
            if (byTemp1 != 0x50)
                ScoreAndArrange(wPoint);
            SeeAroundSEP(wPoint);
            return;
        }

        wPoint1 = wPoint;
        wPoint2 = wPoint;

        if (byTemp1 == 0x40)
            wPoint1 -= 1;
        else if (byTemp1 == 0x10)
            wPoint1 += 1;

        if (byTemp2 == (byte)0x80)
            wPoint2 -= 20;
        else if (byTemp2 == 0x20)
            wPoint2 += 20;

        if ( (byTemp1 != 0x50) && (byTemp2 != (byte)0xa0)) {
            if (TestSafetyOfSEP(wPoint) != 0) {
                ScoreAndArrange(wPoint);
                SeeAroundSEP(wPoint);
                return;
            }

            byStr1 = m_Engine.m_byBoard[wPoint1 & 0xffff];
            byStr2 = m_Engine.m_byBoard[wPoint2 & 0xffff];

            if ( (byStr1 != INITVALUE) && (byStr1 != 0)) {
                if (((byStr1 ^ (byte)m_Engine.m_byStrNum) & 1) == 0) {
                    ScoreAndArrange(wPoint);
                    SeeAroundSEP(wPoint);
                    return;
                }
            }
            if ( (byStr2 != INITVALUE) && (byStr2 != 0)) {
                if ( ( (byStr2 ^ (byte)m_Engine.m_byStrNum) & 1) == 0) {
                    ScoreAndArrange(wPoint);
                    SeeAroundSEP(wPoint);
                    return;
                }
            }

            if ( (byStr1 == 0) && (byStr2 == 0)) {
                byStr1 = m_Engine.m_byBoard[(wPoint1 + (wPoint - wPoint2)) & 0xffff];
                byStr2 = m_Engine.m_byBoard[(wPoint2 + (wPoint - wPoint1)) & 0xffff ];
                if (((byStr1 & 0xff) == m_Engine.m_byStrNum) ||
                        ((byStr2 & 0xff) == m_Engine.m_byStrNum))
                    ScoreAndArrange(wPoint);
            }
            SeeAroundSEP(wPoint);
            return;
        }

        if (byTemp1 == 0x50) {
            byStr2 = m_Engine.m_byBoard[wPoint2 & 0xffff];
            if (byStr2 == INITVALUE)
                return;
            if (byStr2 == 0) {
                ScoreAndArrange(wPoint2);
                return;
            }
            if (((byStr2 ^ (byte)m_Engine.m_byStrNum) & 1) != 0)
                return;
            ScoreAndArrange(wPoint);
            return;
        }

        byStr1 = m_Engine.m_byBoard[wPoint1 & 0xffff];
        if (byStr1 == INITVALUE)
            return;
        if (byStr1 == 0) {
            ScoreAndArrange(wPoint1);
            return;
        }
        if (((byStr1 ^ (byte)m_Engine.m_byStrNum) & 1) != 0)
            return;
        ScoreAndArrange(wPoint);
        return;
    }

    short TestSafetyOfSEP(short wPoint) {
        short i, nEnclose = 0;
        byte byPos = 0, byStr;
        short wPos;

        for (i = 0; i < 4; i++) {
            byStr = m_Engine.m_byBoard[(wPoint & 0xffff) + m_Engine.nNeighbor[i]];
            if (byStr == INITVALUE) {
                nEnclose++;
                continue;
            }
            if (byStr == 0)
                continue;
            if (((byStr ^ (byte)m_Engine.m_byStrNum) & 1) != 0) {
                if ((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) > 2)
                    return 0;
                if ((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) == 2)
                    byPos |= (1 << i);
                else
                    nEnclose++;
                continue;
            }
            if ((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) >= 2) {
                nEnclose++;
                continue;
            }
            if (m_Engine.m_nStoneCount[byStr & 0xff] >= 2)
                continue;
            if (wPoint == m_Engine.m_nPaePos)
                return 1;
            return 0;
        }

        if (nEnclose != 2)
            return 1;
        switch (byPos) {
            case 0x03:
                wPos = (short) (wPoint - 21);
                break;
            case 0x06:
                wPos = (short) (wPoint - 19);
                break;
            case 0x09:
                wPos = (short) (wPoint + 19);
                break;
            case 0x0c:
                wPos = (short) (wPoint + 21);
                break;
            default:
                return 0;
        }

        if (((byStr = m_Engine.m_byBoard[wPos & 0xffff]) == 0) || (((byStr ^ (byte)m_Engine.m_byStrNum) & 1) != 0))
            return 1;
        return 0;
    }

    void ScoreAndArrange(short wPoint) {
        if (IsInUnit(wPoint) >= 0)
            return;
        ScoreAndArrInManyDepth(wPoint);
    }

    void ScoreAndArrInManyDepth(short wPoint) {
        short nScore;

        if (m_Engine.m_nScoredPoints >= MAX_SCOREDPOINTS)
            return;
        nScore = GetScoreByNeighbors(wPoint);
        if (nScore >= 0) {
            RegByScore(wPoint, nScore);
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]++;
        }
    }

    void SeeAroundSEP(short wPoint) {
        short wPos;
        short i, nIsGood;

        for (i = 0; i < 4; i++) {
            wPos = (short) ((wPoint & 0xffff) + m_Engine.nNeighbor[i]);
            if (m_Engine.m_byBoard[wPos & 0xffff] != 0)
                continue;

            m_Engine.m_byBoard[wPos & 0xffff] = (byte) (m_Engine.m_byStrNum & 0xff);
            nIsGood = TestSafetyOfSEP(wPoint);
            m_Engine.m_byBoard[wPos & 0xffff] = 0;
            if (nIsGood != 0)
                ScoreAndArrange(wPos);
        }
    }

    short TwoSEPsInFirst(short wPoint1, byte byPos1, short wPoint2, byte byPos2) {
        byte byStr;
        short wPoint, wPointOn, wPointFrom;
        short nDif = (short) (wPoint2 - wPoint1);

        if ( (nDif == 19) || (nDif == 21)) {
            ScoreAndArrange(wPoint1);
            ScoreAndArrange(wPoint2);

            wPoint = (short) (wPoint2 - 20);
            byStr = m_Engine.m_byBoard[wPoint];
            if (byStr == 0) {
                ScoreAndArrange(wPoint);
                SeeAroundSEP(wPoint2);
                SeeAroundSEP(wPoint1);
                return 1;
            }

            if ((byStr & 0xff) == m_Engine.m_byStrNum) {
                wPoint = (short) (wPoint1 + 20);
                byStr = m_Engine.m_byBoard[wPoint & 0xffff];
                if (byStr == 0) {
                    ScoreAndArrange(wPoint);
                    SeeAroundSEP(wPoint2);
                    SeeAroundSEP(wPoint1);
                    return 1;
                }
            }

            if (((byStr & 0xff) == m_Engine.m_byStrNum) || (((byStr ^ (byte)m_Engine.m_byStrNum) & 1) == 0) ||
                    ((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) <= 2)) {
                SeeAroundSEP(wPoint2);
                SeeAroundSEP(wPoint1);
                return 1;
            }
        } else if (nDif == 1) {
            if ( (byPos1 & 0x10) != 0)
                wPointOn = 0;
            else {
                if (m_Engine.m_byBoard[(wPoint1 & 0xffff) - 1] != INITVALUE)
                    wPointOn = (short) ((wPoint1 & 0xffff) - 1);
                else
                    wPointOn = wPoint1;
            }

            if ( (byPos1 & 0x80) != 0) {
                if (m_Engine.m_byBoard[(wPoint1 & 0xffff) - 20] != INITVALUE)
                    wPointFrom = (short)((wPoint1 & 0xffff) - 20);
                else
                    wPointFrom = wPoint1;
            } else {
                if (m_Engine.m_byBoard[(wPoint1 & 0xffff) + 20] != INITVALUE)
                    wPointFrom = (short) ((wPoint1 & 0xffff) + 20);
                else
                    wPointFrom = wPoint1;
            }
            TwoAttachedSEPs(wPoint1, wPointOn, wPointFrom);

            if ( (byPos2 & 0x40) != 0)
                wPointOn = 0;
            else {
                if (m_Engine.m_byBoard[(wPoint2 & 0xffff) + 1] != INITVALUE)
                    wPointOn = (short) ((wPoint2 & 0xffff) + 1);
                else
                    wPointOn = wPoint2;
            }

            wPointFrom += 1;
            TwoAttachedSEPs(wPoint2, wPointOn, wPointFrom);
            return 1;
        } else if (nDif == 20) {
            if ( (byPos1 & 0x20) != 0)
                wPointOn = 0;
            else {
                if (m_Engine.m_byBoard[(wPoint1 & 0xffff) - 20] != INITVALUE)
                    wPointOn = (short) ((wPoint1 & 0xffff) - 20);
                else
                    wPointOn = wPoint1;
            }

            if ( (byPos1 & 0x40) != 0) {
                if (m_Engine.m_byBoard[(wPoint1 & 0xffff) - 1] != INITVALUE)
                    wPointFrom = (short) ((wPoint1 & 0xffff) - 1);
                else
                    wPointFrom = wPoint1;
            } else {
                if (m_Engine.m_byBoard[(wPoint1 & 0xffff) + 1] != INITVALUE)
                    wPointFrom = (short)((wPoint1 & 0xffff) + 1);
                else
                    wPointFrom = wPoint1;
            }
            TwoAttachedSEPs(wPoint1, wPointOn, wPointFrom);

            if ( (byPos2 & 0x80) != 0)
                wPointOn = 0;
            else {
                if (m_Engine.m_byBoard[(wPoint2 & 0xffff) + 20] != INITVALUE)
                    wPointOn = (short)((wPoint2 & 0xffff) + 20);
                else
                    wPointOn = wPoint2;
            }
            wPointFrom += 20;
            TwoAttachedSEPs(wPoint2, wPointOn, wPointFrom);
            return 1;
        }
        return 0;
    }

    void TwoAttachedSEPs(short wPoint, short wPointOn, short wPointFrom) {
        byte byStrFrom;

        if (wPointOn == 0) {
            if (wPointFrom == wPoint)
                return;
            if ( (byStrFrom = m_Engine.m_byBoard[wPointFrom & 0xffff]) == 0)
                ScoreAndArrange(wPointFrom);
            else if (((byStrFrom & 0xff) != m_Engine.m_byStrNum) &&
                    (((byStrFrom ^ (byte)m_Engine.m_byStrNum) & 1) == 0))
                ScoreAndArrange(wPoint);
            return;
        }

        ScoreAndArrange(wPoint);
        if ( (wPointOn != wPoint) && (m_Engine.m_byBoard[wPointOn & 0xffff] == 0))
            ScoreAndArrange(wPointOn);
        if ( (wPointFrom != wPoint) && (m_Engine.m_byBoard[wPointFrom & 0xffff] == 0))
            ScoreAndArrange(wPointFrom);
        return;
    }

    byte TestSEP() {
        short wPaePos = m_Engine.m_nPaePos;
        short i, j, nKilledStns;
        short wPos = 0;
        byte byStr;

        GetLibs(m_Engine.m_byStrNum, m_Engine.m_wEmptyPoint);
        if (m_Engine.m_wEmptyPoint[0] == wPaePos)
            return -2;
        if (m_Engine.m_nStoneCount[m_Engine.m_byStrNum] >= 2)
            return 1;

        m_Engine.m_nBoardPos = m_Engine.m_wEmptyPoint[0];
        SetTestStone(m_Engine.m_byColor);
        m_Engine.m_nPaePos = wPaePos;

        if ((m_Engine.m_byNewLiberties & 0xff) >= 2)
            return 1;
        if (m_Engine.m_nSCount == 0)
            return 2;

        for (i = 0; i < 4; i++) {
            wPos = (short) (m_Engine.m_nBoardPos + m_Engine.nNeighbor[i]);
            if ((m_Engine.m_byBoard[wPos & 0xffff] & 0xff) == m_Engine.m_byStrNum)
                break;
        }

        nKilledStns = 1;
        for (i = 0; i < 4; i++) {
            byStr = m_Engine.m_byBoard[(wPos & 0xffff) + m_Engine.nNeighbor[i]];
            if ( (byStr != 0) && (byStr != INITVALUE)) {
                for (j = 0; j < m_Engine.m_nSCount; j++) {
                    if (byStr == m_Engine.m_bySameBuf[j]) {
                        nKilledStns += 1;
                        break;
                    }
                }
            }
        }
        if (nKilledStns == 1)
            return 1;
        if (nKilledStns == 2)
            return 0;
        return -1;
    }

    byte SimulInFirstOfOSStr_Reflex() {
        short wCurrLimitStored = m_Engine.m_wCurrLimit;
        int pnCurrUnitStored = m_Engine.m_nCurrUnit;
        int pnSimulPt;
        short nRegs;
        byte cStatus;
        short nLibsLimit;

        m_Engine.m_wCurrLimit = m_Engine.m_wAssignLimit;
        m_Engine.m_nCurrUnit = m_Engine.m_wCurrEnd;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] = 0;
        m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

        GetLibs(m_Engine.m_byStrNum, m_Engine.m_wEmptyPoint);
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3]++;

        pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        m_Engine.m_pTempArea[pnSimulPt] = (short) (m_Engine.m_wEmptyPoint[0] & 0xff);
        m_Engine.m_pTempArea[pnSimulPt + 1] = (short) (((m_Engine.m_wEmptyPoint[0] & 0xffff) >> 8) & 0xff);
        m_Engine.m_pTempArea[pnSimulPt + 2] = 0;
        m_Engine.m_pTempArea[pnSimulPt + 3] = 0;
        m_Engine.m_wCurrEnd += sizeofSIMULPOINT;

        if (GetPeriStrs(m_Engine.m_byStrNum, (short) 1) > 0)
            RegPtsOnOSPerisInFirst();

        FixupCandis();

        nRegs = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3];
        if (nRegs == 0) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -1;
            m_Engine.m_wCurrLimit = wCurrLimitStored;
            m_Engine.m_nCurrUnit = pnCurrUnitStored;
            return -1;
        }
        if (nRegs > m_Engine.m_nMaxSimulPoints) {
            nRegs = m_Engine.m_nMaxSimulPoints;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = (short) (nRegs & 0xff);
            m_Engine.m_wCurrEnd = (short) (m_Engine.m_nCurrUnit + sizeofSIMULUNIT +
                    nRegs*sizeofSIMULPOINT);
        }

        if (IsStopOfSimul(nRegs)) {
            m_Engine.m_wCurrLimit = wCurrLimitStored;
            m_Engine.m_nCurrUnit = pnCurrUnitStored;
            return -8;
        }

        nLibsLimit = m_Engine.m_nLibsLimit;

        while (true) {
            PlayStnAndSimulInSecond(pnSimulPt);
            m_Engine.m_nLibsLimit = nLibsLimit;
            nRegs--;
            pnSimulPt += sizeofSIMULPOINT;
            if ( (nRegs <= 0) || (AssignMemory(nRegs) == 0))
                break;
        }
        cStatus = GetUnitStatus();

        m_Engine.m_wCurrLimit = wCurrLimitStored;
        m_Engine.m_nCurrUnit = pnCurrUnitStored;
        return cStatus;
    }

    byte SimulInSecondOfMSStr() {
//	ExecuteCommand();
        short wCurrLimitStored = m_Engine.m_wCurrLimit;
        int pnCurrUnitStored = m_Engine.m_nCurrUnit, pnChildUnit;
        short nLibs = GetLibs(m_Engine.m_byStrNum, m_Engine.m_wEmptyPoint);
        short wPaePos = m_Engine.m_nPaePos;
        byte byColor = (byte) (m_Engine.m_byColor ^ 3);
        short wPoint, wPoint1, wPoint2;
        int nTemp, j;
        short wEmptyPoint[] = new short[3];
        short nNewLibs[] = new short[3];
        byte cStatus = 0;
        int pnSimulPt;

        //try {

        m_Engine.m_wCurrLimit = m_Engine.m_wAssignLimit;
        m_Engine.m_nCurrUnit = m_Engine.m_wCurrEnd;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = 0;
        m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] = 0;
        m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

        for (nTemp = 0; nTemp < nLibs; nTemp++) {
            m_Engine.m_nPaePos = 0;
            m_Engine.m_nBoardPos = m_Engine.m_wEmptyPoint[nTemp];
            SetTestStone(byColor);
            if (m_Engine.m_nDeadStoneCount > 0)
                m_Engine.m_byNewLiberties = (byte) - m_Engine.m_byNewLiberties;
            wPoint = m_Engine.m_wEmptyPoint[nTemp];
            j = nTemp - 1;
            while (j >= 0) {
                if (m_Engine.m_nNewLibs[j] >= (m_Engine.m_byNewLiberties & 0xff))
                    break;
                m_Engine.m_nNewLibs[j + 1] = m_Engine.m_nNewLibs[j];
                m_Engine.m_wEmptyPoint[j + 1] = m_Engine.m_wEmptyPoint[j];
                j--;
            }
            m_Engine.m_nNewLibs[j + 1] = (short)(m_Engine.m_byNewLiberties & 0xff);
            m_Engine.m_wEmptyPoint[j + 1] = wPoint;
        }
        m_Engine.m_nPaePos = wPaePos;

        wEmptyPoint[0] = m_Engine.m_wEmptyPoint[0];
        wEmptyPoint[1] = m_Engine.m_wEmptyPoint[1];
        wEmptyPoint[2] = m_Engine.m_wEmptyPoint[2];
        nNewLibs[0] = m_Engine.m_nNewLibs[0];
        nNewLibs[1] = m_Engine.m_nNewLibs[1];
        nNewLibs[2] = m_Engine.m_nNewLibs[2];

        if (m_Engine.m_nDepth >= m_Engine.m_nDepthCrit)
            m_Engine.m_nLibsLimit = 3;
        else
            m_Engine.m_nLibsLimit = 4;
        do {
            if (m_Engine.m_nDepth > 0) {
                if (m_Engine.m_nNewLibs[1] > m_Engine.m_nLibsLimit) {
                    m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -1;
                    m_Engine.m_wCurrLimit = wCurrLimitStored;
                    m_Engine.m_nCurrUnit = pnCurrUnitStored & 0x3fff;
                    return -1;
                }
                if (m_Engine.m_nNewLibs[0] > m_Engine.m_nLibsLimit) {
                    AddSimulPoint(m_Engine.m_wEmptyPoint[0]);
                    break;
                }
            }

            if (m_Engine.m_nDepth < m_Engine.m_nDepthCrit)
                m_Engine.m_cInfo = 1;
            else if ((m_Engine.m_byLiberties[m_Engine.m_byStrNum] & 0xff) >= m_Engine.m_nLibsLimit)
                m_Engine.m_cInfo = -1;
            else
                m_Engine.m_cInfo = 0;

            if (nLibs >= 3) {
                wPoint = m_Engine.m_wEmptyPoint[2];
                if ((m_Engine.m_byPosBoard[wPoint & 0xffff] & 0xff) >= 3) {
                    wPoint = m_Engine.m_wEmptyPoint[1];
                    if ((m_Engine.m_byPosBoard[wPoint & 0xffff] & 0xff) < 3)
                        m_Engine.m_wEmptyPoint[1] = m_Engine.m_wEmptyPoint[2];
                    else {
                        wPoint = m_Engine.m_wEmptyPoint[0];
                        if ((m_Engine.m_byPosBoard[wPoint & 0xffff] & 0xff) >= 3)
                            wPoint = m_Engine.m_wEmptyPoint[2];
                        else {
                            m_Engine.m_wEmptyPoint[0] = m_Engine.m_wEmptyPoint[1];
                            m_Engine.m_wEmptyPoint[1] = m_Engine.m_wEmptyPoint[2];
                        }
                    }
                }

                wPoint1 = m_Engine.m_wEmptyPoint[0];
                wPoint2 = m_Engine.m_wEmptyPoint[1];
                OneSEP(wPoint);
                m_Engine.m_wEmptyPoint[0] = wPoint1;
                m_Engine.m_wEmptyPoint[1] = wPoint2;
                TwoSEPs();
            } else if ( ( (m_Engine.m_nNewLibs[0] == 3) && (m_Engine.m_nNewLibs[1] == 3)) ||
                    ( (m_Engine.m_nNewLibs[1] >= 3) && (m_Engine.m_cInfo > 0))) {
                wPoint1 = m_Engine.m_wEmptyPoint[0];
                wPoint2 = m_Engine.m_wEmptyPoint[1];

                nTemp = wPoint2 - wPoint1;
                if ( (nTemp != 19) && (nTemp != 21) && (nTemp != -19) && (nTemp != -21)) {
                    if ( (m_Engine.m_cInfo > 0) || (m_Engine.m_nNewLibs[0] != 3) ||
                            (m_Engine.m_nNewLibs[1] != 3) ||
                            ((m_Engine.m_byPosBoard[wPoint1 & 0xffff] & 0xff) <= 3) ||
                            ((m_Engine.m_byPosBoard[wPoint2 & 0xffff] & 0xff) <= 3) ||
                            (!TwoSEPOppStrNearby(wPoint1) && !TwoSEPOppStrNearby(wPoint2)))
                        TwoSEPs();
                    else {
                        OneSEP(wPoint1);
                        OneSEP(wPoint2);
                    }
                } else {
                    if (nTemp > 0)
                        wPoint = (short) (wPoint2 - 20);
                    else
                        wPoint = (short) (wPoint2 + 20);

                    j = 0;
                    if (m_Engine.m_byBoard[wPoint & 0xffff] == 0) {
                        if ((m_Engine.m_byPosBoard[wPoint & 0xffff] & 0xff) >= 3)
                            j = 1;
                    } else {
                        if (nTemp > 0)
                            wPoint = (short) (wPoint1 + 20);
                        else
                            wPoint = (short) (wPoint1 - 20);
                        if ( (m_Engine.m_byBoard[wPoint & 0xffff] == 0) &&
                                ((m_Engine.m_byPosBoard[wPoint & 0xffff] & 0xff) >= 3))
                            j = 1;
                    }

                    if (j == 0)
                        TwoSEPs();
                    else if (m_Engine.m_nNewLibs[0] > 3) {
                        TwoSEPs();
                        RegInLastPlace(wPoint);
                    } else if ( (m_Engine.m_byPosBoard[wPoint1 & 0xffff] != 3) &&
                            (m_Engine.m_byPosBoard[wPoint2 & 0xffff] != 3)) {
                        TwoSEPs();
                        if (GetPeriStrs(m_Engine.m_byStrNum, (short) 2) > 0)
                            RegInLastPlace(wPoint);
                        else
                            RegInFirstPlace(wPoint);
                    } else {
                        if (m_Engine.m_byPosBoard[wPoint1 & 0xffff] == 3) {
                            OneSEP(wPoint2);
                            OneSEP(wPoint1);
                        } else {
                            OneSEP(wPoint1);
                            OneSEP(wPoint2);
                        }
                        RegInLastPlace(wPoint);
                    }
                }
            } else
                TwoSEPs();

            for (nTemp = 0; nTemp < 3; nTemp++)
                m_Engine.m_wEmptyPoint[nTemp] = wEmptyPoint[nTemp];

            if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] == 0) {
                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -1;
                m_Engine.m_wCurrLimit = wCurrLimitStored;
                m_Engine.m_nCurrUnit = pnCurrUnitStored;
                return -1;
            }

            if (m_Engine.m_nNewLibs[0] <= m_Engine.m_nLibsLimit) {
                if (m_Engine.m_nNewLibs[0] < m_Engine.m_nLibsLimit) {
                    GetPeriStrs(m_Engine.m_byStrNum, (short) 3);
                    RegPtsOnMSPeris( (byte) (nLibs - 2));
                } else
                    GetPeriStrs(m_Engine.m_byStrNum, (short) 1);
                if (m_Engine.m_nOneLibStrs > 0)
                    RegPtsOnOSPerisInSecond();
            }
        } while (false); //SIMUL

        nTemp = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3];
        if (nTemp == 0) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 2] = -1;
            m_Engine.m_wCurrLimit = wCurrLimitStored;
            m_Engine.m_nCurrUnit = pnCurrUnitStored;
            return -1;
        }

        if (nTemp > m_Engine.m_nMaxSimulPoints) {
            nTemp = m_Engine.m_nMaxSimulPoints;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = (short) (nTemp & 0xff);
            m_Engine.m_wCurrEnd = (short) (m_Engine.m_nCurrUnit + sizeofSIMULUNIT +
                    nTemp*sizeofSIMULPOINT);
        }

        if (IsStopOfSimul( (short) nTemp)) {
            m_Engine.m_wCurrLimit = wCurrLimitStored;
            m_Engine.m_nCurrUnit = pnCurrUnitStored;
            return -8;
        }

        pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;

        while (true) {
//		cStatus = PlayStnAndSimulInFirst(pSimulPt);
            wPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
            // 421=0x1af -> &0x1ff
            pnChildUnit = m_Engine.m_wCurrEnd;

            m_Engine.m_pTempArea[pnChildUnit] = (short) (m_Engine.m_nCurrUnit & 0xff);
            m_Engine.m_pTempArea[pnChildUnit + 1] = (short) ( (m_Engine.m_nCurrUnit >> 8) & 0xff);
            m_Engine.m_pTempArea[pnSimulPt + 2] = (short) (pnChildUnit & 0xff);
            m_Engine.m_pTempArea[pnSimulPt + 3] = (short) ( (pnChildUnit >> 8) & 0xff);
            InitGoodTimes();

            if (wPoint == (short) m_Engine.m_nPaePos) {
                m_Engine.m_pTempArea[pnChildUnit + 2] = -2;
                m_Engine.m_pTempArea[pnChildUnit + 3] = 0;
                m_Engine.m_pTempArea[pnChildUnit + 4] = 0;
                m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
                m_Engine.m_cGoodTimes[wPoint & 0xffff]--;
            } else if ( (j = PlaySimulStone(wPoint)) != 0) {
                if (j == 1)
                    m_Engine.m_pTempArea[pnChildUnit + 2] = -1;
                else
                    m_Engine.m_pTempArea[pnChildUnit + 2] = -6;
                m_Engine.m_pTempArea[pnChildUnit + 3] = 0;
                m_Engine.m_pTempArea[pnChildUnit + 4] = 0;
                m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
                m_Engine.m_cGoodTimes[wPoint & 0xffff]--;
            } else {
                if ((m_Engine.m_byLiberties[m_Engine.m_byStrNum] & 0xff) < 2)
                    m_Engine.m_pTempArea[pnChildUnit + 2] = CallReflexRoutine(SIMUL_INFIRST_ONESEP);
                else
                    m_Engine.m_pTempArea[pnChildUnit + 2] = CallReflexRoutine(SIMUL_INFIRST_MANYSEP);

                if (m_Engine.m_pTempArea[pnChildUnit + 2] < 0)
                    m_Engine.m_cGoodTimes[wPoint & 0xffff]--;
                else
                    m_Engine.m_cGoodTimes[wPoint & 0xffff]++;
                RecoverBoard(pnChildUnit);
                m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4]++;
            }

            nTemp--;
            pnSimulPt += sizeofSIMULPOINT;
            if ( (m_Engine.m_pTempArea[pnChildUnit + 2] == 1) || (nTemp <= 0) ||
                    (AssignMemory( (short) nTemp) == 0))
                break;
        }
        cStatus = GetUnitStatus();

        m_Engine.m_wCurrLimit = wCurrLimitStored;
        m_Engine.m_nCurrUnit = pnCurrUnitStored;
//        } catch (Exception e) {
//            System.out.println("SimulInSecondOfMSStr");
//        }
        return cStatus;
    }

    void OneSEP(short wPoint) {
        short wPaePos;

        if (m_Engine.m_cInfo == 0) {
            RegInFirstPlace(wPoint);
            return;
        }
        if (wPoint == (short) m_Engine.m_nPaePos) {
            RegInLastPlace(wPoint);
            return;
        }

        wPaePos = m_Engine.m_nPaePos;
        m_Engine.m_nBoardPos = wPoint;
        SetTestStone(m_Engine.m_byColor);
        m_Engine.m_nPaePos = wPaePos;

        if ((m_Engine.m_byNewLiberties & 0xff) > 1)
            RegInFirstPlace(wPoint);
    }

    void TwoSEPs() {
        short wPoint1, wPoint2;
        wPoint1 = m_Engine.m_wEmptyPoint[1];
        wPoint2 = m_Engine.m_wEmptyPoint[0];
        if ((m_Engine.m_byPosBoard[wPoint1 & 0xffff] & 0xff) >= 3) {
            if ((m_Engine.m_byPosBoard[wPoint2 & 0xffff] & 0xff) < 3) {
                wPoint1 = m_Engine.m_wEmptyPoint[0];
                wPoint2 = m_Engine.m_wEmptyPoint[1];
            }
        }
        OneSEP(wPoint1);
        OneSEP(wPoint2);
    }

    boolean TwoSEPOppStrNearby(short wPoint) {
        short i;
        byte byStr;

        for (i = 0; i < 4; i++) {
            byStr = m_Engine.m_byBoard[(wPoint & 0xffff) + m_Engine.nNeighbor[i]];
            if ( (byStr != 0) && (byStr != INITVALUE)) {
                if ( (m_Engine.m_byLiberties[byStr & 0xff] == 2) &&
                        (((byStr ^ (byte)m_Engine.m_byStrNum) & 1)) != 0)
                    return true;
            }
        }
        return false;
    }

    void RegPtsOnOSPerisInSecond() {
        byte byStr;
        short wPaePos;
        short wEmptyPt[] = {0};
        short nOneLibStrs = m_Engine.m_nOneLibStrs;
        int i, j;

        MEMCPY(m_Engine.m_byTemp, m_Engine.m_byPeriStr, m_Engine.m_byPeriStr.length);
        wPaePos = m_Engine.m_nPaePos;

        for (i = nOneLibStrs - 1; i >= 0; i--) {
            byStr = m_Engine.m_byTemp[i];
            GetLibs(byStr, wEmptyPt);
            m_Engine.m_nBoardPos = wEmptyPt[0];
            m_Engine.m_nPaePos = 0;
            SetTestStone(m_Engine.m_byColor);

            if ((m_Engine.m_byNewLiberties & 0xFF) > 1) {
                if ( (m_Engine.m_wStatus[byStr & 0xFF] & 0x0008) == 0)
                    RegInFirstPlace(wEmptyPt[0]);
                else
                    RegInLastPlace(wEmptyPt[0]);
            }

            GetPeriStrs(byStr, (short) 1);
            if (m_Engine.m_nOneLibStrs == 0)
                continue;

            for (j = m_Engine.m_nOneLibStrs - 1; j >= 0; j--) {
                GetLibs(m_Engine.m_byPeriStr[j], wEmptyPt);
                RegInFirstPlace(wEmptyPt[0]);
            }
        }

        m_Engine.m_nPaePos = wPaePos;
        m_Engine.m_nOneLibStrs = nOneLibStrs;
        MEMCPY(m_Engine.m_byPeriStr, m_Engine.m_byTemp, m_Engine.m_byPeriStr.length);
    }

    void RestorStrDatas(short nPlace) {
        if (nPlace == PARENT_BACKUP) {
            m_Engine.m_nPaePos = m_Engine.m_nTempPaePos;
            m_Engine.m_nDeadStoneCount = m_Engine.m_nTempDeadStoneCount;
            MEMCPY(m_Engine.m_byBoard, m_Engine.m_byTempBoard, m_Engine.m_byBoard.length);
            MEMCPY(m_Engine.m_byLiberties, m_Engine.m_byTempLiberties, m_Engine.m_byLiberties.length);
            MEMCPY(m_Engine.m_nStoneCount, m_Engine.m_nTempStoneCount, m_Engine.m_nStoneCount.length);
            MEMCPY(m_Engine.m_wStatus, m_Engine.m_wTempStatus, m_Engine.m_wStatus.length);
        } else {
            m_Engine.m_nPaePos = m_Engine.m_wBackPaePos;
            m_Engine.m_nDeadStoneCount = m_Engine.m_nBackDeadStoneCount;
            MEMCPY(m_Engine.m_byBoard, m_Engine.m_byBackBoard, m_Engine.m_byBoard.length);
            MEMCPY(m_Engine.m_byLiberties, m_Engine.m_byBackLibs, m_Engine.m_byLiberties.length);
            MEMCPY(m_Engine.m_nStoneCount, m_Engine.m_nBackStns, m_Engine.m_nStoneCount.length);
            MEMCPY(m_Engine.m_wStatus, m_Engine.m_wBackStatus, m_Engine.m_wStatus.length);
        }
    }

    void PrepareOnOutCall() {
        BackupStrDatas(CHILD_BACKUP);
        m_Engine.m_nOutCall = 1;
        m_Engine.m_nReflexMax = 1;
        m_Engine.m_nMaxDepth = 4;

        m_Engine.m_wCurrEnd = 0;
        PrepareSet( (byte) 0);
    }

    void GetTwoPoints(short wEmptyPt, short[] wFirstPt, short[] wSecondPt, int index) {
        byte byColor;
        short wPaePos;
        int pnSimulPt;
        short n;
        short wPoint, wChildUnit;

        wFirstPt[index] = 0;
        if (wEmptyPt == (short) m_Engine.m_nPaePos)
            return;

        byColor = ( (m_Engine.m_byStrNum & 1) != 0) ? IS_BLACK : IS_WHITE;
        wPaePos = m_Engine.m_nPaePos;

        m_Engine.m_nBoardPos = wEmptyPt;
        SetTestStone(byColor);
        m_Engine.m_nPaePos = wPaePos;

        if ( ((m_Engine.m_byNewLiberties & 0xFF) <= 0) ||
                ( (m_Engine.m_byNewLiberties == 1) && (m_Engine.m_nDeadStoneCount != 1)) ||
                (m_Engine.m_nDCount == 1))
            return;

        pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        n = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4];

        while (n > 0) {
            wPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xffff) << 8) |
                    (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
            if (wPoint == wEmptyPt)
                break;
            n--;
            pnSimulPt += sizeofSIMULPOINT;
        }
        if (n <= 0)
            return;

        wChildUnit = (short) (((m_Engine.m_pTempArea[pnSimulPt + 3] & 0xffff) << 8) |
                (m_Engine.m_pTempArea[pnSimulPt + 2] & 0xff));
        wPoint = (short) (((m_Engine.m_pTempArea[wChildUnit + sizeofSIMULUNIT + 1] & 0xffff) << 8) |
                (m_Engine.m_pTempArea[wChildUnit + sizeofSIMULUNIT] & 0xff));

        wFirstPt[index] = wEmptyPt;
        wSecondPt[index] = wPoint;
        return;
    }

    short AnotherInStrChain(short wPoint, byte byColor) {
        byte byStr;
        short wTempPoint, wEmptyPt[] = new short[2];
        short wPaePos = m_Engine.m_nPaePos;
        short byStrNumStored = m_Engine.m_byStrNum;

        short wCurrPoint[] = {wPoint};
        short wPrePoint = 0;

        m_Engine.m_byStrNum = 0;
        m_Engine.m_nSCount--;
        while (m_Engine.m_nSCount >= 0) {
            byStr = m_Engine.m_bySameBuf[m_Engine.m_nSCount];
            if ( ((byStr & 0xff) == m_Engine.m_byStrNum) ||
                    (m_Engine.m_byLiberties[byStr & 0xFF] != 2)) {
                m_Engine.m_nSCount--;
                continue;
            }

            if (GetPeriStrs(byStr, (short) 1) > 0) {
                GetLibs(m_Engine.m_byPeriStr[0], wCurrPoint);
                break;
            }

            GetLibs(byStr, wEmptyPt);
            if (wEmptyPt[0] == wCurrPoint[0])
                wTempPoint = wEmptyPt[1];
            else
                wTempPoint = wEmptyPt[0];
            if (wTempPoint == wPrePoint) {
                m_Engine.m_nSCount = -1;
                break;
            }

            m_Engine.m_byStrNum = (short)(byStr & 0xff);
            wPrePoint = wCurrPoint[0];
            wCurrPoint[0] = wTempPoint;

            m_Engine.m_nBoardPos = wCurrPoint[0];
            SetTestStone(byColor);
            if ((m_Engine.m_byNewLiberties & 0xFF) < 2) {
                m_Engine.m_nSCount = -1;
                break;
            }
            if ((m_Engine.m_byNewLiberties & 0xFF) > 2)
                break;
            m_Engine.m_nSCount--;
        }

        m_Engine.m_nPaePos = wPaePos;
        m_Engine.m_byStrNum = byStrNumStored;
        if (m_Engine.m_nSCount < 0)
            return 0;
        return wCurrPoint[0];
    }

    void SetTestStone(byte byStoneColor) {
        short nCount, i, i0, j, k, m;
        short wStatus[] = {0};
        byte byAround, byStr, byTemp, byStringBuf[] = new byte[4];

        m_Engine.m_nSCount = 0;
        m_Engine.m_nDCount = 0;
        m_Engine.m_byNewLiberties = 0;
        m_Engine.m_byNewStringNumber = 0;

        if (m_Engine.m_nPaePos == m_Engine.m_nBoardPos)
            return;

        m_Engine.m_byStoneColor = byStoneColor;

        wStatus[0] = m_Engine.m_byStoneColor;
        byAround = 0;

        m_Engine.m_nBoardPos -= 20;
        if (LookAbout(wStatus)) {
            byAround |= UP_MASK;
            m_Engine.m_byNewLiberties++;
        }

        m_Engine.m_nBoardPos += 40;
        if (LookAbout(wStatus)) {
            byAround |= DOWN_MASK;
            m_Engine.m_byNewLiberties++;
        }

        m_Engine.m_nBoardPos -= 21;
        if (LookAbout(wStatus)) {
            byAround |= LEFT_MASK;
            m_Engine.m_byNewLiberties++;
        }

        m_Engine.m_nBoardPos += 2;
        if (LookAbout(wStatus)) {
            byAround |= RIGHT_MASK;
            m_Engine.m_byNewLiberties++;
        }

        m_Engine.m_nBoardPos--;
        m_Engine.m_nDeadStoneCount = 0;
        i = m_Engine.m_nDCount;

        while (i > 0) {
            i--;
            byStr = m_Engine.m_byDifferBuf[i];
            if (m_Engine.m_byDifferLiberties[i] != 0)
                continue;

            for (j = STARTPOS; j < ENDPOS; j++) {
                if (m_Engine.m_byBoard[j] == byStr) {
                    m_Engine.m_nPaePos = j;
                    m_Engine.m_nDeadStoneCount++;

                    for (i0 = 0, k = 0; k < 4; k++) {
                        byTemp = m_Engine.m_byBoard[j + m_Engine.nNeighbor[k]];
                        if ( (byTemp == INITVALUE) || (byTemp == 0) || (byTemp == byStr))
                            continue;

                        for (m = 0; m < m_Engine.m_nSCount; m++) {
                            if (m_Engine.m_bySameBuf[m] == byTemp)
                                break;
                        }
                        if (m < m_Engine.m_nSCount) {
                            for (nCount = 0; nCount < i0; nCount++) {
                                if (byStringBuf[nCount] == byTemp)
                                    break;
                            }
                            if (nCount == i0) {
                                byStringBuf[i0] = byTemp;
                                i0++;
                                m_Engine.m_bySameLiberties[m]++;
                            }
                        }
                    }
                }
            }
        }

        if (m_Engine.m_nSCount == 0) {
            if (m_Engine.m_nDeadStoneCount != 1)
                m_Engine.m_nPaePos = 0;
            if (m_Engine.m_byNewLiberties != 0) {
                if (m_Engine.m_byNewLiberties != 1)
                    m_Engine.m_nPaePos = 0;
                byStr = m_Engine.m_byStoneColor;

                while (true) {
                    if ((byStr & 0xff) >= MAX_STRINGCOUNT)
                        return;
                    if (m_Engine.m_byLiberties[byStr & 0xFF] == 0)
                        break;
                    byStr += 2;
                }
                m_Engine.m_byNewStringNumber = byStr;
            }
            return;
        }

        m_Engine.m_nPaePos = 0;
        if (m_Engine.m_nSCount == 1) {
            byStr = m_Engine.m_bySameBuf[0];
            m_Engine.m_byNewLiberties += m_Engine.m_bySameLiberties[0] - 1;

            if (m_Engine.m_byNewLiberties == 0)
                return;
            if ( (byAround & UP_MASK) != 0) {
                if (IsSameStringg( (short) (m_Engine.m_nBoardPos - 20), byStr))
                    m_Engine.m_byNewLiberties--;
            }
            if ( (byAround & DOWN_MASK) != 0) {
                if (IsSameStringg( (short) (m_Engine.m_nBoardPos + 20), byStr))
                    m_Engine.m_byNewLiberties--;
            }
            if ( (byAround & LEFT_MASK) != 0) {
                if (IsSameStringg( (short) (m_Engine.m_nBoardPos - 1), byStr))
                    m_Engine.m_byNewLiberties--;
            }
            if ( (byAround & RIGHT_MASK) != 0) {
                if (IsSameStringg( (short) (m_Engine.m_nBoardPos + 1), byStr))
                    m_Engine.m_byNewLiberties--;
            }
            m_Engine.m_byNewStringNumber = byStr;
            return;
        }

        for (i = 0; i < m_Engine.m_nSCount; i++)
            m_Engine.m_byNewLiberties += (m_Engine.m_bySameLiberties[i] - 1);

        if (m_Engine.m_byNewLiberties == 0)
            return;

        m_Engine.m_byNewStringNumber = m_Engine.m_bySameBuf[0];
        m_Engine.m_byNewLiberties = 0;
        m_Engine.m_byBoard[m_Engine.m_nBoardPos] = m_Engine.m_byNewStringNumber;

        for (j = STARTPOS; j < ENDPOS; j++) {
            byStr = m_Engine.m_byBoard[j];
            if (byStr == 0) {
                for (i = 0; i < m_Engine.m_nSCount; i++) {
                    if (IsSameStringg(j, m_Engine.m_bySameBuf[i])) {
                        m_Engine.m_byNewLiberties++;
                        break;
                    }
                }
                continue;
            }
            if ( (byStr == INITVALUE) || (m_Engine.m_nDeadStoneCount == 0) ||
                    (byStr == m_Engine.m_byStoneColor))
                continue;

            i = (short) (m_Engine.m_nDCount - 1);
            while ( (i >= 0) && (byStr != m_Engine.m_byDifferBuf[i]))
                i--;
            if ( (i < 0) || (m_Engine.m_byDifferLiberties[i] != 0))
                continue;

            for (i = 0; i < m_Engine.m_nSCount; i++) {
                if (IsSameStringg(j, m_Engine.m_bySameBuf[i])) {
                    m_Engine.m_byNewLiberties++;
                    break;
                }
            }
        }
        m_Engine.m_byBoard[m_Engine.m_nBoardPos] = 0;
        return;
    }

    short GetScoreOfLying() {
        short nDifOfTerr;
        short nMyScore;

        m_Engine.m_byTurnColor ^= 3;
        m_Engine.m_nBoardPos = m_Engine.m_nPos2;
        m_Engine.m_nScoreBase = m_Engine.m_nDeadStoneCount;
        if (SetStone2(m_Engine.m_byTurnColor) < 0) {
            m_Engine.m_byTurnColor ^= 3;
            return -1;
        }
        m_Engine.m_byNewStringNumber = (byte) 0xff;
        OldBoardScoreCalc();

        nDifOfTerr = m_Engine.m_nDifOfTerritory;
        m_Engine.m_byTurnColor ^= 3;
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        if (nDifOfTerr <= 0)
            return m_Engine.m_nIniScore;
        if (nDifOfTerr <= m_Engine.m_nNewTerritory) {
            nDifOfTerr = (short) (m_Engine.m_nNewTerritory - nDifOfTerr);
            m_Engine.m_nDeadStoneCount = (short) (m_Engine.m_nScoreBase - m_Engine.m_nDeadStoneCount);
            nMyScore = ResultGain(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase, nDifOfTerr);
            if (nMyScore < 0)
                return nMyScore;
            //return (0x80000000 | min(m_Engine.m_nIniScore,nMyScore * 3/2));
            return (short) (0x8000 | Math.min(m_Engine.m_nIniScore, nMyScore * 3 / 2));
        }
        return (short) (m_Engine.m_nNewTerritory - nDifOfTerr);
    }

    byte SimulInFirstOnOutCall(byte byStr) {
        short nLibs;
        byte cStatus;

        m_Engine.m_nBoardPos = 0;
        m_Engine.m_byStrNum = (short)(byStr & 0xff);
        m_Engine.m_byColor = ( (byStr & 1) != 0) ? IS_WHITE : IS_BLACK;

        nLibs = (short) (m_Engine.m_byLiberties[byStr & 0xFF] & 0xFF);
        if (nLibs < 1)
            return -1;
        if (nLibs > 3)
            return 1;

        PrepareOnOutCall();

        if (nLibs == 1)
            cStatus = SimulInFirstOfOSStr();
        else
            cStatus = SimulInFirstOfMSStr();

        RestorStrDatas(CHILD_BACKUP);

        if (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 4] > 0) {

            m_Engine.m_nBoardPos =
                    (short) (((m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT + 1] & 0xffff) << 8) |
                            (m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + sizeofSIMULUNIT] & 0xff));
        } else
            m_Engine.m_nBoardPos = 0;
        return cStatus;
    }

    byte SimulInFirstOfOSStr() {
        byte cStatus;
        short nTemp, nRegs;
        int pnSimulPt;

        m_Engine.m_nCurrUnit = m_Engine.m_wCurrEnd;
        m_Engine.m_wCurrLimit = m_Engine.m_wAssignLimit;

        GetLibs(m_Engine.m_byStrNum, m_Engine.m_wEmptyPoint);

        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 2] = 0;
        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 3] = 1;
        m_Engine.m_pTempArea[m_Engine.m_wCurrEnd + 4] = 0;
        m_Engine.m_wCurrEnd += sizeofSIMULUNIT;

        pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;
        m_Engine.m_pTempArea[pnSimulPt] = (short) (m_Engine.m_wEmptyPoint[0] & 0xff);
        m_Engine.m_pTempArea[pnSimulPt + 1] = (short) ( ((m_Engine.m_wEmptyPoint[0] & 0xFFFF) >> 8) & 0xff);
        m_Engine.m_pTempArea[pnSimulPt + 2] = 0;
        m_Engine.m_pTempArea[pnSimulPt + 3] = 0;
        m_Engine.m_wCurrEnd += sizeofSIMULPOINT;

        if (GetPeriStrs(m_Engine.m_byStrNum, (short) 1) > 0)
            RegPtsOnOSPerisInFirst();

        nRegs = (short) m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3];
        if (nRegs > 1) {
            m_Engine.m_nScoredPoints = 0;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = 0;
            m_Engine.m_wCurrEnd = (short) pnSimulPt;
            while (nRegs > 0) {
                short wPoint;
                wPoint = (short) (((m_Engine.m_pTempArea[pnSimulPt + 1] & 0xFFFF) << 8) |
                        (m_Engine.m_pTempArea[pnSimulPt] & 0xff));
                ScoreAndArrInManyDepth(wPoint);
                nRegs--;
                pnSimulPt += sizeofSIMULPOINT;
            }
        }
        FixupCandis();

        nRegs = m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3];
        if (nRegs == 0) {
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = -1;
            return -1;
        }
        if (nRegs > m_Engine.m_nMaxSimulPoints) {
            nRegs = m_Engine.m_nMaxSimulPoints;
            m_Engine.m_pTempArea[m_Engine.m_nCurrUnit + 3] = (short) (nRegs & 0xff);
            m_Engine.m_wCurrEnd = (short) (m_Engine.m_nCurrUnit + sizeofSIMULUNIT +
                    nRegs*sizeofSIMULPOINT);
        }

        if (IsStopOfSimul(nRegs))
            return -8;

        nTemp = m_Engine.m_nLibsLimit;
        pnSimulPt = m_Engine.m_nCurrUnit + sizeofSIMULUNIT;

        while (true) {
            PlayStnAndSimulInSecond(pnSimulPt);
            m_Engine.m_nLibsLimit = nTemp;
            nRegs--;
            pnSimulPt += sizeofSIMULPOINT;
            if ( (nRegs == 0) || (AssignMemory(nRegs) == 0))
                break;
        }
        cStatus = GetUnitStatus();

        return cStatus;
    }

    short GetPosOnOneSEP() {
        short nSCount;
        byte byStrNum;
        short nMyScore[] = {0};
        short nPos;
        boolean bEnable;

        if (m_Engine.m_nPaePos != 0)
            return 0;
        nSCount = m_Engine.m_nSCount;
        byStrNum = m_Engine.m_byNewStringNumber;

        m_Engine.m_wStatus[byStrNum & 0xFF] = 0x01ff;
        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        if (m_Engine.m_nScoreBase > -2) {
            m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
            if (m_Engine.m_nIniScore > -2) {
                short[] temp = {m_Engine.m_nPos2};
                GetEmptyPos(byStrNum, (short) 1, temp);
                m_Engine.m_nPos2 = temp[0];

                m_Engine.m_nBoardPos = m_Engine.m_nPos2;
                bEnable = IsEnableTo(nMyScore);
                m_Engine.m_nBoardPos = m_Engine.m_nPos1;
                if (bEnable && (nMyScore[0] >= 0)) {
                    if (nMyScore[0] == 0)
                        return 0;
                    m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 2;
                    return 0;
                }
            }
        }
        LoadData();
        nPos = m_Engine.m_nBoardPos;
        if (nSCount == 0)
            nPos = AnotherInNeighbors(nPos, m_Engine.m_byTurnColor);
        else
            nPos = AnotherInMyStrChain(byStrNum, nPos);

        if (nPos == 0)
            return 0;
        if ( (nPos & 0x8000) != 0)
            return (short) (nPos & 0x7fff);
        if (nSCount != 0)
            return nPos;
        return 0;
    }

    short AnotherInNeighbors(short wPoint, byte byColor) {
        short wPos = 0;
        short i;

        for (i = 0; i < 4; i++) {
            wPos = (short) ((wPoint & 0xFFFF) + m_Engine.nNeighbor[i]);
            if (m_Engine.m_byBoard[wPos & 0xFFFF] == 0)
                break;
        }
        if (i >= 4)
            return 0;

        m_Engine.m_nBoardPos = wPos;
        wPos = m_Engine.m_nPaePos;
        SetTestStone(byColor);
        m_Engine.m_nPaePos = wPos;

        if ((m_Engine.m_byNewLiberties & 0xFF) <= 2)
            return 0;

        SetTestStone( (byte) (byColor ^ 3));
        m_Engine.m_nPaePos = wPos;

        if ( (m_Engine.m_nSCount == 0) && (m_Engine.m_byNewLiberties == 1))
            return (short) (wPos | 0x8000);
        return wPos;
    }

    short AnotherInMyStrChain(byte byStrNum, short wPoint) {
        short nLibs = (short) (m_Engine.m_byLiberties[byStrNum & 0xFF] & 0xFF);
        byte byColor;

        byte byStr;
        short wTempPoint, wEmptyPt[] = new short[2];
        short wPaePos = m_Engine.m_nPaePos;
        short byStrNumStored = m_Engine.m_byStrNum;

        short wCurrPoint[] = {wPoint};
        short wPrePoint = 0;
        m_Engine.m_nPaePos = 0;
        m_Engine.m_byStrNum = 0;

        byColor = ( (byStrNum & 1) != 0) ? IS_WHITE : IS_BLACK;

        if (nLibs < 2)
            return 0;
        m_Engine.m_byLiberties[byStrNum & 0xFF] = 2;

        m_Engine.m_nSCount = 0;
        m_Engine.m_bySameBuf[0] = byStrNum;

        while (m_Engine.m_nSCount >= 0) {
            byStr = m_Engine.m_bySameBuf[m_Engine.m_nSCount];
            if (((byStr & 0xff) == m_Engine.m_byStrNum) || (m_Engine.m_byLiberties[byStr & 0xFF] != 2)) {
                m_Engine.m_nSCount--;
                continue;
            }

            if (GetPeriStrs(byStr, (short) 1) > 0) {
                GetLibs(m_Engine.m_byPeriStr[0], wCurrPoint);
                break;
            }

            GetLibs(byStr, wEmptyPt);
            if (wEmptyPt[0] == wCurrPoint[0])
                wTempPoint = wEmptyPt[1];
            else
                wTempPoint = wEmptyPt[0];
            if (wTempPoint == wPrePoint) {
                m_Engine.m_nSCount = -1;
                break;
            }

            m_Engine.m_byStrNum = (short)(byStr & 0xff);
            wPrePoint = wCurrPoint[0];
            wCurrPoint[0] = wTempPoint;

            m_Engine.m_nBoardPos = wCurrPoint[0];
            SetTestStone(byColor);
            if ((m_Engine.m_byNewLiberties & 0xFF) < 2) {
                m_Engine.m_nSCount = -1;
                break;
            }
            if ((m_Engine.m_byNewLiberties & 0xFF) > 2)
                break;
            m_Engine.m_nSCount--;
        }

        m_Engine.m_nPaePos = wPaePos;
        m_Engine.m_byStrNum = byStrNumStored;
        m_Engine.m_byLiberties[byStrNum & 0xFF] = (byte) nLibs;
        if (m_Engine.m_nSCount < 0)
            return 0;
        return wCurrPoint[0];
    }

    void ResetTempArea() {
        short i;

        for (i = STARTPOS; i < ENDPOS; i++)
            if (m_Engine.byStandardBoard[i] == 0)
                m_Engine.m_cAreaBoard[i] = 0;
    }

    void GetMainScoreOfTest() {
        short nBlackScore[] = {m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos]};
        short nWhiteScore[] = {m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos]};

        short nTemp;

        m_Engine.m_byWhereCall = (byte) PS_POS;
        if (!GetScoreOfTest(BLACK, nBlackScore, nWhiteScore)) {
            nBlackScore[0] = -1;
            nWhiteScore[0] = -1;
        } else {
            nTemp = nBlackScore[0];
            if (!GetScoreOfTest(WHITE, nWhiteScore, nBlackScore)) {
                nBlackScore[0] = -1;
                nWhiteScore[0] = -1;
            } else
                nBlackScore[0] = nTemp;
        }
        m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = nBlackScore[0];
        m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = nWhiteScore[0];

        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] ^= 0x10;
    }

    boolean GetScoreOfTest(short nColor, short[] pnMyScore, short[] pnYouScore) {
        byte byBitControl;
        byte byStrNum;
        byte cSecondSimul;

        m_Engine.m_byWhereCall = (byte) PS_POS;
        m_Engine.m_byTurnColor = (byte) nColor;
        m_Engine.m_nPos1 = m_Engine.m_nBoardPos;
        m_Engine.m_nPos2 = m_Engine.m_nPos3 = 0;
        m_Engine.m_nOldDeadCount = 0;

        if (m_Engine.m_nPos1 == m_Engine.m_nPaePos)
            return false;

        byBitControl = (byte) m_Engine.m_lBitBoard[m_Engine.m_nBoardPos];

        if ( ( (byBitControl & 0x0c) != 0) && ( (byBitControl & 0x0c) != 0x0c) &&
                //H.Joon-2007/03/07>>
                //( (byBitControl & 0x0c) >> 2 != nColor))
                ( (byBitControl & 0x0c) >>> 2 != nColor))
            //<<
            return true;

        if (SetStone2( (byte) nColor) < 0) {
            LoadData();
            return false;
        }
        ;

        if ( ((m_Engine.m_byNewLiberties & 0xFF) <= 1) ||
                ((m_Engine.m_byNewLiberties & 0xFF) >= 4) ||
                ( (m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xFF] & 0x08) != 0) ||
                (IfDeadByGroup(m_Engine.m_byNewStringNumber, m_Engine.m_nBoardPos))) {
            if ( (m_Engine.m_byNewLiberties == 1) && (pnYouScore[0] == -2) && (pnMyScore[0] > 0))
                pnMyScore[0] = 1;
            ResetTempArea();
            LoadData();
            return true;
        }

        byStrNum = m_Engine.m_byNewStringNumber;

        cSecondSimul = SpecialSimulOnOutCall(byStrNum, m_Engine.m_nPos1);

        m_Engine.m_nPos2 = m_Engine.m_nBoardPos;

        if (cSecondSimul != 0) {
            if (cSecondSimul < 0) {
                m_Engine.m_nBoardPos = m_Engine.m_nPos1;
                LoadData();
                if (cSecondSimul != -1) {
                    pnMyScore[0] -= (pnMyScore[0]) / 4;
                    pnYouScore[0] -= (pnYouScore[0]) / 4;
                }
                return true;
            }
            byStrNum = cSecondSimul;
        }
        KillString(byStrNum);
        m_Engine.m_nBoardPos = m_Engine.m_nPos2;
        m_Engine.m_byNewStringNumber = (byte) 0xff;
        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        if (m_Engine.m_nScoreBase > 0)
            m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
        else
            m_Engine.m_nIniScore = m_Engine.m_nScoreBase;
        if (m_Engine.m_nIniScore < 0)
            pnMyScore[0] = m_Engine.m_nIniScore;
        else
            pnMyScore[0] = (short) Math.min(m_Engine.m_nIniScore, GetScoreOfLying());
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        LoadData();
        return true;
    }

    boolean FindSameGrpAround(byte byGrpNum) {
        if ( (m_Engine.m_nMainPosition >= 41) &&
                (byGrpNum == m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition - 20]))
            return true;
        if ( (m_Engine.m_nMainPosition < ENDPOS - 20) &&
                (byGrpNum == m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition + 20]))
            return true;
        if ( (m_Engine.m_byBoard[m_Engine.m_nMainPosition - 1] != -16) &&
                (byGrpNum == m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition - 1]))
            return true;
        if ( (m_Engine.m_byBoard[m_Engine.m_nMainPosition + 1] != -16) &&
                (byGrpNum == m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition + 1]))
            return true;
        return false;
    }

    void StringAndWeightMove() {
        MEMCPY(m_Engine.m_wCorrectStatus, m_Engine.m_wStatus, m_Engine.m_wStatus.length);
        MEMCPY(m_Engine.m_nCorrectWeight, m_Engine.m_cWeightBoard, m_Engine.m_cWeightBoard.length);
        return;
    }

    void ExpressOfGroup() {
        byte byChangeWeight0[] = {0};
        short nSortOfCase[] = {0};
        short t;
        byte byChangeWeight;
        byte byGrpNumber;
        byte byGrpLNumber;
        byte TempAH;

        if (!SortOfWeight(byChangeWeight0, nSortOfCase))
            return;

        byChangeWeight = byChangeWeight0[0];

        if (m_Engine.m_nMainPosition < 40)
            byGrpNumber = -1;
        else
            byGrpNumber = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition - 20];

        if (IsNotEqualGroup(byGrpNumber, nSortOfCase[0])) {
            byGrpLNumber = byGrpNumber;

            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition - 1] == -16)
                byGrpNumber = -1;
            else
                byGrpNumber = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition - 1];

            if (!IsNotEqualGroup(byGrpNumber, nSortOfCase[0]))
                GroupContactStatus(byGrpNumber, byGrpLNumber);
            else {
                short i = (short) ( ( (nSortOfCase[0] & 1) != 0) ? 1 : 2);

                while (m_Engine.m_stGroup[i].nSituation != 0)
                    i += 2;
                if (i >= 50)
                {
                    i -= 40; // Case Of Err	//upversion
                    return;//New Addition
                }
                m_Engine.m_nTotalGroupCount = (short) Math.max(m_Engine.m_nTotalGroupCount, i);
                GroupContactStatus( (byte) i, byGrpNumber);
                GroupContactStatus( (byte) i, byGrpLNumber);
                byGrpNumber = (byte) i;
            }
        } else {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition - 1] == -16)
                byGrpLNumber = -1;
            else
                byGrpLNumber = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition - 1];
            if ( ( (byte) byGrpLNumber > 0) && (byGrpLNumber != byGrpNumber)) {

                if ( ( (byGrpLNumber ^ byGrpNumber) & 1) == 0) {
                    if (byGrpNumber >= byGrpLNumber) {
                        byte tmp = byGrpNumber;
                        byGrpNumber = byGrpLNumber;
                        byGrpLNumber = tmp;
                    }
                    EqualTwoGroupLink(m_Engine.m_nMainPosition, byGrpNumber, byGrpLNumber);

                } else
                    GroupContactStatus(byGrpNumber, byGrpLNumber);

            }
        }

        m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] = byGrpNumber;
        ActualGroupSizeCalc(byGrpNumber, byChangeWeight);

        if ( (nSortOfCase[0] & 2) == 0) {
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nTotalSize++;
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nSituation = 1;
            return;
        }

        m_Engine.m_stGroup[byGrpNumber & 0xFF].nCompetition++;

        //Function Name " AddToGrpInfo5 "

        if ((byChangeWeight & 0xff) < 9) {
            TempAH = byChangeWeight;
            if ((TempAH & 0xff) >= 4) {
                TempAH -= 4;
                if (TempAH == 0)
                    TempAH = 2;
                t = m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize;
                t += TempAH;
                if (t >= 0xFF)
                    m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0xFF;
                else
                    m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = (short) (t & 0xFF);

            }
        } else {
            TempAH = 2;
            t = m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize;
            t += TempAH;
            if (t >= 0xFF)
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0xFF;
            else
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = (short) (t & 0xFF);

        }
        m_Engine.m_stGroup[byGrpNumber & 0xFF].nSituation = 1;
        return;

    }

    boolean SortOfWeight(byte[] pbyChangeWeight, short[] pnSortOfCase) {

        short wALive, wDead;
        byte byStrNumber;
        wDead = 0x08;
        wALive = 0x800;

        pbyChangeWeight[0] = (byte) m_Engine.m_cWeightBoard[m_Engine.m_nMainPosition];

        byStrNumber = m_Engine.m_byBoard[m_Engine.m_nMainPosition];

        if (byStrNumber != 0) {

            if (!IsWhite(byStrNumber))
                pbyChangeWeight[0] = (byte) - (pbyChangeWeight[0]);

//		In Case Of the Black Stone ,it converts 0 - 0x6 to 0 - 0xfa.

            pnSortOfCase[0] = (short) (byStrNumber & 1);

            if ( (m_Engine.m_wStatus[byStrNumber & 0xFF] & wALive) != 0) {
                pbyChangeWeight[0] += 6;

                if ((pbyChangeWeight[0] & 0xff) > 0x80)
                    pbyChangeWeight[0] = 0;

//		In Case Of the Alive Stone ,it converts 0,0xff,0xfe  to 6,5,4.

            } else {
                if (pbyChangeWeight[0] == (byte) 0xff)
                    pbyChangeWeight[0] = (byte) 0xfd;
                if ( (m_Engine.m_wStatus[byStrNumber & 0xFF] & wDead) == 0) {

                    pbyChangeWeight[0] += 6;

                    if ((pbyChangeWeight[0] & 0xff) > 0x80)
                        pbyChangeWeight[0] = 0;

//		In Case Of the Dead Stone ,it converts 0 - 0xfa  to 6 - 0.

                } else {
                    pbyChangeWeight[0] = (byte) - (pbyChangeWeight[0]);
                    pnSortOfCase[0] = (short) ( (pnSortOfCase[0] == 1) ? 2 : 3);

//		In Case Of 	Alive-Dead Stone , Reversal Value

                }

            }

            return true;
        }

        if ( (pbyChangeWeight[0] == 1) || ( (byte) (pbyChangeWeight[0]) > 3)) {
            if (pbyChangeWeight[0] == 1)
                pbyChangeWeight[0] = 3;

            pnSortOfCase[0] = 3;
            return true;
        }

        else if (pbyChangeWeight[0] == 3) {
            if (IsStoneInFourDir()) {
                pnSortOfCase[0] = 3;
                return true;
            }
            return false;
        }

        else if ( (pbyChangeWeight[0] == (byte) 0xFF) || ( (byte) (pbyChangeWeight[0]) < -3)) {
            if (pbyChangeWeight[0] == (byte) 0xFF)
                pbyChangeWeight[0] = (byte) 0xFD;

            pnSortOfCase[0] = 2;
            pbyChangeWeight[0] = (byte) - pbyChangeWeight[0];
            return true;
        }

        else if (pbyChangeWeight[0] == (byte) 0xFD) {
            if (IsStoneInFourDir()) {
                pnSortOfCase[0] = 2;
                pbyChangeWeight[0] = (byte) - pbyChangeWeight[0];
                return true;
            }
            return false;
        } else
            return false;
    }

    boolean IsStoneInFourDir() {
        short nSurPos, i;

        for (i = 0; i < 4; i++) {
            nSurPos = (short) (m_Engine.m_nMainPosition + m_Engine.m_cAroundTable[i]);

            if (m_Engine.m_byBoard[nSurPos] == -16)
                continue;
            if ((m_Engine.m_byBoard[nSurPos] & 0xFF) > 0)
                return true;
        }
        return false;
    }

    void EqualTwoGroupLink(short nEndPos, byte bySmallGNumber, byte byBigGNumber) {
        short tmp, t, i;
        int des;
        int src;
        int ptr;
        byte bitMask[] = {0};
        int ptr1;
        byte bitMask1[] = {0};

        if (bySmallGNumber == 0)
            return;

        while (true) {
            nEndPos--;

            if (m_Engine.m_byBoard[nEndPos] == -16)
                nEndPos--;

            if (nEndPos < STARTPOS)
                break;

            if (m_Engine.m_byGroupBoard[nEndPos] == byBigGNumber)
                m_Engine.m_byGroupBoard[nEndPos] = bySmallGNumber;
        }

        m_Engine.m_stGroup[bySmallGNumber & 0xFF].nTotalSize +=
                m_Engine.m_stGroup[byBigGNumber & 0xFF].nTotalSize;
        tmp = (short) (m_Engine.m_stGroup[bySmallGNumber & 0xFF].nImportance +
                m_Engine.m_stGroup[byBigGNumber & 0xFF].nImportance);

        if (tmp >= 6) {
            m_Engine.m_stGroup[bySmallGNumber & 0xFF].nCompetition++;
            tmp -= 6;
        }

        m_Engine.m_stGroup[bySmallGNumber & 0xFF].nImportance = tmp;

        t = (short) m_Engine.m_stGroup[bySmallGNumber & 0xFF].nCompetition;
        t += (short) m_Engine.m_stGroup[byBigGNumber & 0xFF].nCompetition;

        if (t > 0xFF)
            t = 0xFF;
        m_Engine.m_stGroup[bySmallGNumber & 0xFF].nCompetition = t;

        t = (short) m_Engine.m_stGroup[bySmallGNumber & 0xFF].nHomeSize;
        t += (short) m_Engine.m_stGroup[byBigGNumber & 0xFF].nHomeSize;

        if (t > 0xFF)
            t = 0xFF;

        m_Engine.m_stGroup[bySmallGNumber & 0xFF].nHomeSize = t;

        m_Engine.m_stGroup[byBigGNumber & 0xFF].nTotalSize = 0;
        m_Engine.m_stGroup[byBigGNumber & 0xFF].nImportance = 0;
        m_Engine.m_stGroup[byBigGNumber & 0xFF].nCompetition = 0;
        m_Engine.m_stGroup[byBigGNumber & 0xFF].nSituation = 0;
        m_Engine.m_stGroup[byBigGNumber & 0xFF].nHomeSize = 0;

        des = (bySmallGNumber & 0xFF) * 10; //m_Engine.m_byBitGroupRelInfo
        src = (byBigGNumber & 0xFF) * 10;

        for (i = 0; i < 10; i++) {
            m_Engine.m_byBitGroupRelInfo[des + i] |= m_Engine.m_byBitGroupRelInfo[src + i];
            m_Engine.m_byBitGroupRelInfo[src + i] = 0;
        }

        ptr = GInterRelationAdr( (byte) 1, byBigGNumber, bitMask);

        ptr1 = GInterRelationAdr( (byte) 1, bySmallGNumber, bitMask1);

        for (i = 0; i < m_Engine.m_nTotalGroupCount; i++) {
            if ( (m_Engine.m_byBitGroupRelInfo[ptr] & bitMask[0]) != 0) {
                m_Engine.m_byBitGroupRelInfo[ptr] ^= bitMask[0];
                m_Engine.m_byBitGroupRelInfo[ptr1] |= bitMask1[0];
            }
            ptr += 10;
            ptr1 += 10;
        }

        ptr = GInterRelationAdr(bySmallGNumber, bySmallGNumber, bitMask);
        m_Engine.m_byBitGroupRelInfo[ptr] &= (~bitMask[0]);
    }

    void ActualGroupSizeCalc(byte byGrpNumber, byte byChangeWeight) {
        if ((byChangeWeight & 0xFF) <= 0)
            return;

        if ((byChangeWeight & 0xff) >= 6) {
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nCompetition++;
            return;
        }
//#ifdef UPDATE
//        if (byChangeWeight != 6) { //???
//            if ((byChangeWeight & 0xff) <= 2)
//                return;
//            byChangeWeight -= 2;
//        }
//#endif
        byChangeWeight += (byte) m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance;

        if ((byChangeWeight & 0xff) >= 6) {
            byChangeWeight -= 6;
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nCompetition++;
        }

        m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance = (short) (byChangeWeight & 0xFF);
    }

    boolean IsNotEqualGroup(byte byGrpNumber, short nSortOfCase) {
        if (byGrpNumber <= 0)
            return true;
        if ( (IsWhite(byGrpNumber)) == (IsWhite(nSortOfCase)))
            return false;
        return true;
    }

    void GroupContactStatus(byte byGrpNumber1, byte byGrpNumber2) {
        byte[] Tmp = {0};
        int TmpAdr;

        if (byGrpNumber1 <= 0)
            return;
        if (byGrpNumber2 <= 0)
            return;

        TmpAdr = GInterRelationAdr(byGrpNumber1, byGrpNumber2, Tmp);
        m_Engine.m_byBitGroupRelInfo[TmpAdr] |= Tmp[0];

        TmpAdr = GInterRelationAdr(byGrpNumber2, byGrpNumber1, Tmp);
        m_Engine.m_byBitGroupRelInfo[TmpAdr] |= Tmp[0];
    }

    short GInterRelationAdr(byte byMainGroupNumber, byte byRelGroupNumber, byte[] pbyBitRelationInfo) {
        pbyBitRelationInfo[0] = (byte) (1 << ((byRelGroupNumber & 0xFF) % 8));

        //return m_Engine.m_byBitGroupRelInfo[byMainGroupNumber * 10 + (byRelGroupNumber / 8)];
        return (short)((byMainGroupNumber & 0xFF) * 10 + ((byRelGroupNumber & 0xFF) / 8));
    }

    void LinkableGroupFind() {
        byte byFormerBlackGroup = 0;
        byte byFormerWhiteGroup = 0;

        short nSurGroupCount[] = {0};

        byte bySurrGroupNumber;
        byte byTempGroupNumber = 0;

        int i, j;
        short nSurPos;

        byte Tmp[] = {0};
        int TmpAdr;

        MEMSET(m_Engine.m_bySurGroupNumber, 0);

        out:
        for (i = 0; i < 4; i++) {
            nSurPos = (short) (m_Engine.m_nMainPosition + m_Engine.m_cAroundTable[i]);

            if (m_Engine.m_byBoard[nSurPos] == -16)
                continue;

            if ( (bySurrGroupNumber = m_Engine.m_byGroupBoard[nSurPos]) == 0)
                continue;
            EqualGProc:do {
                if ((m_Engine.m_byBoard[nSurPos] & 0xff) > 0) {
                    if (IsWhite(bySurrGroupNumber)) {
                        byTempGroupNumber = byFormerWhiteGroup;
                        byFormerWhiteGroup = bySurrGroupNumber;

                    } else {
                        byTempGroupNumber = byFormerBlackGroup;
                        byFormerBlackGroup = bySurrGroupNumber;
                    }
                    if (byTempGroupNumber != 0) {

                        if (byTempGroupNumber != bySurrGroupNumber) {

                            if (bySurrGroupNumber > byTempGroupNumber) {
                                //  exchange
                                byte Tempo = byTempGroupNumber;

                                byTempGroupNumber = bySurrGroupNumber;
                                bySurrGroupNumber = Tempo;

                            }
                            if (!IsTwoColorGroup(byTempGroupNumber)) {

                                if (!RecInInterrelG(bySurrGroupNumber,
                                        byTempGroupNumber, nSurGroupCount)) {
                                    if (IsWhite(bySurrGroupNumber))
                                        byFormerWhiteGroup = bySurrGroupNumber;
                                    else
                                        byFormerBlackGroup = bySurrGroupNumber;
                                    continue out;
                                }
                                if ( (byTempGroupNumber == byFormerWhiteGroup) ||
                                        (byTempGroupNumber == byFormerBlackGroup)) {
                                    byte Tempo = byTempGroupNumber;

                                    byTempGroupNumber = bySurrGroupNumber;
                                    bySurrGroupNumber = Tempo;
                                }
                                break EqualGProc;
                            }
                            OtherTwoGroupLink(bySurrGroupNumber, byTempGroupNumber,
                                    nSurGroupCount);
                            if (m_Engine.m_byTotalInterrelCount != 0) {
                                AbsEqInterrel(bySurrGroupNumber, byTempGroupNumber,
                                        nSurGroupCount);
                            }
                            if (IsWhite(bySurrGroupNumber))
                                byFormerWhiteGroup = bySurrGroupNumber;
                            else
                                byFormerBlackGroup = bySurrGroupNumber;
                            continue out;
                        }
                    }
                }
            } while (false); //EqualGProc:

            NextCont:do {
                for (j = nSurGroupCount[0] - 1; j >= 0; j--) {
                    if (m_Engine.m_bySurGroupNumber[j] == bySurrGroupNumber)
                        break NextCont;
                }
                m_Engine.m_bySurGroupNumber[nSurGroupCount[0]] = bySurrGroupNumber;
                if (nSurGroupCount[0] == 0) {
                    nSurGroupCount[0]++;
                    continue out;
                }
                for (j = nSurGroupCount[0] - 1; j >= 0; j--) {
                    byTempGroupNumber = m_Engine.m_bySurGroupNumber[j];

                    TmpAdr = GInterRelationAdr(byTempGroupNumber,
                            bySurrGroupNumber, Tmp);
                    m_Engine.m_byBitGroupRelInfo[TmpAdr] |= Tmp[0];
                    TmpAdr = GInterRelationAdr(bySurrGroupNumber,
                            byTempGroupNumber, Tmp);
                    m_Engine.m_byBitGroupRelInfo[TmpAdr] |= Tmp[0];
                }

                nSurGroupCount[0]++;
            } while (false);

            continue;
        }
    }

    boolean IsTwoColorGroup(byte byTempGroupNumber) {
        byte byLayerInfo = 1;
        byte byPos;
        byte byStrNumber;

        short i;
        short nSurPos;
        byte tp;

        byPos = m_Engine.m_byPosBoard[m_Engine.m_nMainPosition];

        if ((byPos & 0xff) < 2)
            return true;

        for (i = 0; i < 4; i++) {
            nSurPos = (short) (m_Engine.m_nMainPosition + m_Engine.m_cAroundTable[i]);

            if (m_Engine.m_byBoard[nSurPos] == -16)
                continue;

            byStrNumber = m_Engine.m_byBoard[nSurPos];

            if (byStrNumber == 0) {
                tp = byLayerInfo;
                if (--tp >= 0) {
                    byLayerInfo = tp;
                    continue;
                } else
                    return false;
            }

            if ( (IsWhite(byTempGroupNumber)) == (IsWhite(byStrNumber))) {
                if (m_Engine.m_byLiberties[byStrNumber & 0xFF] == 1) { // by KWJ : default;
                    tp = byLayerInfo;
                    if (--tp >= 0) {
                        byLayerInfo = tp;
                        continue;
                    } else
                        return false;
                } else
                    continue;
            }

            if ((m_Engine.m_byLiberties[byStrNumber & 0xFF] & 0xff) > 2) // by KWJ : -> & 0xFF
                return false;

            else
                continue;
        }
        return true;
    }

    boolean RecInInterrelG(byte bySmallGNumber, byte byBigGNumber, short[] nSurGroupCount) {
        int i, k;

        if (m_Engine.m_byTotalInterrelCount == 0) {
            m_Engine.m_byTotalInterrelCount++;

            m_Engine.m_stInterrelGroup[0].byGroupNumber1 = bySmallGNumber;
            m_Engine.m_stInterrelGroup[0].byGroupNumber2 = byBigGNumber;
            m_Engine.m_stInterrelGroup[0].nPos = m_Engine.m_nMainPosition;

            return true;
        }
        for (i = (m_Engine.m_byTotalInterrelCount & 0xff) - 1; i >= 0; i--) {
            if ( (m_Engine.m_stInterrelGroup[i].byGroupNumber1 == bySmallGNumber) &&
                    (m_Engine.m_stInterrelGroup[i].byGroupNumber2 == byBigGNumber)) {
                if (m_Engine.m_stInterrelGroup[i].nPos == m_Engine.m_nMainPosition)
                    return true;

                EqTwoGAndOthTwoC(bySmallGNumber, byBigGNumber, nSurGroupCount, i); //5302
                return false;
            }
        }
        if ((m_Engine.m_byTotalInterrelCount & 0xff) >= 0x20)
            for (k = 0; k < (m_Engine.m_byTotalInterrelCount & 0xff) - 1; k++)
            {
                m_Engine.m_stInterrelGroup[k].copy(m_Engine.m_stInterrelGroup[k + 1]);
            }
        else
            m_Engine.m_byTotalInterrelCount = (byte) (m_Engine.m_byTotalInterrelCount + 1);

        m_Engine.m_stInterrelGroup[(m_Engine.m_byTotalInterrelCount & 0xFF) - 1].byGroupNumber1 = bySmallGNumber;
        m_Engine.m_stInterrelGroup[(m_Engine.m_byTotalInterrelCount & 0xFF) - 1].byGroupNumber2 = byBigGNumber;
        m_Engine.m_stInterrelGroup[(m_Engine.m_byTotalInterrelCount & 0xFF) - 1].nPos = m_Engine.m_nMainPosition;

        return true;
    }

    void EqTwoGAndOthTwoC(byte bySmallGNumber, byte byBigGNumber, short[] nSurGroupCount, int nInterrelI) {
        int i, j, k, nOldPos;

        OtherTwoGroupLink(bySmallGNumber, byBigGNumber, nSurGroupCount);
        if (m_Engine.m_byTotalInterrelCount != 0) {
            m_Engine.m_byTotalInterrelCount = (byte)((m_Engine.m_byTotalInterrelCount & 0xff) - 1);

            for (i = nInterrelI; i < (m_Engine.m_byTotalInterrelCount & 0xff); i++)
                m_Engine.m_stInterrelGroup[i].copy(m_Engine.m_stInterrelGroup[i + 1]);
        } else
            return;
        for (j = (m_Engine.m_byTotalInterrelCount & 0xff) - 1; j >= 0; j--) {
            if ( (m_Engine.m_stInterrelGroup[j].byGroupNumber1 != byBigGNumber) &&
                    (m_Engine.m_stInterrelGroup[j].byGroupNumber2 != byBigGNumber))
                continue;

            if (m_Engine.m_stInterrelGroup[j].byGroupNumber1 == byBigGNumber)
                m_Engine.m_stInterrelGroup[j].byGroupNumber1 = bySmallGNumber;

            else {
                if (m_Engine.m_stInterrelGroup[j].byGroupNumber1 <= bySmallGNumber)
                    m_Engine.m_stInterrelGroup[j].byGroupNumber2 = bySmallGNumber;

                else {
                    m_Engine.m_stInterrelGroup[j].byGroupNumber2 =
                            m_Engine.m_stInterrelGroup[j].byGroupNumber1;
                    m_Engine.m_stInterrelGroup[j].byGroupNumber1 = bySmallGNumber;
                }
            }
            for (k = (m_Engine.m_byTotalInterrelCount & 0xff) - 1; k > j; k--) {
                if ( (m_Engine.m_stInterrelGroup[k].byGroupNumber2 !=
                        m_Engine.m_stInterrelGroup[j].byGroupNumber2) ||
                        (m_Engine.m_stInterrelGroup[k].byGroupNumber1 !=
                                m_Engine.m_stInterrelGroup[j].byGroupNumber1))
                    continue;
                nOldPos = m_Engine.m_stInterrelGroup[k].nPos;

                if (m_Engine.m_byTotalInterrelCount != 0) {
                    m_Engine.m_byTotalInterrelCount--;
                    for (i = k; i < (m_Engine.m_byTotalInterrelCount & 0xFF); i++) // by KWJ : default;
                        m_Engine.m_stInterrelGroup[i].copy(m_Engine.m_stInterrelGroup[i + 1]);
                }
                if (nOldPos != m_Engine.m_stInterrelGroup[j].nPos)
                    EqTwoGAndOthTwoC(m_Engine.m_stInterrelGroup[k].byGroupNumber1,
                            m_Engine.m_stInterrelGroup[k].byGroupNumber2, nSurGroupCount, k);
                break;
            }
        }
        return;
    }

    void OtherTwoGroupLink(byte bySmallGNumber, byte byBigGNumber, short[] nSurGroupCount) {
        int t, i;

        t = (short) m_Engine.m_stGroup[bySmallGNumber & 0xFF].nExtendSize;
        t += (short) m_Engine.m_stGroup[byBigGNumber & 0xFF].nExtendSize;

        if (t > 0xFF)
            t = 0xFF;

        m_Engine.m_stGroup[bySmallGNumber & 0xFF].nExtendSize = (short) t;
        m_Engine.m_stGroup[byBigGNumber & 0xFF].nExtendSize = 0;

        for (i = nSurGroupCount[0] - 1; i >= 0; i--) {
            if (byBigGNumber == m_Engine.m_bySurGroupNumber[i]) {
                (nSurGroupCount[0])--;

                for (; i < (nSurGroupCount[0]); i++)
                    m_Engine.m_bySurGroupNumber[i] = m_Engine.m_bySurGroupNumber[i + 1];

                break;
            }
        }
        EqualTwoGroupLink(ENDPOS, bySmallGNumber, byBigGNumber);
        return;
    }

    void AbsEqInterrel(byte bySmallGNumber, byte byBigGNumber, short[] nSurGroupCount) {
        short i, j, k;
        short nOldPos;

        for (j = (short) ((m_Engine.m_byTotalInterrelCount & 0xFF) - 1); j >= 0; j--) {
            if ( (m_Engine.m_stInterrelGroup[j].byGroupNumber1 != byBigGNumber) &&
                    (m_Engine.m_stInterrelGroup[j].byGroupNumber2 != byBigGNumber))
                continue;
            if (m_Engine.m_stInterrelGroup[j].byGroupNumber1 == byBigGNumber)
                m_Engine.m_stInterrelGroup[j].byGroupNumber1 = bySmallGNumber;

            else {
                if (m_Engine.m_stInterrelGroup[j].byGroupNumber1 <= bySmallGNumber)
                    m_Engine.m_stInterrelGroup[j].byGroupNumber2 = bySmallGNumber;

                else {
                    m_Engine.m_stInterrelGroup[j].byGroupNumber2 =
                            m_Engine.m_stInterrelGroup[j].byGroupNumber1;
                    m_Engine.m_stInterrelGroup[j].byGroupNumber1 = bySmallGNumber;
                }
            }
            for (k = (short) (m_Engine.m_byTotalInterrelCount - 1); k > j; k--) {

                if ( (m_Engine.m_stInterrelGroup[k].byGroupNumber2 !=
                        m_Engine.m_stInterrelGroup[j].byGroupNumber2) ||
                        (m_Engine.m_stInterrelGroup[k].byGroupNumber1 !=
                                m_Engine.m_stInterrelGroup[j].byGroupNumber1))
                    continue;

                nOldPos = m_Engine.m_stInterrelGroup[k].nPos;

                if (m_Engine.m_byTotalInterrelCount != 0) {
                    m_Engine.m_byTotalInterrelCount--;

                    for (i = k; i < m_Engine.m_byTotalInterrelCount - 1; i++)
                    {
                        m_Engine.m_stInterrelGroup[i].copy(m_Engine.m_stInterrelGroup[i + 1]);
                    }
                }
                if (nOldPos != m_Engine.m_stInterrelGroup[j].nPos)
                    EqTwoGAndOthTwoC(m_Engine.m_stInterrelGroup[k].byGroupNumber1,
                            m_Engine.m_stInterrelGroup[k].byGroupNumber2, nSurGroupCount, k);
                break;
            }
        }

    }

    void ExtendGrpInfo() {
        short nCount[] = {0};
        byte byGrpNum;
        byte byTestBit1, byTestBit2;
        boolean bIs;
        byte byResult;
        byte byTestGrpNum[] = {0};

        if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] != 0)
            return;

        byTestGrpNum[0] = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition];
        if ((byTestGrpNum[0] & 0xff) > 0) {
            byTestGrpNum[0] &= 1;
            //byTestGrpNum[0]++;
            byTestGrpNum[0] = (byte)((byTestGrpNum[0] & 0xff) + 1);
        }
        MEMSET(m_Engine.m_bySurGroupNumber, 0);

        SeeBesidePos(m_Engine.m_nMainPosition - 1, nCount, byTestGrpNum);
        SeeBesidePos(m_Engine.m_nMainPosition - 20, nCount, byTestGrpNum);
        SeeBesidePos(m_Engine.m_nMainPosition + 1, nCount, byTestGrpNum);
        SeeBesidePos(m_Engine.m_nMainPosition + 20, nCount, byTestGrpNum);

        SeeDiagPos(m_Engine.m_nMainPosition + 19, m_Engine.m_nMainPosition - 1, m_Engine.m_nMainPosition + 20,
                nCount, byTestGrpNum);
        SeeDiagPos(m_Engine.m_nMainPosition - 21, m_Engine.m_nMainPosition - 1, m_Engine.m_nMainPosition - 20,
                nCount, byTestGrpNum);
        SeeDiagPos(m_Engine.m_nMainPosition - 19, m_Engine.m_nMainPosition + 1, m_Engine.m_nMainPosition - 20,
                nCount, byTestGrpNum);
        SeeDiagPos(m_Engine.m_nMainPosition + 21, m_Engine.m_nMainPosition + 1, m_Engine.m_nMainPosition + 20,
                nCount, byTestGrpNum);

        byResult = 0x00;

        while (nCount[0] > 0) {
            byGrpNum = m_Engine.m_bySurGroupNumber[nCount[0] - 1];
            if (m_Engine.m_stGroup[byGrpNum & 0xFF].nTotalSize == 0) { // by KWJ : -> & 0xFF
                nCount[0]--;
                continue;
            }
            byTestBit1 = 0x01;
            byTestBit2 = 0x01;
            byTestBit1 &= byGrpNum;
            byTestBit1 += 1;
            if ( (byTestGrpNum[0] & byTestBit1) == 0) {
                byTestBit1 <<= 2;
                bIs = false;
                if ( (byTestGrpNum[0] & byTestBit1) != 0) {
                    byTestBit1 = 0x01;
                    if ( (m_Engine.m_byPosBoard[m_Engine.m_nMainPosition] & 0xff) > 3)
                        bIs = true;
                } else {
                    if ( (m_Engine.m_byPosBoard[m_Engine.m_nMainPosition] & 0xff) >= 5) {
                        byTestBit1 = 0x03;
                        byTestBit2 = 0x02;
                        bIs = true;
                    } else {
                        byTestBit1 <<= 2;
                        if ( (byTestGrpNum[0] & byTestBit1) == 0x00) {
                            byTestBit1 = 0x03;
                            byTestBit2 = 0x02;
                        } else {
                            byTestBit1 = 0x02;
                            byTestBit2 = 0x02;
                        }
                        if ( (byte) m_Engine.m_byPosBoard[m_Engine.m_nMainPosition] == 3) {
                            byTestBit1 -= 2;
                            bIs = true;
                        } else if ((m_Engine.m_byPosBoard[m_Engine.m_nMainPosition] & 0xff) > 3)
                            bIs = true;
                    }
                }
                if (bIs == true) {
                    if ( (byGrpNum & 0x01) == 0x01)
                        byResult |= 0x01;
                    else
                        byResult |= 0x02;

                    if (0xff - (byTestBit1 & 0xff) >= m_Engine.m_stGroup[byGrpNum & 0xFF].nExtendSize)
                        m_Engine.m_stGroup[byGrpNum & 0xFF].nExtendSize += (byTestBit1 & 0xff);
                    else
                        m_Engine.m_stGroup[byGrpNum & 0xFF].nExtendSize = 0xff;
                }
            }

            if (m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition] != 0) {
                nCount[0]--;
                continue;
            }

            if (0xff - (byTestBit2 & 0xff) >= m_Engine.m_stGroup[byGrpNum & 0xFF].nTotalSize)
                m_Engine.m_stGroup[byGrpNum & 0xFF].nTotalSize += (byTestBit2 & 0xff);
            else
                m_Engine.m_stGroup[byGrpNum & 0xFF].nTotalSize = 0xff;
            nCount[0]--;
        }

        if ( (byResult == 0x03) && (m_Engine.m_byNewStringNumber == 0) && (m_Engine.m_bFindMove == true))
            m_Engine.m_lBitBoard[m_Engine.m_nMainPosition] |= 0x40000000;
    }

    void SeeBesidePos(int nPos, short[] pnCount, byte[] pbyTestGrpNum) {
        byte byGrpNum, byComp;
        short nCount;
        // Centre is Empty Position.
        if (m_Engine.m_byBoard[nPos] == -16)
            return;
        byGrpNum = m_Engine.m_byGroupBoard[nPos];
        if (byGrpNum == 0)
            return;

        byComp = m_Engine.m_byBoard[nPos];
        if ((byComp & 0xff) > 0) {
            byComp ^= byGrpNum;
            byComp &= 0x01;
            if (byComp == 0) {
                //String and Group is Equal Color.

                if ( (byGrpNum & 0x01) == 0x01) {
                    // White Group

                    pbyTestGrpNum[0] |= 0x20;
                    if ( (pbyTestGrpNum[0] & 0x80) == 0x80)
                        pbyTestGrpNum[0] = 3; // More Than Two Side Equal Group
                    else {
                        pbyTestGrpNum[0] |= 0x80;
                        if ( m_Engine.m_cWeightBoard[nPos] == 0) {
                            if ( (pbyTestGrpNum[0] & 0x04) == 0)
                                pbyTestGrpNum[0] |= 0x04;
                            else
                                pbyTestGrpNum[0] |= 0x01;
                        }
                    }
                } else {
                    pbyTestGrpNum[0] |= 0x10;
                    if ( (pbyTestGrpNum[0] & 0x40) == 0x40)
                        pbyTestGrpNum[0] = 3;
                    else {
                        pbyTestGrpNum[0] |= 0x40;
                        if ( (char) m_Engine.m_cWeightBoard[nPos] == 0) {
                            if ( (pbyTestGrpNum[0] & 0x08) == 0)
                                pbyTestGrpNum[0] |= 0x08;
                            else
                                pbyTestGrpNum[0] |= 0x02;
                        }
                    }
                }
            }
        }

        nCount = pnCount[0];
        while (nCount > 0) {
            if (m_Engine.m_bySurGroupNumber[nCount - 1] == byGrpNum)
                return;
            nCount--;
        }
        m_Engine.m_bySurGroupNumber[pnCount[0]] = byGrpNum;
        (pnCount[0])++;
    }

    void SeeDiagPos(int nPos3, int nPos1, int nPos2, short[] pnCount, byte[] pbyTestGrpNum) {
        byte byStrNum1, byStrNum2, byStrNum3;
        byte byGrpNum3;
        short nCount;

        if (m_Engine.m_byBoard[nPos3] == -16)
            return;

        byStrNum1 = m_Engine.m_byBoard[nPos1];

        byStrNum2 = m_Engine.m_byBoard[nPos2];

        if ( (byStrNum1 != 0) && (byStrNum2 != 0))
            return;

        byGrpNum3 = m_Engine.m_byGroupBoard[nPos3];

        if (byGrpNum3 == 0)
            return;

        byStrNum3 = m_Engine.m_byBoard[nPos3];

        if ( (byStrNum3 == 0) || ( ( (byGrpNum3 ^ byStrNum3) & 0x01) == 0x01)) {
            // None of Stone in Diag, or Opposite color stone and Opposite color Group.

            nCount = pnCount[0];
            while (nCount > 0) {
                if (m_Engine.m_bySurGroupNumber[nCount - 1] == byGrpNum3)
                    return;
                nCount--;
            }
            m_Engine.m_bySurGroupNumber[pnCount[0]] = byGrpNum3;
            (pnCount[0])++;
            return;
        }

        if ( (byGrpNum3 & 0x01) == 0x01) {
            //white color
            if ( (pbyTestGrpNum[0] & 0x80) == 0x80)
                pbyTestGrpNum[0] = 3;
            else {
                pbyTestGrpNum[0] |= 0x80;
                if (m_Engine.m_cWeightBoard[nPos3] == 0) {
                    if ( (pbyTestGrpNum[0] & 0x04) == 0x04)
                        pbyTestGrpNum[0] |= 0x01;
                    else
                        pbyTestGrpNum[0] |= 0x04;
                }
            }
        } else {
            //black color
            if ( (pbyTestGrpNum[0] & 0x40) == 0x40)
                pbyTestGrpNum[0] = 3;
            else {
                pbyTestGrpNum[0] |= 0x40;
                if (m_Engine.m_cWeightBoard[nPos3] == 0) {
                    if ( (pbyTestGrpNum[0] & 0x08) == 0x08)
                        pbyTestGrpNum[0] |= 0x02;
                    else
                        pbyTestGrpNum[0] |= 0x08;
                }
            }
        }

        nCount = pnCount[0];
        while (nCount > 0) {
            if (m_Engine.m_bySurGroupNumber[nCount - 1] == byGrpNum3)
                return;
            nCount--;
        }
        m_Engine.m_bySurGroupNumber[pnCount[0]] = byGrpNum3;
        (pnCount[0])++;
    }
    /*
        void UpdateInfo9() {
            short byGrpNum;
            short byStrNum; //,byOldGrpNum;
            byte bySEPs, byStones;
            short byInfo7, byInfo9;

            for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
                try {
                    if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == -16)
                        continue;

                    byStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition];
                    if (byStrNum == 0)
                        continue;
                    byGrpNum = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition];
                    if (byGrpNum == 0)
                        continue;
                    bySEPs = (byte) m_Engine.m_byLiberties[byStrNum];
                    if ( (bySEPs & 0x80) == 0x80)
                        continue;

                    if (byStrNum <= 0x7a)
                        m_Engine.m_byLiberties[byStrNum] |= 0x80;

                    byStones = m_Engine.m_nStoneCount[byStrNum];
                    if (m_Engine.m_stGroup[byGrpNum].nImGirth == (byte) 0xff)
                        continue;

                    if ( (byStrNum & 0x01) == (byGrpNum & 0x01)) {
                        byInfo7 = (byte) m_Engine.m_stGroup[byGrpNum].nBattleGain;
                        if (bySEPs > byInfo7) {
                            if (byInfo7 > 2)
                                byInfo7 += (bySEPs - 2);
                            else
                                byInfo7 = bySEPs;
                        } else {
                            if (bySEPs > 2)
                                byInfo7 += (bySEPs - 2);
                        }
                        m_Engine.m_stGroup[byGrpNum].nBattleGain = byInfo7;

                        byInfo9 = (byte) m_Engine.m_stGroup[byGrpNum].nImGirth;
                        if (bySEPs > byInfo9) {
                            if (byInfo9 > 3)
                                byInfo9 += (bySEPs - 3);
                            else
                                byInfo9 = bySEPs;
                        } else {
                            if (bySEPs > 3)
                                byInfo9 += (bySEPs - 3);
                        }
                        m_Engine.m_stGroup[byGrpNum].nImGirth = byInfo9;
                    } else
                        m_Engine.m_stGroup[byGrpNum].nImGirth += GetDeadStoneInfo9(bySEPs, byStones);
                } catch (Exception e) {
                    System.out.println("m_Engine.m_nMainPosition : " + m_Engine.m_nMainPosition);
                }
            }

            for (byStrNum = 1; byStrNum < MAX_STRINGCOUNT; byStrNum++)
                m_Engine.m_byLiberties[byStrNum] &= 0x7f;

            for (byGrpNum = 1; byGrpNum <= m_Engine.m_nTotalGroupCount; byGrpNum++) {
                if ( (m_Engine.m_stGroup[byGrpNum].nTotalSize != 0) &&
                    (m_Engine.m_stGroup[byGrpNum].nImGirth != (byte) 0xff)) {
                    byInfo7 = (byte) m_Engine.m_stGroup[byGrpNum].nBattleGain;
                    if (0xff - byInfo7 >= m_Engine.m_stGroup[byGrpNum].nExtendSize) {
                        byInfo7 += (byte) m_Engine.m_stGroup[byGrpNum].nExtendSize;
                        if (0xff - m_Engine.m_stGroup[byGrpNum].nImGirth >= byInfo7)
                            m_Engine.m_stGroup[byGrpNum].nImGirth += byInfo7;
                        else
                            m_Engine.m_stGroup[byGrpNum].nImGirth = 0xff;
                    } else
                        m_Engine.m_stGroup[byGrpNum].nImGirth = 0xff;
                }
                m_Engine.m_stGroup[byGrpNum].nBattleGain = 0;
            }
        }
    */
    short GetDeadStoneInfo9(byte bySEPs, short nStones) {
        short nCount = (short) ((bySEPs & 0xff) + nStones - 1);
        short nInfo9 = nCount;

        if (nCount > 3) {
            nCount -= 3;
            while (nCount > 0) {
                nInfo9 = (short)((nInfo9 & 0xff) + nCount);
                nCount = (short)(nCount - 1);
            }
        }

        nCount = (short) (nStones - 1);
        nInfo9 += (nStones - (bySEPs & 0xff) - 2);

        if (nCount > 3) {
            nCount -= 3;
            while (nCount > 0) {
                nInfo9 += nCount;
                nCount--;
            }
        }

        if (nInfo9 >= 0x80)
            nInfo9 = 0;
        return nInfo9;
    }

    void GroupEstimation(byte byGrpNumber) {
        short bySpaceSize = m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize;
        short byArrExtendPoss = m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize;
        boolean bIs = true;
        byte byHalf, byBits;
        short wInfo;
        short i;

        if ( (byArrExtendPoss < 0x20) && (bySpaceSize <= 0x10)) {
            byArrExtendPoss += (2 * bySpaceSize);
            if (byArrExtendPoss < 0x24)
                bIs = false;
        }
        if (bIs == true) {
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nAliveDead = 0;
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance = 0;
            m_Engine.m_byInfo9 = (byte) 0xff;

            byHalf = (byte) ((bySpaceSize >>> 1) & 0xFF);
            if (0xff - bySpaceSize >= (byHalf & 0xFF))
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize += byHalf;
            else
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0xff;
            return;
        }

        LiveDeadGrpCalc(byGrpNumber, (short) 0);

        byArrExtendPoss = m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize;

        wInfo = LiveDeadDegree( (byte) m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize, (byte) byArrExtendPoss,
                byGrpNumber);

        m_Engine.m_stGroup[byGrpNumber & 0xFF].nAliveDead = (short)(HIBYTE(wInfo) & 0xff);
        m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance = (short)(LOBYTE(wInfo) & 0xff);

        if (m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize == 0)
            return;

        if (HIBYTE(wInfo) == 0)
            m_Engine.m_byInfo9 = (byte) 0xff;

        if ( (m_Engine.m_byNewStringNumber != 0) || (m_Engine.m_bFindMove == false) ||
                (m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize >= 4) ||
                (m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize <= 0x06) ||
                (m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize >= 0x18)) //1b->18
            return;

        if (m_Engine.nBoardScoreCtrl == 0)
            return;

        if ( m_Engine.m_nGameLevel >= 3 )
        {
            byBits = (byte) ((IsWhite(byGrpNumber)) ? 0x04 : 0x08);

            for (i = 0; i < m_Engine.m_nCountOfFoundPos; i++) {
                m_Engine.m_nMainPosition = m_Engine.m_nFoundPos[i]; //,m_Engine.m_byBoardY = m_Engine.m_nFoundPosY[i];
                if ((m_Engine.m_byProp[i] & 0xff) >= 2) {
                    if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == 0) {
                        if (m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize == 0) { //?? no significant!!
                            m_Engine.m_lBitBoard[m_Engine.m_nMainPosition] &= 0xf3;
                            m_Engine.m_lBitBoard[m_Engine.m_nMainPosition] |= byBits;
                        } else
                            Bit23Control(m_Engine.m_nMainPosition);
                    }
                } else {
                    Bit23Control(m_Engine.m_nMainPosition - 1);
                    Bit23Control(m_Engine.m_nMainPosition - 21);
                    Bit23Control(m_Engine.m_nMainPosition - 20);
                    Bit23Control(m_Engine.m_nMainPosition - 19);
                    Bit23Control(m_Engine.m_nMainPosition + 1);
                    Bit23Control(m_Engine.m_nMainPosition + 21);
                    Bit23Control(m_Engine.m_nMainPosition + 20);
                    Bit23Control(m_Engine.m_nMainPosition + 19);
                }
            }
        }
        else
        {
            for( i= m_Engine.m_nFirstPos; i <= m_Engine.m_nLastPos; i++ )
            {
                m_Engine.m_nMainPosition = (short)((m_Engine.m_nHomeCandiY[i] + m_Engine.m_nBoardSize / 2 + 1) * 20
                        + m_Engine.m_nHomeCandiX[i] + m_Engine.m_nBoardSize / 2 + 1);

                Bit23Control(m_Engine.m_nMainPosition - 1);
                Bit23Control(m_Engine.m_nMainPosition - 21 );
                Bit23Control(m_Engine.m_nMainPosition - 20 );
                Bit23Control(m_Engine.m_nMainPosition - 19 );
                Bit23Control(m_Engine.m_nMainPosition + 1 );
                Bit23Control(m_Engine.m_nMainPosition + 21 );
                Bit23Control(m_Engine.m_nMainPosition + 20 );
                Bit23Control(m_Engine.m_nMainPosition + 19 );
            }
        }
    }

    void Bit23Control(int nPos) {
        if (m_Engine.m_byBoard[nPos] == -16)
            return;

        if ( (m_Engine.m_byBoard[nPos] == 0) && ( (m_Engine.m_lBitBoard[nPos] & 0x0c) == 0x00))
            m_Engine.m_lBitBoard[nPos] |= 0x0c;
    }

    void LiveDeadGrpCalc(byte byGrpNumber, short nCount) {
        byte bySidePlusWeight, byPlusWeight[] = {0};
        short j;
        short nPos;
        byte byGrp;
        short i;
        short nCandiCount = 0;
        short nResult;
        byte cGet[] = {0};
        byte byInfo5;
        short nOldLastPos;

        m_Engine.m_nCount = nCount;
        m_Engine.m_byInfo5 = 0;
        m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0;

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xf0)
                continue;

            byGrp = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition];

            if (byGrpNumber != byGrp) {
                if (m_Engine.m_wCtrlGroupNum > 0) {
                    byPlusWeight[0] = ReversalWeight(byGrpNumber);
                    if ((byPlusWeight[0] & 0xFF) >= 3) {
                        if (byGrp == 0) {
                            for (i = m_Engine.m_wCtrlGroupNum; i >= 0; i--)
                                if (true == FindSameGrpAround(m_Engine.m_byBufForOtherSurG[i]))
                                    break;
                            if (i < 0)
                                continue;
                        } else {
                            for (i = m_Engine.m_wCtrlGroupNum; i > 0; i--) {
                                if (byGrp == m_Engine.m_byBufForOtherSurG[i])
                                    break;
                            }
                            if (i == 0)
                                continue;
                        }
                    } else
                        continue;
                } else {
                    if (byGrp == 0) {
                        if (true == FindSameGrpAround(byGrpNumber))
                            byPlusWeight[0] = ReversalWeight(byGrpNumber);
                        else
                            continue;
                    } else
                        continue;
                }

            } else
                byPlusWeight[0] = ReversalWeight(byGrpNumber);

            if ((byPlusWeight[0] & 0xFF) < 3) // by KWJ : -> & 0xFF
                continue;

            if ( ((byPlusWeight[0] & 0xFF) > 3) && (m_Engine.m_wCtrlGroupNum > 0))
                AddToGrpInfo5(byPlusWeight[0], (byte) 0);

            nPos = m_Engine.m_nMainPosition;

            if (false == SpecialValue(byPlusWeight[0])) {
                for (j = 0; j < 4; j++) {
                    m_Engine.m_nMainPosition = (short) (nPos + m_Engine.m_cAroundTable[j]);

                    if (StringGrpColor(byGrpNumber) <= 0) { //space, opposite color
                        bySidePlusWeight = ReversalWeight(byGrpNumber);
                        if ( ((bySidePlusWeight & 0xFF) >= 4) && (false == SpecialValue(bySidePlusWeight))) {
                            if ( (j < 2) && (byPlusWeight[0] == bySidePlusWeight))
                                break;

                            if (byPlusWeight[0] < bySidePlusWeight)
                                break;
                            continue;
                        }
                    }
                }

                m_Engine.m_nMainPosition = nPos;

                if (j < 4)
                    continue;

                byPlusWeight[0] &= 0xfe; //4,7,8 -> 4,6,8
                //H.Joon-2007/03/07>>
                //byPlusWeight[0] += (byPlusWeight[0] >> 1); //6,9,12
                byPlusWeight[0] += ((byPlusWeight[0] & 0xFF) >>> 1); //6,9,12
                //<<
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize += byPlusWeight[0];

                if ( (nCount >= 0) && ((byPlusWeight[0] & 0xFF) < 0x0c))
                    m_Engine.m_nAddPos[nCount++] = m_Engine.m_nMainPosition;

                if (m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize >= 0x1e)
                    return;
                else
                    continue;
            }

            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] != 0) {
                if ((byPlusWeight[0] & 0xFF) >= 6) {
                    m_Engine.m_nHomeCandiX[nCandiCount] = (short) ( (m_Engine.m_nMainPosition % 20 - 1) -
                            m_Engine.m_nBoardSize / 2);
                    m_Engine.m_nHomeCandiY[nCandiCount] = (short) ( (m_Engine.m_nMainPosition / 20 - 1) -
                            m_Engine.m_nBoardSize / 2);
                    nCandiCount++;
                    if (nCandiCount >= 0x20) {
                        m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0x1e;
                        return;
                    }
                    continue;
                }

                nPos = m_Engine.m_nMainPosition;

                for (j = 0; j < 4; j++) {
                    m_Engine.m_nMainPosition = (short) (nPos + m_Engine.m_cAroundTable[j]);

                    nResult = StringGrpColor(byGrpNumber);

                    if (nResult >= 0) //no Opposite Color Stone
                        continue;

                    // Opposite Color Stone

                    bySidePlusWeight = ReversalWeight(byGrpNumber);

                    if ( ((bySidePlusWeight & 0xFF) < 2) || (byPlusWeight[0] < bySidePlusWeight))
                        break;
                }

                m_Engine.m_nMainPosition = nPos;

                if (j < 4)
                    continue;
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize += 6;

                if (nCount >= 0)
                    m_Engine.m_nAddPos[nCount++] = m_Engine.m_nMainPosition;

                if (m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize >= 0x1e)
                    return;
                else
                    continue;
            }
            if (byPlusWeight[0] == 9)
                continue;

            nPos = m_Engine.m_nMainPosition;

            cGet[0] = 8;

            m_Engine.m_nMainPosition--;

            if (true == HomeDetBySpaceSur(byGrpNumber, byPlusWeight, cGet, nPos)) {
                m_Engine.m_nMainPosition = nPos;
                continue;
            }

            m_Engine.m_nMainPosition += 2;

            if (true == HomeDetBySpaceSur(byGrpNumber, byPlusWeight, cGet, nPos)) {
                m_Engine.m_nMainPosition = nPos;
                continue;
            }

            m_Engine.m_nMainPosition -= 21;

            if (true == HomeDetBySpaceSur(byGrpNumber, byPlusWeight, cGet, nPos)) {
                m_Engine.m_nMainPosition = nPos;
                continue;
            }

            m_Engine.m_nMainPosition += 40;

            if (true == HomeDetBySpaceSur(byGrpNumber, byPlusWeight, cGet, nPos)) {
                m_Engine.m_nMainPosition = nPos;
                continue;
            }

            m_Engine.m_nMainPosition = nPos;

            if ((byPlusWeight[0] & 0xFF) >= 6) {
                m_Engine.m_nHomeCandiX[nCandiCount] = (short) ( (m_Engine.m_nMainPosition % 20 - 1) -
                        m_Engine.m_nBoardSize / 2);
                m_Engine.m_nHomeCandiY[nCandiCount] = (short) ( (m_Engine.m_nMainPosition / 20 - 1) -
                        m_Engine.m_nBoardSize / 2);
                nCandiCount++;
                if (nCandiCount >= 0x20) {
                    m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0x1e;
                    return;
                }
                continue;
            }

            if (byPlusWeight[0] == 5) {
                if (nCount >= 0)
                    m_Engine.m_nAddPos[nCount++] = m_Engine.m_nMainPosition;

                if (cGet[0] <= 0)
                    m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize += 1;
                else
                    m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize += 3;
            } else
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize += 1;

            if (m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize >= 0x1e)
                return;
        }

        byInfo5 = m_Engine.m_byInfo5;
        m_Engine.m_byInfo5 = 0;
        if ((byInfo5 & 0xFF) >= 0x10) {
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0x1e;
            return;
        }
        byInfo5 *= 2;
        byInfo5 += (byte) m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize;
        if ((byInfo5 & 0xFF) >= 0x24) {
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = 0x1e;
            return;
        }

        m_Engine.m_nCount = nCount;
        m_Engine.m_byGrpNum = byGrpNumber;
        m_Engine.m_nCountOfFoundPos = 0;

        m_Engine.m_nLastPos = (short) (nCandiCount - 1);

        while (true) {
            m_Engine.m_nFirstPos = 0;
            if ( (m_Engine.m_nLastPos < 0) || (true == UpdateGroupInfo5()))
                return;

            if( m_Engine.m_nGameLevel < 3 )
            {
                byte byValue;
                if( (m_Engine.m_nLastPos - m_Engine.m_nFirstPos + 1) == 2 )
                    byValue = 0x0c;//12
                else if( (m_Engine.m_nLastPos - m_Engine.m_nFirstPos + 1) < 6 )
                    byValue = 0x12;//18
                else
                    byValue = 0x15;//21
                m_Engine.m_stGroup[m_Engine.m_byGrpNum & 0xff].nHomeSize += byValue;
                return;
            }

            GetMaxMinSum();
            RemoveOneCandi(); //changes m_Engine.m_nFirstPos,8369 module

            if ((m_Engine.m_nLastPos - m_Engine.m_nFirstPos + 1) == 0)
                return;

            if (true == UpdateGroupInfo5())
                m_Engine.m_nLastPos -= 1;
            else {
                UpdateWeightTable();
                nOldLastPos = m_Engine.m_nLastPos;
                GetSurPos();
                if (nOldLastPos == m_Engine.m_nLastPos)
                    return;
                UpdateWeightTable();
            }
            if (m_Engine.m_stGroup[m_Engine.m_byGrpNum & 0xFF].nHomeSize >= 0x1e)
                return;
        }
    }

    void AddToGrpInfo5(byte byPlusWeight, byte byGrpNum) {
        byte byInfo5;

        if ( ((byPlusWeight & 0xFF) >= 9) || (byPlusWeight == 4))
            byInfo5 = 2;
        else if ((byPlusWeight & 0xFF) < 4)
            return;
        else
            byInfo5 = (byte) (byPlusWeight - 4);

        if (byGrpNum == 0) {
            if (0xff - (m_Engine.m_byInfo5 & 0xff) >= (byInfo5 & 0xff))
                //m_Engine.m_byInfo5 += byInfo5;
                m_Engine.m_byInfo5 = (byte)((m_Engine.m_byInfo5 & 0xff) + (byInfo5 & 0xff));
            else
                m_Engine.m_byInfo5 = (byte) 0xff;
        } else {
            if (0xff - m_Engine.m_stGroup[byGrpNum & 0xFF].nHomeSize >= (byInfo5 & 0xff))
                m_Engine.m_stGroup[byGrpNum & 0xFF].nHomeSize += (byInfo5 & 0xff);
            else
                m_Engine.m_stGroup[byGrpNum & 0xFF].nHomeSize = 0xff;
        }
    }

    void GetSurPos() {
        byte cAverX[] = {0}
                , cRemX[] = {0};
        byte cAverY[] = {0}
                , cRemY[] = {0};
        byte pchDifX[] = new byte[10];
        byte pchDifY[] = new byte[10];
        short nCount = 0;
        short nBoardX;
        short nBoardY;
        byte byArea[] = {0}
                , byProp[] = {0}
                , byPos[] = {0}
                , byRemoved[] = {0};
        byte byStrNum;
        int n, i;
        boolean bIsIn;

        GetAver(m_Engine.m_nSumOfHomeCandiX, m_Engine.m_nLastPos - m_Engine.m_nFirstPos + 1, cAverX, cRemX);
        GetAver(m_Engine.m_nSumOfHomeCandiY, m_Engine.m_nLastPos - m_Engine.m_nFirstPos + 1, cAverY, cRemY);

        pchDifX[0] = 0;
        pchDifY[0] = 0;

        if ( (cRemX[0] == 0) && (cRemY[0] == 0)) {
            nCount = 3;
            if (cAverX[0] == m_Engine.m_nMaxOfHomeCandiX) {
                pchDifX[1] = 0;
                pchDifX[2] = 0;
                pchDifY[1] = -1;
                pchDifY[2] = 1;
            } else if (cAverY[0] == m_Engine.m_nMaxOfHomeCandiY) {
                pchDifX[1] = -1;
                pchDifX[2] = 1;
                pchDifY[1] = 0;
                pchDifY[2] = 0;
            } else {
                nCount = 9;
                for (i = 1; i <= 8; i++) {
                    pchDifX[i] = (byte) m_Engine.AroundPointPosTable[ (i - 1) * 2];
                    pchDifY[i] = (byte) m_Engine.AroundPointPosTable[ (i - 1) * 2 + 1];
                }
            }
        } else {
            if (cRemX[0] != 0) {
                if (cRemX[0] > 0) {
                    pchDifX[1] = 1;
                    pchDifY[1] = 0;
                } else {
                    pchDifX[1] = -1;
                    pchDifY[1] = 0;
                }

                if (cRemY[0] != 0) {
                    nCount = 4;
                    if (cRemY[0] > 0) {
                        pchDifX[2] = 0;
                        pchDifY[2] = 1;
                    } else {
                        pchDifX[2] = 0;
                        pchDifY[2] = -1;
                    }
                    pchDifX[3] = pchDifX[1];
                    pchDifY[3] = pchDifY[2];
                } else {
                    nCount = 2;
                    if (cAverY[0] != m_Engine.m_nMaxOfHomeCandiY) {
                        pchDifX[2] = 0;
                        pchDifY[2] = -1;
                        pchDifX[3] = 0;
                        pchDifY[3] = 1;

                        pchDifX[4] = pchDifX[1];
                        pchDifY[4] = -1;
                        pchDifX[5] = pchDifX[1];
                        pchDifY[5] = 1;
                        nCount = 6;
                    }
                }
            } else {
                nCount = 2;
                if (cRemY[0] > 0) {
                    pchDifX[1] = 0;
                    pchDifY[1] = 1;
                } else {
                    pchDifX[1] = 0;
                    pchDifY[1] = -1;
                }
                if (cAverX[0] != m_Engine.m_nMaxOfHomeCandiX) {
                    pchDifX[2] = -1;
                    pchDifY[2] = 0;
                    pchDifX[3] = 1;
                    pchDifY[3] = 0;

                    pchDifX[4] = -1;
                    pchDifY[4] = pchDifY[1];
                    pchDifX[5] = 1;
                    pchDifY[5] = pchDifY[1];
                    nCount = 6;
                }
            }
        }

        m_Engine.m_nCountOfFoundPos = 0;

        nBoardX = (short) (cAverX[0] + m_Engine.m_nBoardSize / 2 + 1);
        nBoardY = (short) (cAverY[0] + m_Engine.m_nBoardSize / 2 + 1);

        for (n = 0; n < nCount; n++) {
            m_Engine.m_nMainPosition = (short) ( (nBoardY + pchDifY[n]) * 20
                    + nBoardX + pchDifX[n]);

            bIsIn = false;

            if (m_Engine.m_nCountOfFoundPos > 0) {
                for (i = m_Engine.m_nCountOfFoundPos - 1; i >= 0; i--) {
                    if (m_Engine.m_nMainPosition == m_Engine.m_nFoundPos[i]) {
                        bIsIn = true;
                        break;
                    }
                }
            }
            if ( (bIsIn == true) || (StringGrpColor(m_Engine.m_byGrpNum) > 0))
                continue;

            byPos[0] = 0;
            if (false == GetPropValues(byArea, byProp, byPos)) {
                byRemoved[0] = 0;
                Remove(byRemoved);
                continue;
            }

            i = m_Engine.m_nCountOfFoundPos - 1;
            if (m_Engine.m_nCountOfFoundPos > 0) {
                for (; i >= 0; i--) {
                    byStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition];
                    if (m_Engine.m_byBoard[m_Engine.m_nFoundPos[i]] == 0) {
                        if (byStrNum != 0) {
                            m_Engine.m_nFoundPos[i + 1] = m_Engine.m_nFoundPos[i];
                            m_Engine.m_byProp[i + 1] = m_Engine.m_byProp[i];
                            m_Engine.m_byArea[i + 1] = m_Engine.m_byArea[i];
                            m_Engine.m_byPos[i + 1] = m_Engine.m_byPos[i];
                            continue;
                        }
                    } else if (byStrNum == 0)
                        break;
                    if (byProp[0] < m_Engine.m_byProp[i])
                        break;
                    if ((byProp[0] == m_Engine.m_byProp[i]) &&
                            ((byArea[0] & 0xff) < (m_Engine.m_byArea[i] & 0xff)))
                        break;

                    m_Engine.m_nFoundPos[i + 1] = m_Engine.m_nFoundPos[i];
                    m_Engine.m_byProp[i + 1] = m_Engine.m_byProp[i];
                    m_Engine.m_byArea[i + 1] = m_Engine.m_byArea[i];
                    m_Engine.m_byPos[i + 1] = m_Engine.m_byPos[i];
                }
            }
            m_Engine.m_nFoundPos[i + 1] = m_Engine.m_nMainPosition;
            m_Engine.m_byProp[i + 1] = byProp[0];
            m_Engine.m_byArea[i + 1] = byArea[0];
            m_Engine.m_byPos[i + 1] = byPos[0];
            m_Engine.m_nCountOfFoundPos++;
        }

        if (m_Engine.m_nCountOfFoundPos == 0)
            return;

        AddGrpInfoOfFoundPos(0);
        if (m_Engine.m_nCountOfFoundPos > 1)
            for (i = 1; i < m_Engine.m_nCountOfFoundPos; i++) {
                if ((m_Engine.m_nLastPos + 1) == m_Engine.m_nFirstPos) {
                    if ( ((m_Engine.m_byProp[i] & 0xFF) < 2) ||
                            ((m_Engine.m_byArea[i] & 0xFF) < 0x60))
                        break;
                }
                AddGrpInfoOfFoundPos(i);
            }
        return;
    }

    void Remove(byte[] pbyRemoved) {
        short n;

        for (n = m_Engine.m_nLastPos; n >= m_Engine.m_nFirstPos; n--) {
            if (m_Engine.m_nMainPosition ==
                    ((m_Engine.m_nHomeCandiY[n] + m_Engine.m_nBoardSize / 2 + 1) * 20 +
                            m_Engine.m_nHomeCandiX[n] + m_Engine.m_nBoardSize / 2 + 1))
                break;
        }

        if (n < m_Engine.m_nFirstPos)
            return;

        if (n != m_Engine.m_nLastPos) {
            m_Engine.m_nHomeCandiX[n] = m_Engine.m_nHomeCandiX[m_Engine.m_nLastPos];
            m_Engine.m_nHomeCandiY[n] = m_Engine.m_nHomeCandiY[m_Engine.m_nLastPos];
        }
        m_Engine.m_nLastPos--;
        pbyRemoved[0]++;
        return;
    }

    void AddGrpInfoOfFoundPos(int n) {
        byte byProp = m_Engine.m_byProp[n];
        byte byArea = m_Engine.m_byArea[n];
        byte byPos = m_Engine.m_byPos[n];

        byte byWeight, byRemoved;

        m_Engine.m_nMainPosition = m_Engine.m_nFoundPos[n];

        byWeight = ReversalWeight(m_Engine.m_byGrpNum);
        byArea &= 0x0f;
        byRemoved = RemoveSomePositions(byPos, byWeight);

        if ( ((byProp & 0xff) < 2) && (byRemoved == 0))
            return;
        if ( (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == 0) && ((byProp & 0xff) >= 2))
            //byArea += 0x0c;
            byArea = (byte)((byArea & 0xff) + 0x0c);
        if (byWeight == 6)
            //byProp++;
            byProp = (byte)((byProp & 0xff) + 1);
        if ((byRemoved & 0xff) < (byProp & 0xff)) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == 0) {
                //H.Joon-2007/03/07>>
                //byArea >>= 1;
                byArea = (byte) ((byArea & 0xFF) >>> 1);
                //<<
                byArea = (byte) Math.min((byArea & 0xff), 0x06);
            } else
                byArea = (byte) Math.min((byArea & 0xff), 0x0c);
        }
        m_Engine.m_stGroup[m_Engine.m_byGrpNum & 0xFF].nHomeSize += (byArea & 0xff);
    }

    byte RemoveSomePositions(byte byPos, byte byWeight) {
        byte byRemoved[] = {0};
        byte byCount = 0;
        byte bit;
        short nBoardPos;

        if (byWeight == 6)
            Remove(byRemoved);

        while (byPos != 0) {
            bit = (byte) (byPos & 1);
            //H.Joon-2007/03/07>>
            //byPos = (byte) ( (byPos >> 1) & 0x7f);
            //HJ_Debug>>
//            System.out.println("byPos_pre = " + byPos);
            //<<
            byPos = (byte)((byPos & 0xff) >>> 1);
            //<<
            //HJ_Debug>>
//            System.out.println("byPos = " + byPos);
            //<<
            if (bit == 1) {
                nBoardPos = m_Engine.m_nMainPosition;
                //HJ_Debug>>
//                System.out.println("byCount = " + byCount);
                //<<
                m_Engine.m_nMainPosition += m_Engine.m_cAroundTable[byCount & 0xFF];
                Remove(byRemoved);
                m_Engine.m_nMainPosition = nBoardPos;
            }
            byCount++;
        }
        return byRemoved[0];
    }

    boolean GetPropValues(byte[] pbyArea, byte[] pbyProp, byte[] pbyPos) {
        byte byWeight[] = {ReversalWeight(m_Engine.m_byGrpNum)};
        byte byArea[] = {byWeight[0]};
        byte byTest[] = {0}
                , byProp = 0, byPos1[] = {0}
                , byPos2 = 0;
        byte byStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition];
        short nBoardPos = m_Engine.m_nMainPosition;
        byte byTemp;

        byte byAddedArea, byAdded;
        byte byTempTest;
        boolean bIsContinued;

        if (byWeight[0] < 0)
            return true;

        m_Engine.m_nMainPosition = (short) (nBoardPos - 1);
        if (StringGrpColor(m_Engine.m_byGrpNum) > 0) { //ZF=0
            //H.Joon-2007/03/07>>
            //byPos1[0] >>= 1;
            byPos1[0] = (byte) ((byPos1[0] & 0xFF) >>> 1);
            //<<
            byTest[0] = 3;
        } else {
            byTest[0] = 0;
            if (false == GetPropValuesOfAroundPos(byTest, byArea, byPos1, byWeight, byStrNum)) {
                m_Engine.m_nMainPosition = nBoardPos;
                return false;
            }
            if (byWeight[0] == 6)
                //byProp += 0x10;
                byProp = (byte)((byProp & 0xff) + 0x10);
        }

        m_Engine.m_nMainPosition = (short) (nBoardPos - 20);
        if (StringGrpColor(m_Engine.m_byGrpNum) > 0) {
            byTest[0] |= 1;
            //H.Joon-2007/03/07>>
            //byPos1[0] >>= 1;
            byPos1[0] = (byte) ((byPos1[0] & 0xFF) >>> 1);
            //<<
        } else {
            if (false == GetPropValuesOfAroundPos(byTest, byArea, byPos1, byWeight, byStrNum)) {
                m_Engine.m_nMainPosition = nBoardPos;
                return false;
            }
            m_Engine.m_nMainPosition = (short) (nBoardPos - 21);
            if ( ( (byTest[0] & 1) == 0x01) || (StringGrpColor(m_Engine.m_byGrpNum) > 0)) {
                byTest[0] &= 0xfe;
                if ( (byPos1[0] & 0x80) != 0)
                    //byProp += 0x10;
                    byProp = (byte)((byProp & 0xff) + 0x10);
            } else {
                byWeight[0] = ReversalWeight(m_Engine.m_byGrpNum);
                if (byWeight[0] == 6) {
                    byPos2 |= 0x20;
                    //byArea[0] += 0x10;
                    byArea[0] = (byte)((byArea[0] & 0xff) + 0x10);
                    byTest[0] |= 0xC0;
                    if ((byPos1[0] & 0x40) == 0x00)
                        //byProp += 0x10;
                        byProp = (byte)((byProp & 0xff) + 0x10);
                } else if ((byPos1[0] & 0x80) == 0x80) {
                    if ( (byPos1[0] & 0x40) == 0x00)
                        //byProp += 0x10;
                        byProp = (byte)((byProp & 0xff) + 0x10);
                    else
                        byTest[0] |= 0xC0;
                }
            }
        }

        m_Engine.m_nMainPosition = (short)(nBoardPos + 1);
        if (StringGrpColor(m_Engine.m_byGrpNum) > 0) {
            byTest[0] |= 1;
            //H.Joon-2007/03/07>>
            //byPos1[0] >>= 1;
            byPos1[0] = (byte) ((byPos1[0] & 0xFF) >> 1);
            //<<
        } else {
            if (false == GetPropValuesOfAroundPos(byTest, byArea, byPos1, byWeight, byStrNum)) {
                m_Engine.m_nMainPosition = nBoardPos;
                return false;
            }
            m_Engine.m_nMainPosition = (short) (nBoardPos - 19);
            if ( ( (byTest[0] & 1) == 0x01) || (StringGrpColor(m_Engine.m_byGrpNum) > 0)) {
                byTest[0] &= 0xfe;
                if ( (byPos1[0] & 0x80) == 0x80)
                    //byProp += 0x10;
                    byProp = (byte)((byProp & 0xff) + 0x10);
            } else {
                byWeight[0] = ReversalWeight(m_Engine.m_byGrpNum);
                if (byWeight[0] == 6) {
                    byPos2 |= 0x40;
                    //byArea[0] += 0x10;
                    byArea[0] = (byte)((byArea[0] & 0xff) + 0x10);
                    byTest[0] |= 0x20;
                    if ( ( (byTest[0] & 0x40) == 0x40) || ( (byPos1[0] & 0x40) == 0x00))
                        //byProp += 0x10;
                        byProp = (byte)((byProp & 0xff) + 0x10);
                } else if ((byPos1[0] & 0x80) == 0x80) {
                    if (((byTest[0] & 0x40) == 0x40) || ( (byPos1[0] & 0x40) == 0x00))
                        //byProp += 0x10;
                        byProp = (byte)((byProp & 0xff) + 0x10);
                    else
                        byTest[0] |= 0x20;
                }
            }
        }

        m_Engine.m_nMainPosition = (short) (nBoardPos + 20);
        if (StringGrpColor(m_Engine.m_byGrpNum) > 0) {
            byTest[0] |= 1;
            //H.Joon-2007/03/07>>
            //byPos1[0] >>= 1;
            byPos1[0] = (byte) ((byPos1[0] & 0xFF) >> 1);
            //<<
        } else {
            if (false == GetPropValuesOfAroundPos(byTest, byArea, byPos1, byWeight, byStrNum)) {
                m_Engine.m_nMainPosition = nBoardPos;
                return false;
            }
            m_Engine.m_nMainPosition = (short) (nBoardPos + 21);
            if (((byTest[0] & 1) == 0x01) || (StringGrpColor(m_Engine.m_byGrpNum) > 0)) {
                byTest[0] &= 0xfe;
                if ( (byPos1[0] & 0x80) == 0x80)
                    //byProp += 0x10;
                    byProp = (byte)((byProp & 0xff) + 0x10);
            } else {
                byWeight[0] = ReversalWeight(m_Engine.m_byGrpNum);
                if (byWeight[0] == 6) {
                    byPos2 |= 0x80;
                    //byArea[0] += 0x10;
                    byArea[0] = (byte)((byArea[0] & 0xff) + 0x10);
                    byTest[0] |= 0x10;
                    if ( ( (byTest[0] & 0x20) == 0x20) || ( (byPos1[0] & 0x40) == 0x00))
                        //byProp += 0x10;
                        byProp = (byte)((byProp & 0xff) + 0x10);
                } else if ( (byPos1[0] & 0x80) == 0x80) {
                    if ( ( (byTest[0] & 0x20) == 0x20) || ( (byPos1[0] & 0x40) == 0x00))
                        //byProp += 0x10;
                        byProp = (byte)((byProp & 0xff) + 0x10);
                    else
                        byTest[0] |= 0x10;
                }
            }
        }

        m_Engine.m_nMainPosition = (short) (nBoardPos + 19);
        if (((byTest[0] & 3) == 0x00) && (StringGrpColor(m_Engine.m_byGrpNum) <= 0)) {
            byWeight[0] = ReversalWeight(m_Engine.m_byGrpNum);
            byTemp = byPos1[0];
            if (byWeight[0] != 6) {
                byTemp &= 0x90;
                if ( (byTemp == (byte)0x90) && ( (byTest[0] & 0x90) == 0x00))
                    //byProp -= 0x10;
                    byProp = (byte)((byProp & 0xff) - 0x10);
            } else {
                byPos2 |= 0x10;
                //byArea[0] += 0x10;
                byArea[0] = (byte)((byArea[0] & 0xff) + 0x10);
                byTemp &= 0x90;
                if (byTemp == 0)
                    byProp = (byte)((byProp & 0xff) + 0x10);
                    //byProp += 0x10;
                else if (byTemp == (byte)0x90) {
                    if ( (byTest[0] & 0x90) == 0x00)
                        //byProp -= 0x10;
                        byProp = (byte)((byProp & 0xff) - 0x10);
                } else {
                    if (byTemp == (byte)0x80) {
                        if ( (byTest[0] & 0x10) == 0x10)
                            //byProp += 0x10;
                            byProp = (byte)((byProp & 0xff) + 0x10);
                    } else if ( (byTest[0] & 0x80) == 0x80)
                        //byProp += 0x10;
                        byProp = (byte)((byProp & 0xff) + 0x10);
                }
            }
        }
        m_Engine.m_nMainPosition = nBoardPos;
        //H.Joon-2007/03/07>>
        //pbyPos[0] = (byte) (byPos2 | (byPos1[0] >> 4));
        pbyPos[0] = (byte) (byPos2 | ((byPos1[0] & 0xFF) >>> 4));
        //<<

        byTempTest = byTest[0];
        byTest[0] = (byte) (byArea[0] & 0x0f);
        byArea[0] &= 0xf0;
        bIsContinued = true;

        if (byStrNum != 0) {
            if ( ((byProp & 0xff) < 0x10) && ( (byTempTest & 0x08) == 0x08))
                byArea[0] = (byte)((byArea[0] & 0xff) + 0x06);
            else
                //byArea[0] += 0x0C;
                byArea[0] = (byte)((byArea[0] & 0xff) + 0x0C);
        } else {
            if ( (byTest[0] != 6) && ((byArea[0] & 0xff) < 0x20))
                return false;

            if ((byProp & 0xff) < 0x20) {
                if ((byArea[0] & 0xff) >= 0x20) {
                    //byArea[0] += 0x0C;
                    byArea[0] = (byte)((byArea[0] & 0xff) + 0x0c);
                    bIsContinued = false;
                }
            } else {
                if ((byArea[0] & 0xff) >= 0x30) {
                    byAddedArea = (byte) ( ((byTest[0] & 0xFF) < 6) ? 3 : 6);
                    //byArea[0] += byAddedArea;
                    byArea[0] = (byte)((byArea[0] & 0xff) + (byAddedArea & 0xff));
                    bIsContinued = false;
                }
            }
            if (bIsContinued == true) {
                byAdded = (byte) AddToGroupInfoOnEmpty();
                if ((byProp & 0xff) < 0x20) {
                    if ((byAdded & 0xff) <= 9)
                        byAddedArea = byAdded;
                    else if ((byArea[0] & 0xff) < 0x10)
                        byAddedArea = 9;
                    else
                        byAddedArea = (byte) ( ((byAdded & 0xff) >= 0x0c) ? 0x0c : 0x09);
                } else if ( (byAdded != 0x0c) && (byAdded != 0x10) && (byAdded != 9))
                    byAddedArea = 0x03;
                else
                    byAddedArea = (byte) ( ((byTest[0] & 0xFF) < 6) ? 3 : 6);

                //byArea[0] += byAddedArea;
                byArea[0] = (byte)((byArea[0] & 0xff) + (byAddedArea & 0xff));
            }
        }

        if (byTest[0] == 6)
            //byArea[0] += 0x10;
            byArea[0] = (byte)((byArea[0] & 0xff) + 0x10);

        if ((byProp & 0xff) > 0x20)
            byProp = 0x20;

        pbyArea[0] = byArea[0];
        //H.Joon-2007/03/07>>
        //pbyProp[0] = (byte) (byProp >> 4);
        pbyProp[0] = (byte) ((byProp & 0xFF) >>> 4);
        //<<
        return true;
    }

    boolean GetPropValuesOfAroundPos(byte[] pbyTest, byte[] pbyArea, byte[] pbyPos, byte[] pbyWeight,
                                     byte byStrNum) {
        byte byStr = m_Engine.m_byBoard[m_Engine.m_nMainPosition];

        if (byStrNum != 0) {
            pbyWeight[0] = ReversalWeight( (byte) (byStrNum ^ 0x01));

            if (pbyWeight[0] == 1) {
                if (byStr != 0)
                    return false;

                pbyTest[0] = (byte) ((pbyTest[0]) ^ 0x08);
                if ( (pbyTest[0] & 0x08) == 0)
                    return false;
            }
        } else {
            pbyWeight[0] = ReversalWeight(m_Engine.m_byGrpNum);
            if ( (char) pbyWeight[0] < 0)
                return false;
            if ((pbyWeight[0] & 0xff) <= 1) {
                if (byStr != 0)
                    return false;
                pbyTest[0] = (byte) ( (pbyTest[0]) ^ 0x08);
                if (((pbyTest[0]) & 0x08) == 0x00)
                    return false;
            }
        }

        if (pbyWeight[0] == 6) {
            //pbyArea[0] += 0x10;
            pbyArea[0] = (byte)((pbyArea[0] & 0xff) + 0x10);
            //H.Joon-2007/03/07>>
            //pbyPos[0] = (byte) ( (pbyPos[0] >> 1) | 0x80);
            pbyPos[0] = (byte)(((pbyPos[0] & 0xFF) >>> 1) | 0x80);
            //<<
        } else
            //H.Joon-2007/03/07>>
            //pbyPos[0] = (byte) ( (pbyPos[0] >> 1) & 0x7f);
            pbyPos[0] = (byte)((pbyPos[0] & 0xFF) >>> 1);
        //<<
        return true;
    }

    byte AddToGroupInfoOnEmpty() {
        byte cAdded[] = {12};
        short nBoardPos = m_Engine.m_nMainPosition;

        m_Engine.m_nMainPosition = (short) (nBoardPos - 1);
        GetAddValueOnEmpty(cAdded);

        m_Engine.m_nMainPosition = (short) (nBoardPos - 20);
        GetAddValueOnEmpty(cAdded);

        m_Engine.m_nMainPosition = (short) (nBoardPos + 1);
        GetAddValueOnEmpty(cAdded);

        m_Engine.m_nMainPosition = (short) (nBoardPos + 20);
        GetAddValueOnEmpty(cAdded);

        m_Engine.m_nMainPosition = nBoardPos;

        cAdded[0] = (byte) Math.max(cAdded[0], 0);

        return cAdded[0];
    }

    void GetAddValueOnEmpty(byte[] pchAdded) {
        byte byWeight;

        if (StringGrpColor(m_Engine.m_byGrpNum) > 0)
            return;

        byWeight = ReversalWeight(m_Engine.m_byGrpNum);

        if ((byWeight & 0xff) <= 3)
            //pchAdded[0] -= 3;
            pchAdded[0] = (byte)((pchAdded[0] & 0xff) - 3);

        if ((byWeight & 0xff) == 5)
            //pchAdded[0] += 4;
            pchAdded[0] = (byte)((pchAdded[0] & 0xff) + 4);

        return;
    }

    void GetAver(int nSum, int nCount, byte[] pchAver, byte[] pchRem) {
        if (nCount == 0)
            nCount = 1;

        pchRem[0] = (byte) (nSum % nCount);
        pchAver[0] = (byte) (nSum / nCount);

        if (pchRem[0] == 0)
            return;

        if ((pchRem[0]) > 0) {
            if ( (pchRem[0]) * 2 > nCount) {
                pchRem[0] -= (byte) nCount;
                pchAver[0] += 1;
            }
            return;
        }

        pchRem[0] = (byte) - pchRem[0];
        if ( (pchRem[0]) * 2 > nCount) {
            pchRem[0] -= (byte) nCount;
            pchAver[0] -= 1;
        }
        pchRem[0] = (byte) - (pchRem[0]);
        return;
    }

    void UpdateWeightTable() {
        short nCount = m_Engine.m_nFirstPos;

        while (nCount > 0) {
            nCount--;
            m_Engine.m_cWeightBoard[(m_Engine.m_nHomeCandiY[nCount] + m_Engine.m_nBoardSize / 2 + 1) * 20
                    + m_Engine.m_nHomeCandiX[nCount] + m_Engine.m_nBoardSize / 2 + 1] ^= 0x0f;
        }
        return;
    }

    void GetMaxMinSum() {
        short i;

        m_Engine.m_nSumOfHomeCandiX = 0;
        m_Engine.m_nSumOfHomeCandiY = 0;
        m_Engine.m_nMaxOfHomeCandiX = -19;
        m_Engine.m_nMaxOfHomeCandiY = -19;
        m_Engine.m_nMinOfHomeCandiX = 19;
        m_Engine.m_nMinOfHomeCandiY = 19;

        for (i = m_Engine.m_nFirstPos; i <= m_Engine.m_nLastPos; i++) {
            m_Engine.m_nSumOfHomeCandiX += m_Engine.m_nHomeCandiX[i];
            m_Engine.m_nMaxOfHomeCandiX = (short) Math.max(m_Engine.m_nMaxOfHomeCandiX,
                    m_Engine.m_nHomeCandiX[i]);
            m_Engine.m_nMinOfHomeCandiX = (short) Math.min(m_Engine.m_nMinOfHomeCandiX,
                    m_Engine.m_nHomeCandiX[i]);

            m_Engine.m_nSumOfHomeCandiY += m_Engine.m_nHomeCandiY[i];
            m_Engine.m_nMaxOfHomeCandiY = (short) Math.max(m_Engine.m_nMaxOfHomeCandiY,
                    m_Engine.m_nHomeCandiY[i]);
            m_Engine.m_nMinOfHomeCandiY = (short) Math.min(m_Engine.m_nMinOfHomeCandiY,
                    m_Engine.m_nHomeCandiY[i]);
        }
        return;
    }

    void RemoveOneCandi() {
        short nSpaceX, nSpaceY, i;

        short[] pnHomeCandiArray;
        short nNextPos = 0, nAttHomeCandi = 0;

        nSpaceX = (short) (m_Engine.m_nMaxOfHomeCandiX - m_Engine.m_nMinOfHomeCandiX);
        nSpaceY = (short) (m_Engine.m_nMaxOfHomeCandiY - m_Engine.m_nMinOfHomeCandiY);

        if (nSpaceX >= nSpaceY) {
            if (nSpaceX < 3)
                return;

            switch (CompareTwoAversX()) {
                case 0:
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMinOfHomeCandiX, m_Engine.m_nHomeCandiX,
                            m_Engine.m_nFirstPos, m_Engine.m_nLastPos);
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMaxOfHomeCandiX, m_Engine.m_nHomeCandiX, nNextPos,
                            m_Engine.m_nLastPos);
                    break;
                case 1:
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMinOfHomeCandiX, m_Engine.m_nHomeCandiX,
                            m_Engine.m_nFirstPos, m_Engine.m_nLastPos);
                    break;
                case -1:
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMaxOfHomeCandiX, m_Engine.m_nHomeCandiX,
                            m_Engine.m_nFirstPos, m_Engine.m_nLastPos);
            }

            switch (CompareTwoAversY()) {
                case 1:
                    nAttHomeCandi = m_Engine.m_nMinOfHomeCandiY;
                    break;
                case 0:
                case -1:
                    nAttHomeCandi = m_Engine.m_nMaxOfHomeCandiY;
            }
            pnHomeCandiArray = m_Engine.m_nHomeCandiY;
        } else {
            if (nSpaceY < 3)
                return;

            switch (CompareTwoAversY()) {
                case 0:
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMinOfHomeCandiY, m_Engine.m_nHomeCandiY,
                            m_Engine.m_nFirstPos, m_Engine.m_nLastPos);
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMaxOfHomeCandiY, m_Engine.m_nHomeCandiY, nNextPos,
                            m_Engine.m_nLastPos);
                    break;
                case 1:
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMinOfHomeCandiY, m_Engine.m_nHomeCandiY,
                            m_Engine.m_nFirstPos, m_Engine.m_nLastPos);
                    break;
                case -1:
                    nNextPos = ArrangeCandiArea(m_Engine.m_nMaxOfHomeCandiY, m_Engine.m_nHomeCandiY,
                            m_Engine.m_nFirstPos, m_Engine.m_nLastPos);
            }

            switch (CompareTwoAversX()) {
                case 1:
                    nAttHomeCandi = m_Engine.m_nMinOfHomeCandiX;
                    break;
                case 0:
                case -1:
                    nAttHomeCandi = m_Engine.m_nMaxOfHomeCandiX;
            }
            pnHomeCandiArray = m_Engine.m_nHomeCandiX;
        }

        for (i = m_Engine.m_nFirstPos; i < nNextPos; i++) {
            if (nAttHomeCandi == pnHomeCandiArray[i]) {
                Exchange(i, m_Engine.m_nFirstPos);
                break;
            }
        }

        m_Engine.m_nFirstPos++;

        GetMaxMinSum();
        RemoveOneCandi();

        return;
    }

    short ArrangeCandiArea(short nAttHomeCandi, short[] pnHomeCandiArray, short nStartPos, short nEndPos) {
        short i, nNextPos = nStartPos;

        for (i = nStartPos; i <= nEndPos; i++) {
            if (pnHomeCandiArray[i] != nAttHomeCandi)
                continue;

            if (i != nNextPos)
                Exchange(i, nNextPos);

            nNextPos++;
        }

        return nNextPos;
    }

    void Exchange(short nFoundPos, short nNextPos) {
        short nTempX, nTempY;

        nTempX = m_Engine.m_nHomeCandiX[nNextPos];
        nTempY = m_Engine.m_nHomeCandiY[nNextPos];

        m_Engine.m_nHomeCandiX[nNextPos] = m_Engine.m_nHomeCandiX[nFoundPos];
        m_Engine.m_nHomeCandiY[nNextPos] = m_Engine.m_nHomeCandiY[nFoundPos];

        m_Engine.m_nHomeCandiX[nFoundPos] = nTempX;
        m_Engine.m_nHomeCandiY[nFoundPos] = nTempY;
    }

    short CompareTwoAversY() {
        byte cAver[] = {0}
                , cRem[] = {0};
        short nSumOfMaxAndMin = (short) (m_Engine.m_nMaxOfHomeCandiY + m_Engine.m_nMinOfHomeCandiY);

        GetAver(m_Engine.m_nSumOfHomeCandiY * 2, m_Engine.m_nLastPos - m_Engine.m_nFirstPos + 1, cAver, cRem);

        if (cAver[0] != nSumOfMaxAndMin)
            return (short) ( (cAver[0] > nSumOfMaxAndMin) ? 1 : -1);

        if (cRem[0] == 0)
            return 0;

        return (short) ( (cRem[0] > 0) ? 1 : -1);
    }

    short CompareTwoAversX() {
        byte cAver[] = {0}
                , cRem[] = {0};
        short nSumOfMaxAndMin = (short) (m_Engine.m_nMaxOfHomeCandiX + m_Engine.m_nMinOfHomeCandiX);

        GetAver(m_Engine.m_nSumOfHomeCandiX * 2, m_Engine.m_nLastPos - m_Engine.m_nFirstPos + 1, cAver, cRem);

        if (cAver[0] != nSumOfMaxAndMin)
            return (short) ( (cAver[0] > nSumOfMaxAndMin) ? 1 : -1);

        if (cRem[0] == 0)
            return 0;

        return (short) ( (cRem[0] > 0) ? 1 : -1);
    }

    boolean UpdateGroupInfo5() {
        if (m_Engine.m_nLastPos - m_Engine.m_nFirstPos >= 1)
            return false;

        m_Engine.m_nMainPosition = (short) ( (m_Engine.m_nHomeCandiY[m_Engine.m_nLastPos] +
                m_Engine.m_nBoardSize / 2 + 1) * 20
                + m_Engine.m_nHomeCandiX[m_Engine.m_nLastPos] +
                m_Engine.m_nBoardSize / 2 + 1);

        if (m_Engine.m_nCount >= 0)
            m_Engine.m_nAddPos[m_Engine.m_nCount++] = m_Engine.m_nMainPosition;

        if ( (byte) m_Engine.m_byBoard[m_Engine.m_nMainPosition] == 0)
            m_Engine.m_stGroup[m_Engine.m_byGrpNum & 0xFF].nHomeSize +=
                    (byte) (Math.min(AddToGroupInfoOnEmpty(), 9));
            //Why 9 - > 12 ???
        else
            AddToGroupInfoOnNoEmpty(m_Engine.m_byBoard[m_Engine.m_nMainPosition]);

        return true;
    }

    void AddToGroupInfoOnNoEmpty(byte byStrNum) {
        short nBoardPos = m_Engine.m_nMainPosition;
        byte byTest[] = {0};

        m_Engine.m_nMainPosition = (short) (nBoardPos - 1);
        if (false == GetTestValue(byTest, byStrNum)) {
            m_Engine.m_nMainPosition = nBoardPos;
            return;
        }

        m_Engine.m_nMainPosition = (short) (nBoardPos - 20);
        if (false == GetTestValue(byTest, byStrNum)) {
            m_Engine.m_nMainPosition = nBoardPos;
            return;
        }

        m_Engine.m_nMainPosition = (short) (nBoardPos + 1);
        if (false == GetTestValue(byTest, byStrNum)) {
            m_Engine.m_nMainPosition = nBoardPos;
            return;
        }

        m_Engine.m_nMainPosition = (short) (nBoardPos + 20);
        if (false == GetTestValue(byTest, byStrNum)) {
            m_Engine.m_nMainPosition = nBoardPos;
            return;
        }

        if ( (byTest[0] & 0x08) != 0)
            m_Engine.m_stGroup[m_Engine.m_byGrpNum & 0xFF].nHomeSize += 0x06;
        else
            m_Engine.m_stGroup[m_Engine.m_byGrpNum & 0xFF].nHomeSize += 0x0c;
    }

    boolean GetTestValue(byte[] pbyTest, byte byStrNum) {
        short nCompare = StringGrpColor( (byte) (byStrNum ^ 0x01));
        byte byWeight;

        if (nCompare > 0)
            return true;

        byWeight = ReversalWeight( (byte) (byStrNum ^ 0x01));

        if (byWeight != 1)
            return true;

        if (nCompare < 0) // ??? What Case is Such Case ? Two Stones are Equal String.
            return false;

        pbyTest[0] = (byte) (pbyTest[0] ^ 0x08);

        if ( (pbyTest[0] & 0x08) != 0)
            return true;

        return false;

    }

    short StringGrpColor(byte byNum) {
        byte byStrNum;

        if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xf0)
            return 2; //Wall

        byStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPosition];

        if (byStrNum == 0)
            return 0;

        if ( (IsWhite(byStrNum)) == (IsWhite(byNum)))
            return 1;
        else
            return -1;
    }

    boolean HomeDetBySpaceSur(byte byGrpNumber, byte[] byPlusWeight, byte[] pcGet, short nPos) {
        byte byWeight;

        short nResult = StringGrpColor(byGrpNumber);

        if (nResult > 0)
            return false;

        if (nResult == 0) {
            byWeight = ReversalWeight(byGrpNumber);
            if ((byWeight & 0xFF) < 3) {
                pcGet[0] -= 3;
                return false;
            }
            if (byWeight == 3) {
                pcGet[0] -= 2;
                return false;
            }
            if (true == SpecialValue(byWeight)) {
                if ((byPlusWeight[0] & 0xff) > 5)
                    return false;

                if ((byWeight & 0xff) > (byPlusWeight[0] & 0xff))
                    return true;

                pcGet[0] += 4;
                return false;
            }
        }

        if (byPlusWeight[0] != 6)
            return true;

        if (m_Engine.m_cWeightBoard[nPos] == byPlusWeight[0]) //
            m_Engine.m_cWeightBoard[nPos] = 9;
        else
            m_Engine.m_cWeightBoard[nPos] = -9;

        return true;

    }

    byte ReversalWeight(byte byGrpNum) {
        byte byWeight = (byte) m_Engine.m_cWeightBoard[m_Engine.m_nMainPosition];

        if ( (byGrpNum & 0x01) == 0x00)
            byWeight = (byte)((~byWeight) + 1);

        if ((byWeight) < 0)
            byWeight = 0;

        return byWeight;
    }

    void UpdateInfo2_3(byte byGrpNum) {
        m_Engine.m_stGroup[byGrpNum & 0xFF].nBattleGain = 0;
        m_Engine.m_byHIResult = (byte) m_Engine.m_stGroup[byGrpNum & 0xFF].nAliveDead;
        if (m_Engine.m_byHIResult == 0) {
            m_Engine.m_pbyTmpBitGroupRelAdr -= 0x0a;
            return;
        }

        m_Engine.m_byLOResult = (byte) m_Engine.m_stGroup[byGrpNum & 0xFF].nImportance;

//  EqGrpInflu()

        if ( (byGrpNum & 0x01) == 0x01)
            InterrelGSearch( (byte) 0xaa, byGrpNum); // EqGrpInflu()
        else
            InterrelGSearch( (byte) 0x55, byGrpNum); // EqGrpInflu()

        m_Engine.m_stGroup[byGrpNum & 0xFF].nAliveDead = (short)(m_Engine.m_byHIResult & 0xff);
        m_Engine.m_stGroup[byGrpNum & 0xFF].nImportance = (short)(m_Engine.m_byLOResult & 0xff);
    }

    void MoveDataSave() {
        m_Engine.m_nDifBackUp = m_Engine.m_nDifOfTwoT9;

        MEMCPY(m_Engine.m_TempStringStateArea, m_Engine.m_wStatus, m_Engine.m_wStatus.length);
        MEMCPY(m_Engine.m_TempWeightTableArea, m_Engine.m_cWeightBoard, m_Engine.m_cWeightBoard.length);
        m_Engine.m_bMoveDataFlag = true;
    }

    void KillStringInGroup(byte byGroupNumber) {
        short nAxisPos, nTpPos;
        byte byStringNumber;
        for (nAxisPos = STARTPOS; nAxisPos < ENDPOS; nAxisPos++) {
//		if( byBoard[nAxisPos] == -16 )
//			continue;
            if (m_Engine.m_byGroupBoard[nAxisPos] != byGroupNumber)
                continue;

            byStringNumber = m_Engine.m_byBoard[nAxisPos];

            if (byStringNumber == 0)
                continue;
            if ( (m_Engine.m_byLiberties[byStringNumber & 0xFF] & 0x80) == 0) { // by KWJ : -> & 0xFF
                if ( ( (byStringNumber ^ byGroupNumber) & 1) != 0) {
                    m_Engine.m_wStatus[byStringNumber & 0xFF] &= 0xfffb;
                    m_Engine.m_wStatus[byStringNumber & 0xFF] |= 0x400;
                } else {
                    m_Engine.m_wStatus[byStringNumber & 0xFF] |= 4;
                    LetSurStrAlive(byStringNumber);
                    // Let Sur String Alive.
                }
                m_Engine.m_byLiberties[byStringNumber & 0xFF] |= 0x80;
            }
            nTpPos = m_Engine.m_nMainPosition;

            m_Engine.m_nMainPosition = nAxisPos;

            m_Engine.m_nBoardPos = m_Engine.m_nMainPosition;
            ExpressTempArea();

            m_Engine.m_nMainPosition = nTpPos;
        }

        for (byStringNumber = 1; (byStringNumber & 0xFF) < MAX_STRINGCOUNT; byStringNumber++)
            m_Engine.m_byLiberties[byStringNumber & 0xFF] &= 0x7f;

        return;
    }

    void LetSurStrAlive(byte byStringNumber) {
        byte byNumber;

        for (m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition++) {
            if (m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xf0)
                continue;

            byNumber = m_Engine.m_byBoard[m_Engine.m_nMainPosition];

            if (((byNumber & 0xff) < 1) || (byNumber == byStringNumber))
                continue;
            if (false == IssSameString(byStringNumber))
                continue;

            m_Engine.m_wStatus[byNumber] &= 0xffFB;
            m_Engine.m_wStatus[byNumber] |= 0x400;
        }
        return;
    }

    boolean IssSameString(byte byStringNumber) {
        if (m_Engine.m_byBoard[m_Engine.m_nMainPosition - 20] == byStringNumber
                || m_Engine.m_byBoard[m_Engine.m_nMainPosition + 20] == byStringNumber
                || m_Engine.m_byBoard[m_Engine.m_nMainPosition - 1] == byStringNumber
                || m_Engine.m_byBoard[m_Engine.m_nMainPosition + 1] == byStringNumber)
            return true;
        return false;
    }

    void MoveDataLoad() {

        m_Engine.m_nDifOfTwoT9 = m_Engine.m_nDifBackUp;

        MEMCPY(m_Engine.m_wStatus, m_Engine.m_TempStringStateArea, m_Engine.m_wStatus.length);
        MEMCPY(m_Engine.m_cWeightBoard, m_Engine.m_TempWeightTableArea, m_Engine.m_cWeightBoard.length);
    }

    void RelativeGoodDegree(short nGroupNumber) {
        byte byWhiteBlackBit;
        int pbyTemp;
        short nTmpFlag;

        if ( (nGroupNumber & 0x01) == 0)
            byWhiteBlackBit = (byte) 0xaa;
        else
            byWhiteBlackBit = 0x55;

        m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;
        InterrelGSearch(byWhiteBlackBit, (byte) nGroupNumber); //OtherGrpCalc()

        if ( (m_Engine.m_byLOResult != 0x00) && (m_Engine.m_byHIResult != 0x00)) {
            pbyTemp = m_Engine.m_pbyTmpBitGroupRelAdr;
            nTmpFlag = m_Engine.m_nFuncControlFlag;

            GoodDegreeCalc( (byte) nGroupNumber);

            m_Engine.m_nFuncControlFlag = nTmpFlag;
            m_Engine.m_pbyTmpBitGroupRelAdr = pbyTemp;
        }
        return;
    }

    void GoodDegreeCalc(byte byGrpNumber )
    {
        short	 bySurEntireExt = 0;
        short	 byTotalWeight = 0;
        short	 nSurGrpCount;
        byte cCentreCompetition,cCalcCompetition;
        short byEntireEyeSize = 0;
        short byCentreAliveDead,bySurImport;
        byte byTemp;
        byte byEntireImport;
        short byTempEyeSize;

        byte byBitWhiteBlack;

        short	ulTemp1;
        short	ulTemp2;
        short	nTemp3;
        short wInfo = 0;
        short bySumImport = 0;

        cCentreCompetition = (byte)m_Engine.m_stGroup[byGrpNumber & 0xFF].nCompetition;

        if( ( cCentreCompetition > 4 ) || ( cCentreCompetition == (byte)0x80 ) )
            return;

        m_Engine.m_byHIResult = 0;

        m_Engine.m_wCtrlGroupNum = (short)(m_Engine.m_byLOResult & 0xFF);

        m_Engine.m_byBufForOtherSurG[m_Engine.m_wCtrlGroupNum] = byGrpNumber;
        //Adr_MainProc:
        do
        {
            if(m_Engine.m_nGameLevel < 4)
                return;
//            if (m_Engine.m_nGameLevel >= 4) {
            //Ht2
            //start no
            if (!m_Engine.m_bMoveDataFlag)
                MoveDataSave();
//end
            ulTemp1 = m_Engine.m_wWhiteTSize9;
            ulTemp2 = m_Engine.m_wBlackTSize9;
            nTemp3 = m_Engine.m_nDifOfTwoT9;

            KillStringInGroup(byGrpNumber);
            m_Engine.m_byNewGroupNumber |= 0x80;

            BoardWeightCalc();

            m_Engine.m_byNewGroupNumber &= 0x7f;
            byGrpNumber = m_Engine.m_byBufForOtherSurG[0];

            byTempEyeSize = m_Engine.m_stGroup[byGrpNumber &
                    0xFF].nHomeSize;

            LiveDeadGrpCalc(byGrpNumber, (short) - 1);
            MoveDataLoad();

            byEntireEyeSize = m_Engine.m_stGroup[byGrpNumber &
                    0xFF].nHomeSize;
            m_Engine.m_stGroup[byGrpNumber &
                    0xFF].nHomeSize = byTempEyeSize;

            m_Engine.m_wWhiteTSize9 = ulTemp1;
            m_Engine.m_wBlackTSize9 = ulTemp2;
            m_Engine.m_nDifOfTwoT9 = nTemp3;

//		wDI = m_wCtrlGroupNum;

            if ((byEntireEyeSize & 0xff) >= 0x18) {
                m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;
                break;
            }

            bySurEntireExt = 0;
            byTotalWeight = 0;

            nSurGrpCount = (short) m_Engine.m_wCtrlGroupNum;
            while (nSurGrpCount >= 0) {
                byGrpNumber = m_Engine.m_byBufForOtherSurG[nSurGrpCount--];
                bySurEntireExt += m_Engine.m_stGroup[byGrpNumber &
                        0xFF].nExtendSize; // by KWJ : default;
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize |= 0x80;

                if (bySurEntireExt >= 0x20) { //bySurEntireExt is short type.
                    m_Engine.m_byHIResult = m_Engine.m_byLOResult = 0;
                    break;
                }

                if (0xff - byTotalWeight >= //byTotalWeight is short type.
                        m_Engine.m_stGroup[byGrpNumber & 0xFF].nTotalSize) // by KWJ : -> & 0xFF
                    byTotalWeight += m_Engine.m_stGroup[byGrpNumber &
                            0xFF].nTotalSize;
                else
                    byTotalWeight = 0xff;
            }
//            }

            byGrpNumber = (byte) m_Engine.m_nTotalGroupCount; //m_nTotalGroupCount;
            ++byGrpNumber;

            m_Engine.m_stGroup[byGrpNumber & 0xFF].nTotalSize = byTotalWeight;
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nHomeSize = byEntireEyeSize;
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize = bySurEntireExt;

            wInfo = LiveDeadDegree((byte) byEntireEyeSize, (byte) bySurEntireExt,
                    byGrpNumber);

            if (HIBYTE(wInfo) == 0)
                break;

            m_Engine.m_byHIResult = HIBYTE(wInfo);
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nAliveDead = (short)(m_Engine.m_byHIResult & 0xff);
            m_Engine.m_byLOResult = LOBYTE(wInfo);
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance = (short)(m_Engine.m_byLOResult & 0xff);

            nSurGrpCount = (short) m_Engine.m_wCtrlGroupNum;
            byGrpNumber = m_Engine.m_byBufForOtherSurG[0];
            m_Engine.m_nFuncControlFlag = 8; //ArmiesForRGoodD()

            if ((byGrpNumber & 1) == 0)
                byBitWhiteBlack = 0x55;
            else
                byBitWhiteBlack = (byte)0xaa;

            while (nSurGrpCount >= 0) {
                byGrpNumber = m_Engine.m_byBufForOtherSurG[nSurGrpCount--];
                m_Engine.m_pbyTmpBitGroupRelAdr = ((byGrpNumber & 0xFF) + 1) * 0x0a - 1;

                if (InterrelGSearch(byBitWhiteBlack, byGrpNumber) == false)
                    break;
            }
        } while (false);

        byGrpNumber = (byte)m_Engine.m_nTotalGroupCount;

        do
        {
            m_Engine.m_stGroup[byGrpNumber & 0xFF].nExtendSize &= 0x7f;
            --byGrpNumber;
        }while( byGrpNumber != 0 );

        byEntireImport = m_Engine.m_byLOResult;

        if( (m_Engine.m_byHIResult & 0xff) >= 0xfe )
            return;
//$Adr10:
        nSurGrpCount = m_Engine.m_wCtrlGroupNum;
        byGrpNumber = m_Engine.m_byBufForOtherSurG[nSurGrpCount];

        byCentreAliveDead = m_Engine.m_stGroup[byGrpNumber & 0xFF].nAliveDead;

        if( (byEntireImport & 0xff) > 0 )
        {
            bySumImport = 0;

            while( nSurGrpCount >= 0 )
            {
                byGrpNumber = m_Engine.m_byBufForOtherSurG[nSurGrpCount--];

                if( m_Engine.m_stGroup[byGrpNumber & 0xFF].nAliveDead == 0xff )
                    continue;
//upversion
//			if( ( m_wStatus[0] & 0x800 ) == 0 )
                if( m_Engine.m_stGroup[byGrpNumber & 0xFF].nImGirth < 4 )
                    continue;

                if ( 0xff - bySumImport >= m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance )
                    bySumImport += m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance;
                else
                {
                    bySumImport = 0xff;
                    break;
                }
            }

            if( bySumImport <= (byEntireImport & 0xff) )
                return;
        }

        nSurGrpCount = m_Engine.m_wCtrlGroupNum;

        while( nSurGrpCount > 0 )
        {
            byGrpNumber = m_Engine.m_byBufForOtherSurG[--nSurGrpCount];

            if( m_Engine.m_stGroup[byGrpNumber & 0xFF].nAliveDead == 0xff )
                continue;

            if( m_Engine.m_stGroup[byGrpNumber & 0xFF].nImGirth < 4 )
                continue;

            bySurImport = m_Engine.m_stGroup[byGrpNumber & 0xFF].nImportance;

            if( bySurImport == 0 )
                continue;

            if( byEntireImport != 0 )
                bySurImport -= ( bySurImport * (byEntireImport & 0xff) / bySumImport );

            if( byCentreAliveDead < 0xfe )
                bySurImport = (byte)(( bySurImport * byCentreAliveDead + 0x80 ) / 0x100);

            cCalcCompetition = cCentreCompetition;

            if( cCalcCompetition > 0 )
            {
                byTemp = (byte)(cCalcCompetition & 1);
                cCalcCompetition >>= 1;
                ++ cCalcCompetition;
                bySurImport >>= cCalcCompetition;

                if( byTemp != 0 )
                {
                    byTemp = (byte)bySurImport;
                    byTemp = (byte) ((byTemp & 0xFF) >> 1);
                    ++ byTemp;
                    byTemp = (byte) ((byTemp & 0xFF) >> 1);
                    bySurImport -= (byTemp & 0xff);
                }
            }
            else if( cCalcCompetition >= -27 )
            {
                cCalcCompetition = (byte)- cCalcCompetition;

                byTemp = (byte)cCalcCompetition;
                cCalcCompetition >>= 2;
                ++cCalcCompetition;
                m_Engine.m_byLOResult = (byte)bySurImport;
                bySurImport >>= (cCalcCompetition & 0xff);
                cCalcCompetition = (byte)m_Engine.m_byLOResult;
                byTemp &= 3;

                if( byTemp != 0 )
                {
                    if( byTemp == 2 )
                        byTemp = (byte)0xB5;
                    else if( (byTemp & 0xFF) < 2 )// by KWJ : -> & 0xFF
                        byTemp = (byte)0xD7;
                    else
                        byTemp = (byte)0x98;

                    bySurImport = (byte)(( bySurImport * (byTemp & 0xff) + 0x80 ) / 0x100);
                }

                bySurImport = (short)-bySurImport;
                bySurImport += (cCalcCompetition & 0xff);
            }

            if( 0xff - bySurImport >= m_Engine.m_stGroup[byGrpNumber & 0xFF].nBattleGain )
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nBattleGain += bySurImport;
            else
                m_Engine.m_stGroup[byGrpNumber & 0xFF].nBattleGain = 0xff;
        }
        return;
    }


/*
    void GoodDegreeCalc(byte byGrpNumber) {
        short nSurGrpCount;
        byte cCentreCompetition, cCalcCompetition;
        short bySumImport = 0;
        short wInfo = 0;
        short byCentreAliveDead, bySurImport;
        byte byTemp;
        byte byEntireImport;

        cCentreCompetition = (byte) m_Engine.m_stGroup[byGrpNumber].nCompetition;

        if ( (cCentreCompetition > 4) || (cCentreCompetition == 0x80))
            return;

        m_Engine.m_byHIResult = 0;

        m_Engine.m_wCtrlGroupNum = (short) m_Engine.m_byLOResult;

        m_Engine.m_byBufForOtherSurG[m_Engine.m_wCtrlGroupNum] = byGrpNumber;
        byEntireImport = 0;
        nSurGrpCount = m_Engine.m_wCtrlGroupNum;
        byGrpNumber = m_Engine.m_byBufForOtherSurG[nSurGrpCount];

        byCentreAliveDead = m_Engine.m_stGroup[byGrpNumber].nAliveDead;

        if (byEntireImport > 0) {
            bySumImport = 0;

            while (nSurGrpCount >= 0) {
                byGrpNumber = m_Engine.m_byBufForOtherSurG[nSurGrpCount--];

                if (m_Engine.m_stGroup[byGrpNumber].nAliveDead == (byte) 0xff)
                    continue;
                if (m_Engine.m_stGroup[byGrpNumber].nImGirth < 4)
                    continue;

                if (0xff - bySumImport >= m_Engine.m_stGroup[byGrpNumber].nImportance)
                    bySumImport += m_Engine.m_stGroup[byGrpNumber].nImportance;
                else {
                    bySumImport = 0xff;
                    break;
                }
            }

            if (bySumImport <= byEntireImport)
                return;
        }

        nSurGrpCount = m_Engine.m_wCtrlGroupNum;

        while (nSurGrpCount > 0) {
            byGrpNumber = m_Engine.m_byBufForOtherSurG[--nSurGrpCount];

            if (m_Engine.m_stGroup[byGrpNumber].nAliveDead == (byte) 0xff)
                continue;

            if (m_Engine.m_stGroup[byGrpNumber].nImGirth < 4)
                continue;

            bySurImport = m_Engine.m_stGroup[byGrpNumber].nImportance;

            if (bySurImport == 0)
                continue;

            if (byCentreAliveDead < 0xfe)
                bySurImport = (byte) ( (bySurImport * byCentreAliveDead + 0x80) / 0x100);

            cCalcCompetition = cCentreCompetition;

            if (cCalcCompetition > 0) {
                byTemp = (byte) (cCalcCompetition & 1);
                cCalcCompetition >>= 1;
                ++cCalcCompetition;
                bySurImport >>= cCalcCompetition;

                if (byTemp != 0) {
                    byTemp = (byte) bySurImport;
                    //H.Joon-2007/03/07>>
                    //byTemp >>= 1;
                    byTemp >>>= 1;
                    //<<
                    ++byTemp;
                    //H.Joon-2007/03/07>>
                    //byTemp >>= 1;
                    byTemp >>>= 1;
                    //<<
                    bySurImport -= byTemp;
                }
            } else if (cCalcCompetition >= -27) {
                cCalcCompetition = (byte) - cCalcCompetition;

                byTemp = (byte) cCalcCompetition;
                cCalcCompetition >>= 2;
                ++cCalcCompetition;
                m_Engine.m_byLOResult = (byte) bySurImport;
                bySurImport >>= (byte) cCalcCompetition;
                cCalcCompetition = (byte) m_Engine.m_byLOResult;
                byTemp &= 3;

                if (byTemp != 0) {
                    if (byTemp == 2)
                        byTemp = (byte) 0xB5;
                    else if (byTemp < 2)
                        byTemp = (byte) 0xD7;
                    else
                        byTemp = (byte) 0x98;

                    bySurImport = (byte) ( (bySurImport * byTemp + 0x80) / 0x100);
                }

                bySurImport = (byte) - bySurImport;
                bySurImport += (byte) cCalcCompetition;
            }

            if (0xff - bySurImport >= m_Engine.m_stGroup[byGrpNumber].nBattleGain)
                m_Engine.m_stGroup[byGrpNumber].nBattleGain += bySurImport;
            else
                m_Engine.m_stGroup[byGrpNumber].nBattleGain = 0xff;
        }
        return;
    }
*/

    void AliveNeighborsOnMyDead(short byStrNum) {
        byte byStr;
        short i, k;

        m_Engine.m_nProfitStrs = 0;
        m_Engine.m_wStatus[byStrNum] = 0x01ff;

        for (i = STARTPOS; i < ENDPOS; i++) {
            byStr = m_Engine.m_byBoard[i];
            if ( (byStr == 0) || ((byStr & 0xFF) == byStrNum) || (byStr == INITVALUE) || // by KWJ : -> & 0xFF
                    (IsSameStringg(i, (byte)byStrNum) == false))
                continue;

            for (k = 0; k < m_Engine.m_nAttachedStrs; k++) {
                if (byStr == m_Engine.m_byAttachedStr[k])
                    break;
            }
            if (k < m_Engine.m_nAttachedStrs)
                continue;

            m_Engine.m_byAttachedStr[m_Engine.m_nAttachedStrs++] = byStr;
            if ( (m_Engine.m_wStatus[byStr & 0xFF] & 0x0008) == 0) {
                if ( (m_Engine.m_wStatus[byStr & 0xFF] & 0x0800) == 0)
                    m_Engine.m_nProfitStrs++;
                m_Engine.m_wStatus[byStr & 0xFF] &= 0xff03;
                m_Engine.m_wStatus[byStr & 0xFF] |= 0xff00;
            }
        }
    }

    void StatusOfRelStrs(short byStrNum, short wPoint) {
        short wResult, wCount;
        short byStr, bySame;
        int pnMove;
        int pnResult;
        short wTempPoint;
        try {

            for (byStr = 1; byStr < MAX_STRINGCOUNT; byStr++) {
                if (byStr == byStrNum)
                    continue;
                if ((bySame = (short)((byStr ^ m_Engine.m_byTurnColor) & 1)) != 0)
                    wResult = m_Engine.m_wResultInSecond[byStr];
                else
                    wResult = m_Engine.m_wResultInFirst[byStr];
                if (wResult == (short) 0xffff)
                    continue;
                pnResult = (wResult & 0xFFFF);
//		if (pResult->byRelStr) continue;

                //wCount = pResult->byCount;
                wCount = m_Engine.m_pResultArea[pnResult];
                pnMove = pnResult + sizeofSIMULRESULT; //sizeofSIMULMOVE -> sizeofSIMULRESULT
                for (; wCount != 0; wCount--, pnMove += sizeofSIMULMOVE) {
                    //pMove->wPoint
                    wTempPoint = (short)(((m_Engine.m_pResultArea[pnMove + 1] & 0xffff) << 8) |
                            m_Engine.m_pResultArea[pnMove]);
                    if (wTempPoint != wPoint)
                        continue;
                    if (bySame != 0) AliveNeighborsOnMyDead(byStr);
                    else if ((((byStr ^ m_Engine.m_nComStoneColor) & 1) != 0) ||
                            (m_Engine.m_pResultArea[pnMove + 2] > 0))//pMove->cStatus
                        m_Engine.m_wStatus[byStr] = (short) 0xff01;
                    m_Engine.m_nStnsOfRelStrs += m_Engine.m_nStoneCount[byStr];
                    break;
                }
            }
        } catch (Exception e) {
            //System.out.println("StatusOfRelStrs");
        }
    }

    short OldBoardScoreCalc() {
        short nTempBoardPos = m_Engine.m_nBoardPos;
        short wFormerWTSize = m_Engine.m_wWhiteTSize;
        short wFormerBTSize = m_Engine.m_wBlackTSize;

        m_Engine.m_nTotal++;

        if (m_Engine.m_nBoardPos != 0) {
            ExpressTempArea();
        }

        BoardWeightCalc();
        //HJ_Debug>>
//        System.out.println("m_nBoardPos = " + m_Engine.m_nBoardPos);
//        OUTPUT("m_cWeightBoard", m_Engine.m_cWeightBoard, 20);
        //<<

        m_Engine.m_cBlackCountChange = (short) (m_Engine.m_byBlackGroupCount & 0xFF);
        m_Engine.m_cWhiteCountChange = (short) (m_Engine.m_byWhiteGroupCount & 0xFF);
        GroupScoreCalc();
        m_Engine.m_nDifOfTerritory = (short) (m_Engine.m_nDifOfTwoT9 - m_Engine.m_nDifOfTerritory);
        m_Engine.m_cBlackCountChange -= (byte)m_Engine.m_byBlackGroupCount;
        m_Engine.m_cWhiteCountChange -= (byte)m_Engine.m_byWhiteGroupCount;
        m_Engine.m_nWhiteTChange = (short) (wFormerWTSize - m_Engine.m_wWhiteTSize);
        m_Engine.m_nBlackTChange = (short) (wFormerBTSize - m_Engine.m_wBlackTSize);

        m_Engine.m_nChangedTSize = (short) (m_Engine.m_nDifOfTerritory - m_Engine.m_nWhiteTChange +
                m_Engine.m_nBlackTChange);

        if (m_Engine.m_byTurnColor == IS_BLACK) //black
            m_Engine.m_nChangedTSize = (short) - m_Engine.m_nChangedTSize;

        m_Engine.m_nDifOfTerritory = m_Engine.m_nDifOfTwoT9;
        m_Engine.m_nChangedTSize += (m_Engine.m_nDeadStoneCount - m_Engine.m_nOldDeadCount) * 6;

        m_Engine.m_nBoardPos = nTempBoardPos;

        if (m_Engine.m_nChangedTSize < -12)
            return -2;
        if (m_Engine.m_nChangedTSize < -3)
            return -1;
        return ( (short) ( (m_Engine.m_nChangedTSize + 3) / 6));
    }

    short GainOfNewMove(byte byWhereCall, short nScoreBase) {
        short nMyT, nYouT;
        byte byMyG, byYouG;
        short nTemp;

        m_Engine.m_nMainPosition = m_Engine.m_nBoardPos; //

        m_Engine.WhereCall = byWhereCall;

        if (m_Engine.m_byTurnColor == IS_BLACK) {
            nMyT = m_Engine.m_nBlackTChange;
            nYouT = m_Engine.m_nWhiteTChange;
            byMyG = (byte) m_Engine.m_cWhiteCountChange;
            byYouG = (byte) m_Engine.m_cBlackCountChange;
        } else {
            nMyT = m_Engine.m_nWhiteTChange;
            nYouT = m_Engine.m_nBlackTChange;
            byMyG = (byte) m_Engine.m_cBlackCountChange;
            byYouG = (byte) m_Engine.m_cWhiteCountChange;
        }
        nYouT >>= 1;
        do {
            if (nMyT < 0) {
                nMyT >>= 1;
                if (((byte) byMyG < 0) && (IsCutByFirPos() == false))
                    break;
            }

            nYouT = m_Engine.m_nNewTerritory;

            if (nYouT >= 0)
                return (byte) (Math.min(0xfd, (nYouT + 3) / 6));

            if (nYouT <= -12) {
                if (((nMyT > 0) && (nYouT + nMyT > -12)) || (nScoreBase > -2))
                    return -1;
                return -2;
            }

            if (nYouT < -3)
                return -1;
            else
                return 0x00;
        } while (false);

        if (byWhereCall == 0) {
            nYouT = m_Engine.m_nNewTerritory;
            if (nYouT >= 0)
                return (byte) (Math.min(0xfd, (nYouT + 3) / 6));

            if (nYouT <= -12) {
                if ( ( (nMyT > 0) && (nYouT + nMyT > -12)) || (nScoreBase > -2))
                    return -1;
                return -2;
            }

            if (nYouT < -3)
                return -1;
            else
                return 0x00;
        }

        if (nYouT <= 0)
            nYouT >>= 1;
        else {
            nYouT = (short) - nYouT;

            if (nYouT >= nMyT)
                nYouT >>= 1;
            else
                nYouT = (short)(((nMyT - nYouT) >> 2) + (nMyT >> 1));
        }

        nYouT += nMyT;
        nMyT >>= 1;

        if ((byte)byWhereCall > 0)
            nYouT = (short) Math.min(nYouT - nMyT, 0);
        else {
            if (byMyG == (byte) 0xff) {
                nTemp = (short) (m_Engine.m_nDifOfTerritory - m_Engine.m_nTempDifOfTerritory);

                if ( (m_Engine.m_byTurnColor & 1) == 0)
                    nTemp = (short) - nTemp;
                if (nTemp > 0) {
                    nTemp >>= 1;
                    nYouT += nTemp;
                }
                nMyT >>= 1;
                nYouT += nMyT;
                if (nYouT >= 0)
                    nYouT = 0;
            } else if ((byte) byYouG < 0) {
                nMyT >>= 1;
                nYouT += nMyT;
                if (nYouT >= 0)
                    nYouT = 0;
            } else
                nYouT = (short) Math.min(nYouT - nMyT, 0);
        }

        nTemp = m_Engine.m_nNewTerritory;

        if ( (nYouT < 0) && (nTemp > -12) && (nTemp < 0))
            return -1;

        nYouT += nTemp;

        if (nYouT >= 0)
            return (byte) (Math.min(0xfd, (nYouT + 3) / 6));

        if (nTemp >= 0) {
            if (nYouT >= -3)
                return 0;
            if (nYouT > -12)
                return -1;
        }

        if ( ( (nMyT > 0) && (nMyT + nYouT > -12)) || (nScoreBase > -2))
            return -1;
        return -2;
    }

    boolean IsCutByFirPos() {
        short wPat = (short) ((m_Engine.m_byLocalPattern[m_Engine.m_nMainPosition][0] & 0xff) |
                ((m_Engine.m_byLocalPattern[m_Engine.m_nMainPosition][1] & 0xff) << 8));
        if ( (m_Engine.m_byTurnColor & 1) != 0) {
            if ( ( ( (wPat & 0x03c3) == 0x0182) &&
                    ( (m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition + 19]] & 0x800)) != 0)
                    || ( ( (wPat & 0x0c0f) == 0x040a) &&
                    ( (m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition - 21]] & 0x800)) != 0)
                    || ( ( (wPat & 0x303c) == 0x1028) &&
                    ( (m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition - 19]] & 0x800)) != 0)
                    || ( ( (wPat & 0xc0f0) == 0x40a0) &&
                    ( (m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition + 21]] & 0x800)) != 0))
                return true;

            if ( ( (wPat & 0xd3ff) == 0x0209) || ( (wPat & 0x7cff) == 0x0881)
                    || ( (wPat & 0x4fff) == 0x0824) || ( (wPat & 0xf1ff) == 0x2006)
                    || ( (wPat & 0x3dff) == 0x2090) || ( (wPat & 0xc7ff) == 0x8018)
                    || ( (wPat & 0xf4ff) == 0x8042) || ( (wPat & 0x1fff) == 0x0260))
                return true;
        } else {
            if ((((wPat & 0x03c3) == 0x0241) &&
                    ( (m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition + 19]] & 0x800)) != 0)
                    || (((wPat & 0x0c0f) == 0x0805) &&
                    ((m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition - 21]] & 0x800)) != 0)
                    || (((wPat & 0x303c) == 0x2014) &&
                    ((m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition - 19]] & 0x800)) != 0)
                    || (((wPat & 0xc0f0) == 0x8050) &&
                    ((m_Engine.m_wStatus[m_Engine.m_byBoard[m_Engine.m_nMainPosition + 21]] & 0x800)) != 0))
                return true;

            if ( ( (wPat & 0xe3ff) == 0x0106) || ( (wPat & 0xbcff) == 0x0442)
                    || ( (wPat & 0x8fff) == 0x0418) || ( (wPat & 0xf2ff) == 0x1009)
                    || ( (wPat & 0x3eff) == 0x1060) || ( (wPat & 0xcbff) == 0x4024)
                    || ( (wPat & 0xf8ff) == 0x4081) || ( (wPat & 0x2fff) == 0x0190))
                return true;
        }
        return false;
    }

    boolean IfDeadByGroup(short StringNo, short nMainPos) {
        m_Engine.m_nBoardPos = nMainPos;
        if ( (m_Engine.m_byPosBoard[nMainPos] == 2) &&
                ((m_Engine.m_byLiberties[StringNo] & 0xFF) <= 3) &&
                (AstonePosWeight(true) >= 5)) {
            m_Engine.m_wStatus[StringNo] = 0x1ff;
            return true;
        }
        return false;
    }
/*
    short ScoreOnManySEP() {

        short nStrNum = m_Engine.m_byNewStringNumber;
        short nOldSEP = m_Engine.m_byTempLiberties[nStrNum];
        short nNewSEP = m_Engine.m_byLiberties[nStrNum];

        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);

        return m_Engine.m_nIniScore;
    }
*/

    short ScoreOnManySEP() {
        short	i,nScore;
        short   nDCount;
//	BYTE byNum;

        byte byDifferStr;
//	WORD wStatus;

        short nStrNum;
        short nOldSEP;
        short nNewSEP;

        short nOldEmptyCount=0;
        short wOldStatus = (short)0xff00;

        short	wStrStatus = m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xFF];
        //if m_byWhereCall == PS_POS,Other String Status Change

        if((m_Engine.m_byWhereCall == (byte)0xff) &&
                ((m_Engine.m_byTurnColor & 0xFF) == m_Engine.m_nComStoneColor))
        {
            nDCount = m_Engine.m_nDCount;
            for( i=0;i<nDCount;i++)
            {
                byDifferStr = m_Engine.m_byDifferBuf[i];
            }
        }

        nStrNum = (short) (m_Engine.m_byNewStringNumber & 0xFF);
        nOldSEP = (short) (m_Engine.m_byTempLiberties[nStrNum] & 0xFF);
        nNewSEP = (short) (m_Engine.m_byLiberties[nStrNum] & 0xFF);

        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall,m_Engine.m_nScoreBase);

        End:
        do
        {
            if (m_Engine.m_nIniScore < -1) {
                nScore = -2;
                break End;
            }

            if (m_Engine.m_nIniScore == -1) {
                if (IsAtariPat()) return m_Engine.m_nIniScore;
                if (((m_Engine.m_wStatus[nStrNum] & 0x08) == 0) && IsTwoLinePat())
                    return m_Engine.m_nIniScore;
                nScore = -1;
                break End;
            }

            if ((m_Engine.m_wStatus[nStrNum] & 0x08) == 0) {
                if (IsTwoLinePat()) return m_Engine.m_nIniScore;
            }

            if (IsAtariPat())return m_Engine.m_nIniScore;
            if (IsOneLinePat())return m_Engine.m_nIniScore;
            if (IsToviPat1())return m_Engine.m_nIniScore;
            if ((m_Engine.m_wStatus[nStrNum] & 0x08) != 0){
                nScore = m_Engine.m_nIniScore;
                break End;
            }
            if (IsTukePat())return m_Engine.m_nIniScore;
            if (IsToviPat2())return m_Engine.m_nIniScore;
            if (IsKeimaPat())return m_Engine.m_nIniScore;

            return m_Engine.m_nIniScore;
        }
        while (false);

        if ( (nScore==-2) &&
                ((m_Engine.m_byNewLiberties & 0xFF) > nOldEmptyCount) &&
                ((wStrStatus & 0x08)==0) )
            nScore=-1;
        if( ((nScore == -1) || (nScore == 0)) &&
                ((m_Engine.m_byNewLiberties & 0xff) <= nOldEmptyCount) &&
                (((wOldStatus & 0x08) != 0) || ((wOldStatus & 0x8000) == 0)) )
            nScore--;
        return nScore;
    }


    short ResultGain(byte byWhereCall, short nScoreBase, short nChangedTSize) {
        short nTpWCChange;
        short nTpBCChange;
        short nGain;

        m_Engine.m_nBlackTChange = (short) (m_Engine.m_wTempBlackTSize - m_Engine.m_wBlackTSize);
        m_Engine.m_nWhiteTChange = (short) (m_Engine.m_wTempWhiteTSize - m_Engine.m_wWhiteTSize);
        m_Engine.m_cBlackCountChange = (short) (m_Engine.m_byTempBlackGroupCount -
                m_Engine.m_byBlackGroupCount); //Unnecessary,Already In 3be4.
        m_Engine.m_cWhiteCountChange = (short) (m_Engine.m_byTempWhiteGroupCount -
                m_Engine.m_byWhiteGroupCount); //Unnecessary,Already In 3be4.

        nTpWCChange = m_Engine.m_cWhiteCountChange;
        nTpBCChange = m_Engine.m_cBlackCountChange;

        m_Engine.m_cWhiteCountChange = 0;
        m_Engine.m_cBlackCountChange = 0;

        m_Engine.m_nNewTerritory = nChangedTSize;

        nGain = GainOfNewMove(byWhereCall, nScoreBase);

        m_Engine.m_cWhiteCountChange = nTpWCChange;
        m_Engine.m_cBlackCountChange = nTpBCChange;

        return nGain;
    }

    short ScoreOnOneSEP(boolean bIsPae) {
        short nMyScore[] = {0};
        byte byStrNum;

        if (bIsPae) {
            m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xFF] = 0x0201;
            m_Engine.m_nScoreBase = (short) (OldBoardScoreCalc() - 1);
            if ( (m_Engine.m_byNewStringNumber & 1) != 0)
                m_Engine.m_nDifOfTerritory -= 4;
            else
                m_Engine.m_nDifOfTerritory += 4;
            m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
            return GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
        }
        byStrNum = m_Engine.m_byNewStringNumber;
        m_Engine.m_wStatus[byStrNum & 0xFF] = 0x01ff;
        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        if (m_Engine.m_nScoreBase < -1)
            return m_Engine.m_nScoreBase;
        m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
        if (m_Engine.m_nIniScore < -1)
            return m_Engine.m_nIniScore;

        short[] temp = {m_Engine.m_nPos2};
        GetEmptyPos(byStrNum, (short) 1, temp);
        m_Engine.m_nPos2 = temp[0];
        m_Engine.m_nBoardPos = m_Engine.m_nPos2;

        if (IsEnableTo(nMyScore) && (nMyScore[0] >= 0)) {
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            if (nMyScore[0] == 0)
                return -1;
            m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 2;
            return nMyScore[0];
        }
        return nMyScore[0];
    }

    short ScoreOnCrisisPos(short nGroupColor) {
        if ((m_Engine.m_byTurnColor & 0xFF) != nGroupColor)
            m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xFF] = 0x01ff;
        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        if (m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xFF] == 0x0201) {
            m_Engine.m_nScoreBase = -1;
            if ( (m_Engine.m_byNewStringNumber & 1) != 0)
                m_Engine.m_nDifOfTerritory -= 4;
            else
                m_Engine.m_nDifOfTerritory += 4;
        }
        return GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
    }

    short ScoreOnLittleSEP() {
        short nDCount = m_Engine.m_nDCount;
        short nScore;
        short nAdd;
        short nStrNum = (short) (m_Engine.m_byNewStringNumber & 0xFF);
        short wStatus = 0;
        short i;
        short nPos[] = new short[2];
        short nTemp;
        short nNewSEP;
        short nStrNumber;
        short nStr;
        byte cWeight;

        if ( (m_Engine.m_wStatus[nStrNum] & 0x08) == 0) {
            if (IfDeadByGroup(nStrNum, m_Engine.m_nBoardPos))
                return ScoreOnManySEP();
            m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xFF] = (short) 0xff01;
            m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 0x10;
        }
        if ( ((m_Engine.m_byNewLiberties & 0xFF) > 2) ||
                (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] != 2))
            return ScoreOnManySEP();

        if (!IsSameString( (byte) 0)) {
            m_Engine.m_nScoreBase = OldBoardScoreCalc();
            m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
            return GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
        }

        for (i = 0; i < m_Engine.m_nDCount; i++) {
            if (m_Engine.m_byDifferLiberties[i] == 1) {
                {
                    wStatus = m_Engine.m_wStatus[m_Engine.m_byDifferBuf[i]];
                    m_Engine.m_wStatus[m_Engine.m_byDifferBuf[i] & 0xFF] &= 0x01ff;
                    break;
                }
            }
        }
        if (i < m_Engine.m_nDCount) {
            m_Engine.m_nScoreBase = OldBoardScoreCalc();
            m_Engine.m_cWhiteCountChange = 0;
            m_Engine.m_cBlackCountChange = 0;
            m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
            nScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
            if ((m_Engine.m_byWhereCall == (byte)0xff) && (nScore > 0)) {
                byte byEnemyStr = m_Engine.m_byDifferBuf[i];
                byte byStr;
                boolean bFlag = false;
                EXIT:
                do {
                    if ( (wStatus & 0x8000) == 0) {
                        bFlag = true;
                        break EXIT;
                    }
                    for (m_Engine.m_nBoardPos = 21; m_Engine.m_nBoardPos < 400; m_Engine.m_nBoardPos++) {
                        if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == 0)
                            continue;
                        if (!IsSameString(byEnemyStr))
                            continue;
                        byStr = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
                        if( byStr == (byte)0xF0 )
                            continue;
                        if ((m_Engine.m_byLiberties[byStr & 0xFF] & 0xFF) < 2) {
                            bFlag = true;
                            break EXIT;
                        }
                    }
                    if ( (m_Engine.m_nStoneCount[(byEnemyStr & 0xff)] == 1) &&
                            (m_Engine.m_byLiberties[nStrNum] == 2))
                        return (short) (nScore * 5);
                } while (false); //EXIT
                if (!bFlag)
                    nScore *= 2;
                else
                    nScore /= 2;
            }
            return nScore;
        }

        m_Engine.m_nScoreBase = m_Engine.m_nDeadStoneCount;

        GetEmptyPos(m_Engine.m_byNewStringNumber, (short) 2, nPos);

        nAdd = 0;

        m_Engine.m_nPos2 = nPos[1];
        m_Engine.m_nPos3 = nPos[0];

        if ( (m_Engine.m_nComStoneColor == (m_Engine.m_byTurnColor & 0xFF)) &&
                (m_Engine.m_byWhereCall == (byte)0xff)) {
            m_Engine.m_nBoardPos = m_Engine.m_nPos2;
            if ( (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] == 3) && (nDCount == 1) &&
                    ( (SetStone1((byte)(m_Engine.m_byTurnColor ^ 3)) < 0) ||
                            ((m_Engine.m_byNewLiberties & 0xFF) < 2)))
                nAdd += 0x20;
            else {
                m_Engine.m_nBoardPos = m_Engine.m_nPos3;
                if ( (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] == 3) && (nDCount == 1) &&
                        ( (SetStone1( (byte) (m_Engine.m_byTurnColor ^ 3)) < 0) ||
                                ((m_Engine.m_byNewLiberties & 0xFF) < 2))) {
                    nAdd += 0x20;
                    nTemp = m_Engine.m_nPos2;
                    m_Engine.m_nPos2 = m_Engine.m_nPos3;
                    m_Engine.m_nPos3 = nTemp;
                }
            }
        }

        m_Engine.m_nBoardPos = m_Engine.m_nPos2;
        if ( (m_Engine.m_nPos2 == m_Engine.m_nPaePos) ||
                (SetStone2( (byte) (m_Engine.m_byTurnColor ^ 3)) < 0) ||
                (m_Engine.m_byNewLiberties < 2)) {
            nTemp = m_Engine.m_nPos2;
            m_Engine.m_nPos2 = m_Engine.m_nPos3;
            m_Engine.m_nPos3 = nTemp;
            LoadData();
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            SetStone2(m_Engine.m_byTurnColor);
            m_Engine.m_nBoardPos = m_Engine.m_nPos2;
            if ( (m_Engine.m_nPos2 == m_Engine.m_nPaePos) ||
                    (SetStone2((byte)(m_Engine.m_byTurnColor ^ 3)) < 0) ||
                    ((m_Engine.m_byNewLiberties & 0xFF) < 2)) {
                LoadData();
                m_Engine.m_nBoardPos = m_Engine.m_nPos1;
                SetStone2(m_Engine.m_byTurnColor);
                m_Engine.m_nScoreBase = OldBoardScoreCalc();
                m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
                nScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
                if (nScore >= -1)
                    nScore += nAdd; ///////
                return nScore;
            }

        }
        ExpressTempArea();
        m_Engine.m_nOldDeadCount = m_Engine.m_nDeadStoneCount;

        m_Engine.m_nBoardPos = m_Engine.m_nPos3;
        m_Engine.m_nPaePos = 0;
        SetStone1(m_Engine.m_byTurnColor);
        nNewSEP = (short) (m_Engine.m_byNewLiberties & 0xFF);
        if (nNewSEP < 1) {
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            nStrNumber = (short) (m_Engine.m_byBoard[m_Engine.m_nBoardPos] & 0xFF);
            if (SimulInFirstOnOutCall( (byte) nStrNumber) <= 0) {
                m_Engine.m_wStatus[nStrNumber] = 0x01ff;
                m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            } else {
                m_Engine.m_nPos3 = m_Engine.m_nBoardPos;
                nNewSEP = 2;
            }
        } else if (nNewSEP == 1) {
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            nStr = (short) (m_Engine.m_byBoard[m_Engine.m_nBoardPos] & 0xFF);
            if (m_Engine.m_nStoneCount[nStr] == 1) {
                m_Engine.m_nBoardPos = m_Engine.m_nPos3;
                SetStone1( (byte) (m_Engine.m_byTurnColor ^ 3));
                if (m_Engine.m_nPaePos != 0)
                    m_Engine.m_wStatus[nStr] = 0x0101;
                else
                    m_Engine.m_wStatus[nStr] = 0x01ff;
            } else
                m_Engine.m_wStatus[nStr] = 0x01ff;
        }

        if (nNewSEP < 2) {
            m_Engine.m_nDeadStoneCount = m_Engine.m_nScoreBase;
            m_Engine.m_byNewStringNumber = (byte) 0xff;
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 2;
            nScore = OldBoardScoreCalc();
            if (nScore >= 0) {
                m_Engine.m_nDeadStoneCount -= m_Engine.m_nOldDeadCount;
                m_Engine.m_nOldDeadCount = 0;
                m_Engine.m_nPos3 = 0;
                nScore = ResultGain(m_Engine.m_byWhereCall, (byte) 0, m_Engine.m_nChangedTSize);
            }
        } else { //nNewSEP >= 2
            SetStone2(m_Engine.m_byTurnColor);
            ExpressTempArea();
            m_Engine.m_byNewGroupNumber = 0;
            m_Engine.m_nDeadStoneCount += m_Engine.m_nScoreBase;
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            ExpressTempArea();
            BoardWeightCalc();
            m_Engine.m_nBoardPos = m_Engine.m_nPos2;
            if (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] != 1) {
                if ( (m_Engine.m_nBoardPos >= 1) && (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos - 1] == 3))
                    m_Engine.m_nBoardPos--;
                else if ( (m_Engine.m_nBoardPos >= 41) &&
                        (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos - 20] == 3))
                    m_Engine.m_nBoardPos -= 20;
                else if ((m_Engine.m_nBoardPos < 399) &&
                        (m_Engine.m_byPosBoard[m_Engine.m_nBoardPos + 1] == 3))
                    m_Engine.m_nBoardPos++;
                else
                    m_Engine.m_nBoardPos += 20;

                if (m_Engine.m_byBoard[m_Engine.m_nBoardPos] == 0) {
                    cWeight = m_Engine.m_cWeightBoard[m_Engine.m_nBoardPos];
                    if ( (m_Engine.m_byTurnColor & 1) != 0) {
                        if (cWeight > -4)
                            m_Engine.m_cWeightBoard[m_Engine.m_nBoardPos] = -1;
                    } else if (cWeight < 4)
                        m_Engine.m_cWeightBoard[m_Engine.m_nBoardPos] = 1;
                }
            }
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            nScore = BoardGroupScoreCalc();
            if (nScore < -1)
                return nScore;
            else if (nScore == -1)
                return (short) (nScore + nAdd);
            m_Engine.m_nDeadStoneCount -= m_Engine.m_nOldDeadCount;
            m_Engine.m_nOldDeadCount = 0;
            nScore = (short) (ResultGain(m_Engine.m_byWhereCall, (short) 0, m_Engine.m_nChangedTSize) + 3);
        }

        m_Engine.m_nIniScore = nScore;
        LoadData();
        SetStone2(m_Engine.m_byTurnColor);
        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        nScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
        if ( (m_Engine.m_nIniScore < 0) && (nScore > 0))
            nScore = 0;
        else if ((m_Engine.m_nIniScore >= 0) && (nScore > m_Engine.m_nIniScore))
            nScore = (short) Math.min(nScore, m_Engine.m_nIniScore);
        if (nScore >= -1)
            nScore += nAdd;
        return nScore;
    }

    short BoardGroupScoreCalc() {
        short nTempBoardPos = m_Engine.m_nBoardPos;
        short wFormerWTSize = m_Engine.m_wWhiteTSize, wFormerBTSize = m_Engine.m_wBlackTSize;

        m_Engine.m_nTotal++;
        m_Engine.m_cBlackCountChange = (short) (m_Engine.m_byBlackGroupCount & 0xFF);
        m_Engine.m_cWhiteCountChange = (short) (m_Engine.m_byWhiteGroupCount & 0xFF);
        GroupScoreCalc();
        m_Engine.m_nDifOfTerritory = (short) (m_Engine.m_nDifOfTwoT9 - m_Engine.m_nDifOfTerritory);
        m_Engine.m_cBlackCountChange -= (m_Engine.m_byBlackGroupCount & 0xFF);
        m_Engine.m_cWhiteCountChange -= (m_Engine.m_byWhiteGroupCount & 0xFF);
        m_Engine.m_nWhiteTChange = (short) (wFormerWTSize - m_Engine.m_wWhiteTSize);
        m_Engine.m_nBlackTChange = (short) (wFormerBTSize - m_Engine.m_wBlackTSize);
        m_Engine.m_nChangedTSize = (short) (m_Engine.m_nDifOfTerritory - m_Engine.m_nWhiteTChange +
                m_Engine.m_nBlackTChange);
        m_Engine.m_nDifOfTerritory = m_Engine.m_nDifOfTwoT9;
        if (m_Engine.m_byTurnColor == 2) //black
            m_Engine.m_nChangedTSize = (short) - m_Engine.m_nChangedTSize;
        m_Engine.m_nChangedTSize += (m_Engine.m_nDeadStoneCount - m_Engine.m_nOldDeadCount) * 6;

        m_Engine.m_nBoardPos = nTempBoardPos;

        if (m_Engine.m_nChangedTSize < -12)
            return -2;
        if (m_Engine.m_nChangedTSize < -3)
            return -1;
        return ( (byte) ( (m_Engine.m_nChangedTSize + 3) / 6));
    }

    short GetDiffer() {
        short nScore, nWeight, nTemp;

        nWeight = m_Engine.m_cWeightBoard[m_Engine.m_nBoardPos];

        nTemp = (short) ( (nWeight > 0) ? nWeight : -nWeight);

        if (nTemp <= 2)
            return 0;

        if (nWeight > 6)
            nWeight = 6;
        else if (nWeight < -6)
            nWeight = -6;

        nTemp = (short) ( (nWeight > 0) ? nWeight : -nWeight);
        nScore = (short) (nTemp - 4);

        if (nScore < 0)
            nScore = 0;
        if (nWeight > 0)
            nScore -= m_Engine.m_cAverageWeight;
        else
            nScore += m_Engine.m_cAverageWeight;
        if (nScore < 0)
            nScore = 0;
        return (nScore);
    }

    void InverseColor() {
        short i;
        byte byTemp;

        m_Engine.m_wNearby = InversePattern(m_Engine.m_wNearby);
        m_Engine.m_byAttach = LOBYTE(m_Engine.m_wNearby);
        m_Engine.m_byKosumi = HIBYTE(m_Engine.m_wNearby);

        m_Engine.m_wIKenDKos = InversePattern(m_Engine.m_wIKenDKos);
        m_Engine.m_byIKen = LOBYTE(m_Engine.m_wIKenDKos);
        m_Engine.m_byDKosumi = HIBYTE(m_Engine.m_wIKenDKos);

        m_Engine.m_wOKeima = InversePattern(m_Engine.m_wOKeima);

        m_Engine.m_wKeima = InversePattern(m_Engine.m_wKeima);
        m_Engine.m_byKeima1 = LOBYTE(m_Engine.m_wKeima);
        m_Engine.m_byKeima2 = HIBYTE(m_Engine.m_wKeima);

        i = 4;
        while (i > 0) {
            byTemp = (byte) (m_Engine.m_byNiKen & 3);
            if ( (byTemp == 1) || (byTemp == 2))
                m_Engine.m_byNiKen ^= 3;
            m_Engine.m_byNiKen = rorb2(m_Engine.m_byNiKen);
            i--;
        }
    }

    short InversePattern(short wPattern) {
        short i = 8;
        short wTemp;

        while (i > 0) {
            wTemp = (short) (wPattern & 3);
            if ( (wTemp == 1) || (wTemp == 2))
                wPattern ^= 3;
            wPattern = rorw2(wPattern);
            i--;
        }
        return wPattern;
    }
/*
    byte BiasPattern(short byColor) {
        if (m_Engine.m_nPosCode < 2)
            return 0;

        DIST distSave = m_Engine.m_Dist[0];
        int nInvYMatch[] = new int[16];
        PATTUNIT ppPattUnit[] = new PATTUNIT[16];

        int dwPropOffset0 = IDist.getInt(m_Engine.m_pPattData, 18);

        int dwOffset, dwOffset1, dwOffset2, dwOffset3, dwPropOffset;
        int ii, jj, kk, nn, mm, nKeyCount, nPattCount;
        PATTUNIT pPattUnit = new PATTUNIT();

        byte cScore1 = 0, cScore = 0;
        if (m_Engine.m_nPosCode == 2) {
            for (nn = 0; nn < 4; nn++) {
                if (LOBYTE(m_Engine.m_Dist[0].wNearby) >= 0xc0)
                    break;
                RotateR90(m_Engine.m_Dist[0], m_Engine.m_Dist[0]);
            }
            InverseAxisY(m_Engine.m_Dist[0], m_Engine.m_Dist[1]);
            if (byColor == IS_WHITE) {
                InverseColor(m_Engine.m_Dist[0], m_Engine.m_Dist[0]);
                InverseColor(m_Engine.m_Dist[1], m_Engine.m_Dist[1]);
            }

            dwOffset = IDist.getInt(m_Engine.m_pPattData, 30);
            nKeyCount = IDist.getShort(m_Engine.m_pPattData, dwOffset);
            for (ii = 0; ii < nKeyCount; ii++) {
                dwOffset1 = dwOffset + sizeofWORD + (sizeofDWORD * (2 * ii + 1));
                dwOffset2 = IDist.getInt(m_Engine.m_pPattData, dwOffset1);
                nPattCount = IDist.getShort(m_Engine.m_pPattData, dwOffset2);
                for (jj = 0; jj < nPattCount; jj++) {
                    dwOffset3 = dwOffset2 + sizeofWORD + (sizeofPATTUNIT * jj);
                    pPattUnit = pPattUnit.creatUnit(m_Engine.m_pPattData, dwOffset3);
                    dwPropOffset = dwPropOffset0 + (pPattUnit.dwPropOffset);
                    for (kk = 0; kk < 2; kk++) {
                        if (IsMatchingDist(m_Engine.m_Dist[kk], pPattUnit.dist, pPattUnit.wOption)) {
                            if (IsMatchingProp(cScore, dwPropOffset, nn, kk, 2 - byColor)) {
                                if ( (pPattUnit.wOption & 32) != 0) {
                                    m_Engine.m_Dist[0] = distSave;
                                    return cScore;
                                }
                                if ( (pPattUnit.wOption & 16) != 0)
                                    break;
                                m_Engine.m_Dist[0] = distSave;
                                return cScore;
                            }
                        }
                    }
                    if (kk < 2)
                        break;
                }
            }
            m_Engine.m_Dist[0] = distSave;
            return cScore;
        }
        int nMatchCount = 0;
        for (nn = 0; nn < 4; nn++) {
            InverseAxisY(m_Engine.m_Dist[0], m_Engine.m_Dist[1]);
            if ( (nn == 0) && (byColor == IS_WHITE)) {
                InverseColor(m_Engine.m_Dist[0], m_Engine.m_Dist[0]);
                InverseColor(m_Engine.m_Dist[1], m_Engine.m_Dist[1]);
            }

            dwOffset = IDist.getInt(m_Engine.m_pPattData, 34);
            nKeyCount = IDist.getShort(m_Engine.m_pPattData, dwOffset);
            for (ii = 0; ii < nKeyCount; ii++) {
                dwOffset1 = dwOffset + sizeofWORD + (sizeofDWORD * (2 * ii + 1));
                dwOffset2 = IDist.getInt(m_Engine.m_pPattData, dwOffset1);
                nPattCount = IDist.getShort(m_Engine.m_pPattData, dwOffset2);
                for (jj = 0; jj < nPattCount; jj++) {
                    if (ii > 6 && jj > 21) {
                        System.out.println("nn + " + nn + " ii : " + ii + " jj : " + jj);
                    }
                    dwOffset3 = dwOffset2 + sizeofWORD + (sizeofPATTUNIT * jj);
                    pPattUnit = pPattUnit.creatUnit(m_Engine.m_pPattData, dwOffset3);
                    dwPropOffset = dwPropOffset0 + (pPattUnit.dwPropOffset);

                    for (kk = 0; kk < 2; kk++) {
                        if (IsMatchingDist(m_Engine.m_Dist[kk], pPattUnit.dist, pPattUnit.wOption)) {
                            if (IsMatchingProp(cScore1, dwPropOffset, nn, kk, 2 - byColor)) {
                                if ( (pPattUnit.wOption & 32) != 0) {
                                    m_Engine.m_Dist[0] = distSave;
                                    return cScore1;
                                }
                                for (mm = 0; mm < nMatchCount; mm++) {
                                    if (pPattUnit == ppPattUnit[mm]) {
                                        if (kk != nInvYMatch[mm])
                                            break;
                                    }
                                }
                                if (mm < nMatchCount)
                                    break;
                                ppPattUnit[nMatchCount] = pPattUnit;
                                nInvYMatch[nMatchCount] = kk;
                                nMatchCount++;
                                cScore += cScore1;
                                break;
                            }
                        }
                    }
                    if (kk < 2)
                        break;
                }
                if ( (jj < nPattCount) && ( (pPattUnit.wOption & 16) == 0))
                    break;
            }
            RotateR90(m_Engine.m_Dist[0], m_Engine.m_Dist[0]);
        }
        m_Engine.m_Dist[0] = distSave;
        return cScore;
    }

    void InverseAxisY(DIST pSrc, DIST pDst) {
        byte by1, by2;
        short w;
        by1 = LOBYTE(pSrc.wNearby);
        by2 = HIBYTE(pSrc.wNearby);
        //H.Joon-2007/03/07>>
        //by1 = (byte) ( (by1 & 0xcc) | ( (by1 & 3) << 4) | ( (by1 & 0x30) >> 4));
        //by2 = (byte) ( ( (by2 & 0xc0) >> 6) | ( (by2 & 0x30) >> 2) | ( (by2 & 0x0c) << 2) | ( (by2 & 3) << 6));
        by1 = (byte) ( (by1 & 0xcc) | ( (by1 & 3) << 4) | ( (by1 & 0x30) >>> 4));
        by2 = (byte) ( ( (by2 & 0xc0) >>> 6) | ( (by2 & 0x30) >>> 2) | ( (by2 & 0x0c) << 2) | ( (by2 & 3) << 6));
        //<<
        pDst.wNearby = (byte) ( (by2 << 8) | by1);

        w = pSrc.wKeima;
        //H.Joon-2007/03/07>>
        //pDst.wKeima = (short) ( ( (w & 0xc000) >> 14) | ( (w & 0x3000) >> 10) | ( (w & 0x0c00) >> 6)
        //                       | ( (w & 0x0300) >> 2) | ( (w & 0x00C0) << 2) | ( (w & 0x0030) << 6)
        //                       | ( (w & 0x000c) << 10) | ( (w & 0x0003) << 14));
        pDst.wKeima = (short) ( ( (w & 0xc000) >>> 14) | ( (w & 0x3000) >>> 10) | ( (w & 0x0c00) >>> 6)
                              | ( (w & 0x0300) >>> 2) | ( (w & 0x00C0) << 2) | ( (w & 0x0030) << 6)
                              | ( (w & 0x000c) << 10) | ( (w & 0x0003) << 14));
        //<<
        by1 = LOBYTE(pSrc.wIkenDKos);
        by2 = HIBYTE(pSrc.wIkenDKos);
        //H.Joon-2007/03/07>>
        by1 = (byte) ( (by1 & 0xcc) | ( (by1 & 3) << 4) | ( (by1 & 0x30) >>> 4));
        by2 = (byte) ( ( (by2 & 0xc0) >>> 6) | ( (by2 & 0x30) >>> 2) | ( (by2 & 0x0c) << 2) | ( (by2 & 3) << 6));
        //<<
        pDst.wIkenDKos = (short) ( (by2 << 8) | by1);

        w = pSrc.wOKeima;
        //H.Joon-2007/03/-7>>
        //pDst.wOKeima = (short) ( ( (w & 0xc000) >> 14) | ( (w & 0x3000) >> 10) | ( (w & 0x0c00) >> 6)
        //                        | ( (w & 0x0300) >> 2) | ( (w & 0x00C0) << 2) | ( (w & 0x0030) << 6)
        //                        | ( (w & 0x000c) << 10) | ( (w & 0x0003) << 14));
        pDst.wOKeima = (short) ( ( (w & 0xc000) >>> 14) | ( (w & 0x3000) >>> 10) | ( (w & 0x0c00) >>> 6)
                               | ( (w & 0x0300) >>> 2) | ( (w & 0x00C0) << 2) | ( (w & 0x0030) << 6)
                               | ( (w & 0x000c) << 10) | ( (w & 0x0003) << 14));
        //<<
        by1 = pSrc.byNiken;
        //H.Joon-2007/03/-7>>
        //pDst.byNiken = (byte) ( (by1 & 0xcc) | ( (by1 & 3) << 4) | ( (by1 & 0x30) >> 4));
        pDst.byNiken = (byte) ( (by1 & 0xcc) | ( (by1 & 3) << 4) | ( (by1 & 0x30) >>> 4));
        //<<
    }

    void InverseColor(DIST pSrc, DIST pDst) {
        int ii;
        byte byMask;

        //memcpy(pDst, pSrc, sizeof(DIST));
        for (ii = 0; ii < 8; ii++) {
            byMask = (byte) (pDst.wNearby & 3);
            if ( (byMask == 1) || (byMask == 2))
                pDst.wNearby ^= 3;
            pDst.wNearby = rorw2(pDst.wNearby);

            byMask = (byte) (pDst.wKeima & 3);
            if ( (byMask == 1) || (byMask == 2))
                pDst.wKeima ^= 3;
            pDst.wKeima = rorw2(pDst.wKeima);

            byMask = (byte) (pDst.wIkenDKos & 3);
            if ( (byMask == 1) || (byMask == 2))
                pDst.wIkenDKos ^= 3;
            pDst.wIkenDKos = rorw2(pDst.wIkenDKos);

            byMask = (byte) (pDst.wOKeima & 3);
            if ( (byMask == 1) || (byMask == 2))
                pDst.wOKeima ^= 3;
            pDst.wOKeima = rorw2(pDst.wOKeima);
        }
        for (ii = 0; ii < 4; ii++) {
            byMask = (byte) (pDst.byNiken & 3);
            if ( (byMask == 1) || (byMask == 2))
                pDst.byNiken ^= 3;
            pDst.byNiken = rorb2(pDst.byNiken);
        }
    }

    boolean IsMatchingDist(DIST pDis, DISTRIBUTION pdist, short wOption) {
        if ( (wOption & 8) != 0)
            return false;
        switch (wOption & 7) {
            case 1:
                if ( ( (pDis.wNearby) & (HIWORD(pdist.dwNearby))) == (LOWORD(pdist.dwNearby)))
                    return true;
                break;
            case 2:
                if ( ( ( (pDis.wNearby) & (HIWORD(pdist.dwNearby))) == (LOWORD(pdist.dwNearby))) &&
                    ( ( (pDis.wKeima) & (HIWORD(pdist.dwKeima))) == (LOWORD(pdist.dwKeima))))
                    return true;
                break;
            case 3:
                if ( ( ( (pDis.wNearby) & (HIWORD(pdist.dwNearby))) == (LOWORD(pdist.dwNearby))) &&
                    ( ( (pDis.wKeima) & (HIWORD(pdist.dwKeima))) == (LOWORD(pdist.dwKeima))) &&
                    ( ( (pDis.wIkenDKos) & (HIWORD(pdist.dwIkenDKos))) == (LOWORD(pdist.dwIkenDKos))))
                    return true;
                break;
            case 4:
                if ( ( ( (pDis.wNearby) & (HIWORD(pdist.dwNearby))) == (LOWORD(pdist.dwNearby))) &&
                    ( ( (pDis.wKeima) & (HIWORD(pdist.dwKeima))) == (LOWORD(pdist.dwKeima))) &&
                    ( ( (pDis.wIkenDKos) & (HIWORD(pdist.dwIkenDKos))) == (LOWORD(pdist.dwIkenDKos))) &&
                    ( ( (pDis.wOKeima) & (HIWORD(pdist.dwOKeima))) == (LOWORD(pdist.dwOKeima))))
                    return true;
                break;
            case 5:
                if ( ( ( (pDis.wNearby) & (HIWORD(pdist.dwNearby))) == (LOWORD(pdist.dwNearby))) &&
                    ( ( (pDis.wKeima) & (HIWORD(pdist.dwKeima))) == (LOWORD(pdist.dwKeima))) &&
                    ( ( (pDis.wIkenDKos) & (HIWORD(pdist.dwIkenDKos))) == (LOWORD(pdist.dwIkenDKos))) &&
                    ( ( (pDis.wOKeima) & (HIWORD(pdist.dwOKeima))) == (LOWORD(pdist.dwOKeima))) &&
                    ( ( (pDis.byNiken) & (HIBYTE(pdist.wNiken))) == (LOBYTE(pdist.wNiken))))
                    return true;
                break;
            default:
                return false;
        }
        return false;
    }

    boolean IsMatchingProp(byte cScore, int pbyProp, int nRot, int nInvY, int nInvC) {
        short wCount = IDist.getShort(m_Engine.m_pPattData, pbyProp);
        byte by1 = (byte) (wCount & 0x0f);
        //H.Joon-2007/03/07>>
        //byte by2 = (byte) ( (wCount >> 4) & 0x0f);
        //byte by3 = (byte) ( (wCount >> 8) & 0x0f);
        //byte by4 = (byte) ( (wCount >> 12) & 0x0f);
        byte by2 = (byte) ( (wCount >>> 4) & 0x0f);
        byte by3 = (byte) ( (wCount >>> 8) & 0x0f);
        byte by4 = (byte) ( (wCount >>> 12) & 0x0f);
        //<<
        byte byNum[] = new byte[16], byOperater[] = new byte[16];
        short wComp[] = new short[16];
        int dwCondi, dwCond[] = new int[16];
        boolean bTemp, bflag[] = new boolean[16];
        byte cScore1[] = new byte[16], cComp;
        int n1, n2, n3, n4, nValue = 0;
        int pbyProp1 = pbyProp + 2;

        System.arraycopy(m_Engine.m_pPattData, pbyProp1, byNum, 0, by1);
        pbyProp1 += by1;
        System.arraycopy(m_Engine.m_pPattData, pbyProp1, byOperater, 0, by2);
        pbyProp1 += by2;
        for (n3 = 0; n3 < by3; n3++, pbyProp1 += 2) {
            wComp[n3] = IDist.getShort(m_Engine.m_pPattData, pbyProp1);
        }
        for (n4 = 0; n4 < by4; n4++) {
            dwCond[n4] = IDist.getInt(m_Engine.m_pPattData, pbyProp1);
            cScore1[n4] = IDist.getByte(m_Engine.m_pPattData, pbyProp1 + 4);
            pbyProp1 += 5;
        }
        for (n3 = 0; n3 < by3; n3++) {
            //H.Joon-2007/03/07>>
            //n1 = (wComp[n3] >> 12) & 0x0f;
            n1 = (wComp[n3] >>> 12) & 0x0f;
            //<<
            n1 = GetRealNum(byNum[n1], nRot, nInvY);
            //H.Joon-2007/03/07>>
            //n2 = (wComp[n3] >> 8) & 0x0f;
            n2 = (wComp[n3] >>> 8) & 0x0f;
            //<<
            cComp = (byte) (wComp[n3] & 0xff);
            //H.Joon-2007/03/07>>
            //switch (byOperater[n2] >> 4) {
            switch (byOperater[n2] >>> 4) {
            //<<
                case LIBERTIES:
                    nValue = StrLibs(n1);
                    break;
                case STATUS:
                    nValue = StrStatus(n1);
                    break;
                case STRDEAD:
                    nValue = StrDead(n1);
                    break;
                case WHOSEINFLUENCE:
                    nValue = WhoseInfluence(n1, nInvC);
                    break;
                case INFLUENCE:
                    nValue = Influence(n1, nInvC);
                    break;
                case LAYER:
                    nValue = Layer(n1);
                    break;
                case WHERECALL:
                    nValue = (byte) m_Engine.m_byWhereCall;
                    break;
                default:
                    break;
            }
            switch (byOperater[n2] & 0x0f) {
                case SAME:
                    if (nValue == cComp)
                        bflag[n3] = true;
                    else
                        bflag[n3] = false;
                    break;
                case NOSAME:
                    if (nValue != cComp)
                        bflag[n3] = true;
                    else
                        bflag[n3] = false;
                    break;
                case BIG:
                    if (nValue > cComp)
                        bflag[n3] = true;
                    else
                        bflag[n3] = false;
                    break;
                case SMALL:
                    if (nValue < cComp)
                        bflag[n3] = true;
                    else
                        bflag[n3] = false;
                    break;
                default:
                    break;
            }
        }
        for (n4 = 0; n4 < by4; n4++) {
            dwCondi = dwCond[n4];
            bTemp = true;
            for (n3 = 0; n3 < by3; n3++) {
                switch (dwCondi & 3) {
                    case 0:
                        break;
                    case 1:
                        if (!bflag[n3])
                            bTemp = false;
                        break;
                    case 2:
                        if (bflag[n3])
                            bTemp = false;
                        break;
                    case 3:
                        if (bflag[n3])
                            dwCondi &= 0xfffffff3;
                        break;
                }
                if (!bTemp)
                    break;
                //H.Joon-2007/03/07>>
                //dwCondi = dwCondi >> 2;
                dwCondi = dwCondi >>> 2;
                //<<
            }
            if (bTemp) {
                cScore = cScore1[n4];
                return true;
            }
        }
        return false;
    }

    byte GetRealNum(byte byNum, int nRot, int nInvY) {
        int ii;
        if (nInvY != 0) {
            byNum = c_byInvY[byNum];
        }
        for (ii = 0; ii < nRot; ii++) {
            byNum = c_byRot[byNum];
        }
        return byNum;
    }

    int StrLibs(int nNum) {
        int x1, y1, nStr;

        x1 = m_Engine.m_nBoardX + c_ptAroundPos[ (nNum - 1) * 2];
        y1 = m_Engine.m_nBoardY + c_ptAroundPos[ (nNum - 1) * 2 + 1];

        if ( (x1 < 0) || (x1 >= 19) || (y1 < 0) || (y1 >= 19))
            return -1;

        nStr = m_Engine.m_byBoard[getSerialCoord(x1, y1)];
        if (nStr == 0)
            return 0;
        return m_Engine.m_byLiberties[nStr];
    }

    int StrStatus(int nNum) {
        int x1, y1, nStr;
        short wStatus;

        x1 = m_Engine.m_nBoardX + c_ptAroundPos[ (nNum - 1) * 2];
        y1 = m_Engine.m_nBoardY + c_ptAroundPos[ (nNum - 1) * 2 + 1];

        if ( (x1 < 0) || (x1 >= 19) || (y1 < 0) || (y1 >= 19))
            return 0;
        nStr = m_Engine.m_byBoard[getSerialCoord(x1, y1)];
        if (nStr == 0)
            return 0;

        wStatus = m_Engine.m_wStatus[nStr];

        if ( (m_Engine.m_byLiberties[nStr] < 2) || ( (wStatus & 8) != 0))
            return 2;
        if ( (wStatus & 0x8000) == 0)
            return 1;
        return 0;
    }

    int StrDead(int nNum) {
        int x1, y1, nStr;

        x1 = m_Engine.m_nBoardX + c_ptAroundPos[ (nNum - 1) * 2];
        y1 = m_Engine.m_nBoardY + c_ptAroundPos[ (nNum - 1) * 2 + 1];

        if ( (x1 < 0) || (x1 >= 19) || (y1 < 0) || (y1 >= 19))
            return 0;
        nStr = m_Engine.m_byBoard[getSerialCoord(x1, y1)];
        return (m_Engine.m_wStatus[nStr] & 0x08);
    }

    int WhoseInfluence(int nNum, int nInvC) {
        int x1, y1, nWeight;

        x1 = m_Engine.m_nBoardX + c_ptAroundPos[ (nNum - 1) * 2];
        y1 = m_Engine.m_nBoardY + c_ptAroundPos[ (nNum - 1) * 2 + 1];

        if ( (x1 < 0) || (x1 >= 19) || (y1 < 0) || (y1 >= 19))
            return 0;
        nWeight = m_Engine.m_cWeightBoard[getSerialCoord(x1, y1)];
        if (nWeight < 0)
            return 0;
        if (nWeight == 0)
            return 1;
        return 2;
    }

    int Influence(int nNum, int nInvC) {
        int x1, y1;

        x1 = m_Engine.m_nBoardX + c_ptAroundPos[ (nNum - 1) * 2];
        y1 = m_Engine.m_nBoardY + c_ptAroundPos[ (nNum - 1) * 2 + 1];

        if ( (x1 < 0) || (x1 >= 19) || (y1 < 0) || (y1 >= 19))
            return -1;
        return m_Engine.m_cWeightBoard[getSerialCoord(x1, y1)];
    }

    int Layer(int nNum) {
        int x1, y1;

        if (nNum == 0) {
            x1 = m_Engine.m_nBoardX;
            y1 = m_Engine.m_nBoardY;
        } else {
            x1 = m_Engine.m_nBoardX + c_ptAroundPos[ (nNum - 1) * 2];
            y1 = m_Engine.m_nBoardY + c_ptAroundPos[ (nNum - 1) * 2 + 1];
        }

        if ( (x1 < 0) || (x1 >= 19) || (y1 < 0) || (y1 >= 19))
            return 0;
        return m_Engine.m_byPosBoard[getSerialCoord(x1, y1)];
    }

    short getSerialCoord(int x, int y) {
        return (short) ( (y + 1) * (m_Engine.m_nBoardSize + 1) + (x + 1));
    }

    void EvenPattern() {
        if (m_Engine.m_nPosCode < 2) {
            m_Engine.m_cBaseScore -= 4;
            return;
        }
        DIST distSave = m_Engine.m_Dist[0];
        int nInvYMatch[] = new int[16];
        PATTUNIT ppPattUnit[] = new PATTUNIT[16];
        int dwPropOffset0 = IDist.getInt(m_Engine.m_pPattData, 18);

        int dwOffset, dwOffset1, dwOffset2, dwOffset3, dwPropOffset;
        int ii, jj, kk = 0, nn, mm, nKeyCount, nPattCount;
        byte cScore = 0, cTempScore = m_Engine.m_cBaseScore;
        PATTUNIT pPattUnit = new PATTUNIT();

        if (m_Engine.m_nPosCode == 2) {
            for (nn = 0; nn < 4; nn++) {
                if (LOBYTE(m_Engine.m_Dist[0].wNearby) >= 0xc0)
                    break;
                RotateR90(m_Engine.m_Dist[0], m_Engine.m_Dist[0]);
            }
            InverseAxisY(m_Engine.m_Dist[0], m_Engine.m_Dist[1]);
            InverseColor(m_Engine.m_Dist[0], m_Engine.m_Dist[2]);
            InverseColor(m_Engine.m_Dist[1], m_Engine.m_Dist[3]);

            dwOffset = IDist.getInt(m_Engine.m_pPattData, 22);
            nKeyCount = IDist.getShort(m_Engine.m_pPattData, dwOffset);
            for (ii = 0; ii < nKeyCount; ii++) {
                dwOffset1 = dwOffset + sizeofWORD + (sizeofDWORD * (2 * ii + 1));
                dwOffset2 = IDist.getInt(m_Engine.m_pPattData, dwOffset1);
                nPattCount = IDist.getShort(m_Engine.m_pPattData, dwOffset2);
                for (jj = 0; jj < nPattCount; jj++) {
                    dwOffset3 = dwOffset2 + sizeofWORD + (sizeofPATTUNIT * jj);
                    pPattUnit = pPattUnit.creatUnit(m_Engine.m_pPattData, dwOffset3);
                    dwPropOffset = dwPropOffset0 + pPattUnit.dwPropOffset;
                    for (kk = 0; kk < 4; kk++) {
                        if (IsMatchingDist(m_Engine.m_Dist[kk], (pPattUnit.dist), pPattUnit.wOption)) {
                            if (IsMatchingProp(cScore, dwPropOffset, nn, kk % 2, kk / 2)) {
                                if ( (pPattUnit.wOption & 32) != 0) {
                                    m_Engine.m_cBaseScore = (byte) (cTempScore + cScore);

                                    m_Engine.m_Dist[0] = distSave;
                                    return;
                                }
                                m_Engine.m_cBaseScore += cScore;
                                if ( (pPattUnit.wOption & 16) != 0)
                                    break;
                                m_Engine.m_Dist[0] = distSave;
                                return;
                            }
                        }
                        if (kk < 4)
                            break;
                    }
                }
            }
            m_Engine.m_Dist[0] = distSave;
            return;
        }

        int nMatchCount = 0;
        for (nn = 0; nn < 4; nn++) {
            InverseAxisY(m_Engine.m_Dist[0], m_Engine.m_Dist[1]);
            InverseColor(m_Engine.m_Dist[0], m_Engine.m_Dist[2]);
            InverseColor(m_Engine.m_Dist[1], m_Engine.m_Dist[3]);

            dwOffset = IDist.getInt(m_Engine.m_pPattData, 26);
            nKeyCount = IDist.getShort(m_Engine.m_pPattData, dwOffset);
            for (ii = 0; ii < nKeyCount; ii++) {
                dwOffset1 = dwOffset + sizeofWORD + (sizeofDWORD * (2 * ii + 1));
                dwOffset2 = IDist.getInt(m_Engine.m_pPattData, dwOffset1);
                nPattCount = IDist.getShort(m_Engine.m_pPattData, dwOffset2);
                for (jj = 0; jj < nPattCount; jj++) {
                    dwOffset3 = dwOffset2 + sizeofWORD + (sizeofPATTUNIT * jj);
                    pPattUnit = pPattUnit.creatUnit(m_Engine.m_pPattData, dwOffset3);
                    dwPropOffset = dwPropOffset0 + (pPattUnit.dwPropOffset);
                    for (kk = 0; kk < 4; kk++) {
                        if (IsMatchingDist(m_Engine.m_Dist[kk], (pPattUnit.dist), pPattUnit.wOption)) {
                            if (IsMatchingProp(cScore, dwPropOffset, nn, kk % 2, kk / 2)) {
                                if ( (pPattUnit.wOption & 32) != 0) {
                                    m_Engine.m_cBaseScore = (byte) (cTempScore + cScore);

                                    m_Engine.m_Dist[0] = distSave;
                                    return;
                                }
                                for (mm = 0; mm < nMatchCount; mm++) {
                                    if (pPattUnit == ppPattUnit[mm]) {
                                        if ( (kk % 2) != nInvYMatch[mm])
                                            break;
                                    }
                                }
                                if (mm < nMatchCount)
                                    break;
                                ppPattUnit[nMatchCount] = pPattUnit;
                                nInvYMatch[nMatchCount] = kk % 2;
                                nMatchCount++;
                                m_Engine.m_cBaseScore += cScore;
                                break;
                            }
                        }

                    }
                    if (kk < 4)
                        break;
                }
                if ( (jj < nPattCount) && ((pPattUnit.wOption & 16) == 0))
                    break;
            }
            RotateR90(m_Engine.m_Dist[0], m_Engine.m_Dist[0]);
        }
        m_Engine.m_Dist[0] = distSave;
        return;
    }
*/

    void EvenPattern() //lci  modify control flow
    {

        short wOKeima, wTemp;
        byte byNiKen, byTemp, byTemp1;
        short nInfo;
        byte byConst1, byConst2, byConst3, byConst4;
        short wConst1, wConst2, wConst3;

        byte byParam[] = new byte[1];
        short ret = 0;

        if (m_Engine.m_nPosCode < 2) {
            m_Engine.m_cBaseScore -= 4;
            return;
        }

        EvenPatternOnEdge();

        if ((m_Engine.m_byAttach == 0x66) ||
                (m_Engine.m_byAttach == (byte) 0x99)) {
            m_Engine.m_cBaseScore += 10;
            return;
        }

        if ((m_Engine.m_nPosCode >= 5)
                && (m_Engine.m_wNearby == 0)
                && (m_Engine.m_wKeima == 0)
                && (m_Engine.m_byIKen == 0)) {
            m_Engine.m_cBaseScore -= 1;
            if (m_Engine.m_byNiKen == 0) {
                if (m_Engine.m_wOKeima == 0) m_Engine.m_cBaseScore -= 2;
                return;
            } else if (m_Engine.m_wOKeima == 0)return;

            byNiKen = m_Engine.m_byNiKen;
            wOKeima = m_Engine.m_wOKeima;

            for (m_Engine.m_nEntry = 4; m_Engine.m_nEntry > 0;
                 m_Engine.m_nEntry--) {
                if ((m_Engine.m_byNiKen & 1) != 0) {
                    if (((m_Engine.m_wOKeima & 0x0028) == 0) &&
                            (m_Engine.m_wOKeima & 0x0014) != 0) {
                        m_Engine.m_cBaseScore += 3;
                        break;
                    }
                } else if ((m_Engine.m_byNiKen & 2) != 0
                        && ((m_Engine.m_wOKeima & 0x0014) == 0)
                        && (m_Engine.m_wOKeima & 0x0028) != 0) {
                    m_Engine.m_cBaseScore += 3;
                    break;
                }

                m_Engine.m_wOKeima = rolw4(m_Engine.m_wOKeima);
                m_Engine.m_byNiKen = rolb2(m_Engine.m_byNiKen);
            }

            m_Engine.m_byNiKen = byNiKen;
            m_Engine.m_wOKeima = wOKeima;
            return;
        }

        for (m_Engine.m_nEntry = 4; m_Engine.m_nEntry > 0; RotatePattern(),
                m_Engine.m_nEntry--) {
            boolean bGoto_NO_SPECIAL = false, bGoto_LEFT_EMPTY = false; //lci add 070327-1544

            byTemp1 = (byte) (m_Engine.m_byDKosumi & 3);
            byTemp = (byte) (m_Engine.m_byIKen & 0xc3);

            if (((m_Engine.m_wNearby & 0x03c3) == 0) &&
                    ((byTemp1 == 1) || (byTemp1 == 2)) &&
                    ((byTemp == (byte) 0x82) || (byTemp == 0x41))) {
                if (byTemp1 == 1) {
                    if (byTemp == (byte) 0x82) {
                        if ((m_Engine.m_byKeima1 & 5) == 0 &&
                                (m_Engine.m_byKeima1 & 0x0a) != 0 &&
                                (L2D2StrStatus() == 0)) {
                            if ((m_Engine.m_byKeima1 & 0x0f) == 0x0a) m_Engine.
                                    m_cBaseScore += 4;
                            else m_Engine.m_cBaseScore += 2;
                        }
                        //goto CONTINUE1;
//                        RotatePattern();
                        continue;
                    }
                } else if (byTemp == 0x41) {
                    if ((m_Engine.m_byKeima1 & 0x0a) == 0 &&
                            (m_Engine.m_byKeima1 & 5) != 0 && (L2D2StrStatus() == 0)) {
                        if ((m_Engine.m_byKeima1 & 0x0f) == 0x05) m_Engine.
                                m_cBaseScore += 4;
                        else m_Engine.m_cBaseScore += 2;
                    }
                    //goto CONTINUE1;
//                    RotatePattern();
                    continue;
                }
            }

            if ((m_Engine.m_wNearby & 0x0fff) == 0) {
                byTemp = (byte) (m_Engine.m_byIKen & 3);
                if ((byTemp == 1) || (byTemp == 2)) {
                    if (byTemp == 1) {
                        wTemp = MAKEWORD((m_Engine.m_byKeima1 & 0xeb),
                                (m_Engine.m_byIKen & 0xcc));
                        byConst1 = (byte) 0x82;
                        byConst2 = (byte) 0x88;
                        byConst3 = 0x14;
                        byConst4 = 0x10;
                        wConst1 = (short) 0x8080;
                        wConst2 = 0x0802;
                        wConst3 = (short) 0x82aa;
                    } else {
                        wTemp = MAKEWORD((m_Engine.m_byKeima1 & 0xd7),
                                (m_Engine.m_byIKen & 0xcc));
                        byConst1 = 0x41;
                        byConst2 = 0x44;
                        byConst3 = 0x28;
                        byConst4 = 0x20;
                        wConst1 = 0x4040;
                        wConst2 = 0x0401;
                        wConst3 = 0x4155;
                    }

                    if ((LOBYTE(wTemp) == byConst1) ||
                            (HIBYTE(wTemp) == byConst2) ||
                            (wTemp == wConst1) || (wTemp == wConst2)) {
                        m_Engine.m_cBaseScore += 6;
                        if (((m_Engine.m_byIKen & 0x30) != 0x30) &&
                                ((m_Engine.m_byKeima2 & byConst3) != 0
                                        || (m_Engine.m_byIKen & byConst4) != 0))
                            m_Engine.m_cBaseScore += 2;
                    } else if ((m_Engine.m_byKeima1) != 0 &&
                            (m_Engine.m_byIKen & byConst2) == 0 &&
                            (m_Engine.m_wKeima & wConst3) == 0 &&
                            (byTemp = (byte) (m_Engine.m_byKeima1 & byConst3)) !=
                                    0) {
                        if (byTemp == byConst3) m_Engine.m_cBaseScore -= 2;
                        else m_Engine.m_cBaseScore -= 1;
                    }
                }
                //goto CONTINUE1;
//                RotatePattern();
                continue;
            }

            wTemp = (short) (m_Engine.m_wNearby & 0x0fcf);
            if ((wTemp == 0x0a01) || (wTemp == 0x0502)) {
                if (wTemp == 0x0a01) {
                    byConst1 = 2;
                    byConst2 = (byte) 0x80;
                    byConst3 = (byte) 0x88;
                    wConst1 = (short) 0xa020;
                } else {
                    byConst1 = 1;
                    byConst2 = 0x40;
                    byConst3 = 0x44;
                    wConst1 = 0x5010;
                }
                if ((nInfo = L1StrLibs()) < 2) m_Engine.m_cBaseScore += 16;
                else if (((byTemp = (byte) L1D1StrLibs()) < 2) ||
                        ((byTemp1 = (byte) L1U1StrLibs()) < 2))
                    m_Engine.m_cBaseScore -= 2;
                else if (nInfo == 2) m_Engine.m_cBaseScore += 10;
                else if ((m_Engine.m_byIKen & byConst3) != 0 ||
                        (m_Engine.m_wNearby & wConst1) != 0)
                    m_Engine.m_cBaseScore += 8;
                else {
                    if ((byTemp == 2) && (m_Engine.m_byKeima1 & byConst1) == 0) {
                        if (m_Engine.m_nPosCode == 3) {
                            //goto CONTINUE1;
//                            RotatePattern();
                            continue;
                        }
                        byConst4 = 1;
                    } else byConst4 = 0;

                    if ((byTemp1 == 2) && (m_Engine.m_byKeima1 & byConst2) == 0) {
                        if (m_Engine.m_nPosCode == 3) {
                            //goto CONTINUE1;
//                            RotatePattern();
                            continue;
                        }
                        byConst4 += 1;
                    }
                    if (byConst4 != 2) m_Engine.m_cBaseScore += 8;
                }
                //goto CONTINUE1;
//                RotatePattern();
                continue;
            }

            wTemp = (short) (m_Engine.m_wNearby & 3);
            if (wTemp == 2) {
                if ((m_Engine.m_byAttach & 0x20) != 0 &&
                        (m_Engine.m_byAttach & 0xcc) == 0 &&
                        (m_Engine.m_byKosumi & 0x41) != 0 &&
                        (m_Engine.m_byKosumi & 0x14) != 0) {
                    m_Engine.m_cBaseScore += 3;
                    //goto CONTINUE1;
//                    RotatePattern();
                    continue;
                }

                if ((m_Engine.m_wNearby & 0x05cf) == 2) {
                    if ((m_Engine.m_wNearby == 0x6002) ||
                            (m_Engine.m_wNearby == (short) 0x9002))
                        m_Engine.m_cBaseScore -= 2;
                    else if ((wTemp = (short) (m_Engine.m_wNearby & 0x0030)) ==
                            0x0010) {
                        if ((m_Engine.m_wNearby & 0xa000) == 0) m_Engine.
                                m_cBaseScore -= 4;
                    } else if (wTemp == 0x0020) {
                        if ((m_Engine.m_wNearby & 0x5000) == 0) m_Engine.
                                m_cBaseScore -= 4;
                    } else {
                        m_Engine.m_cBaseScore -= 4;
                        if ((m_Engine.m_wNearby & 0xf000) == 0 &&
                                ((m_Engine.m_byIKen & 0x30) != 0x30)) {
                            if ((m_Engine.m_byIKen & 0x20) != 0) m_Engine.
                                    m_cBaseScore--;
                            if ((m_Engine.m_byKeima2 & 0x28) != 0) m_Engine.
                                    m_cBaseScore--;
                        }
                    }
                    //goto CONTINUE1;
//                    RotatePattern();
                    continue;
                }
            } else if (wTemp == 1) {
                if ((m_Engine.m_wNearby & 0x10) != 0 &&
                        (m_Engine.m_wNearby & 0xcc) == 0 &&
                        (m_Engine.m_wNearby & 0x8200) != 0 &&
                        (m_Engine.m_wNearby & 0x2800) != 0) {
                    m_Engine.m_cBaseScore += 3;
                    //goto CONTINUE1;
//                    RotatePattern();
                    continue;
                }

                if ((m_Engine.m_wNearby & 0x0acf) == 1) {
                    if ((m_Engine.m_wNearby == (short) 0x9001) ||
                            (m_Engine.m_wNearby == 0x6001))
                        m_Engine.m_cBaseScore -= 2;
                    else if ((wTemp = (short) (m_Engine.m_wNearby & 0x0030)) ==
                            0x10) {
                        if ((m_Engine.m_wNearby & 0xa000) == 0) m_Engine.
                                m_cBaseScore -= 4;
                    } else if (wTemp == 0x20) {
                        if ((m_Engine.m_wNearby & 0x5000) == 0) m_Engine.
                                m_cBaseScore -= 4;
                    } else {
                        m_Engine.m_cBaseScore -= 4;
                        if (((m_Engine.m_wNearby & 0xf000) == 0) &&
                                ((m_Engine.m_byIKen & 0x30) != 0x30)) {
                            if ((m_Engine.m_byIKen & 0x10) != 0) m_Engine.
                                    m_cBaseScore--;
                            if ((m_Engine.m_byKeima2 & 0x14) != 0) m_Engine.
                                    m_cBaseScore--;
                        }
                    }
                    //goto CONTINUE1;
//                    RotatePattern();
                    continue;
                }
            }

            wTemp = (short) (m_Engine.m_wNearby & 0x03ff);
            if ((wTemp == 0x0269) || (wTemp == 0x0196)) {
                if (IsU1StrDead() == 0 || IsR1StrDead() == 0) {
                    m_Engine.m_cBaseScore += 2;

                    byTemp = (byte) L1StrLibs();
                    byTemp1 = (byte) D1StrLibs();

                    if (L1D1StrStatus() == 2) {
                        if ((byTemp == 1) || (byTemp1 == 1)) m_Engine.
                                m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore -= 2;
                    } else {
                        if ((byTemp < 2) || (byTemp1 < 2)) m_Engine.
                                m_cBaseScore += 8;
                        else m_Engine.m_cBaseScore += 10;
                    }
                }
            } else if ((m_Engine.m_wNearby & 0x038f) == 0x0209) {
                if (IsU1StrDead() == 0) {
                    nInfo = L1D1StrStatus();
                    if (nInfo == 2) {
                        if ((L1StrLibs() == 1) || (D1StrLibs() == 1)) m_Engine.
                                m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore -= 2;
                    } else if ((m_Engine.m_wNearby & 0x0040) != 0) {
                        if (nInfo == 1) m_Engine.m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore += 10;
                    } else {
                        if ((m_Engine.m_wNearby & 0x0010) != 0) m_Engine.
                                m_cBaseScore += 10;
                        else if ((m_Engine.m_wNearby & 0x0020) != 0) m_Engine.
                                m_cBaseScore += 4;
                        else if (((m_Engine.m_wNearby & 0x8000) == 0) ||
                                ((m_Engine.m_byIKen & 0xff) >= 0xc0)) {
                            if (L1StrLibs() >= 2) m_Engine.m_cBaseScore += 10;
                            else m_Engine.m_cBaseScore += 8;
                        } else if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.
                                m_cBaseScore += 10;
                        else if ((m_Engine.m_byIKen & 0x80) != 0) m_Engine.
                                m_cBaseScore += 4;
                        else if ((m_Engine.m_byKeima2 & 0x80) == 0 ||
                                (m_Engine.m_byKeima1 & 2) == 0)
                            m_Engine.m_cBaseScore += 8;
                        else m_Engine.m_cBaseScore += 4;
                    }
                }
            } else if ((m_Engine.m_wNearby & 0x03f2) == 0x0260) {
                if (IsR1StrDead() == 0) {
                    nInfo = L1D1StrStatus();
                    if (nInfo == 2) {
                        if ((L1StrLibs() == 1) || (D1StrLibs() == 1))
                            m_Engine.m_cBaseScore += 6;
                        else
                            m_Engine.m_cBaseScore -= 2;
                    } else if ((m_Engine.m_wNearby & 0x0001) != 0) {
                        if (nInfo == 1) m_Engine.m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore += 10;
                    } else {
                        if ((m_Engine.m_wNearby & 0x0004) != 0) m_Engine.
                                m_cBaseScore += 10;
                        else if ((m_Engine.m_wNearby & 0x0008) != 0) m_Engine.
                                m_cBaseScore += 4;
                        else if ((m_Engine.m_wNearby & 0x0800) == 0 ||
                                ((m_Engine.m_byIKen & 3) == 3)) {
                            if (D1StrLibs() >= 2) m_Engine.m_cBaseScore += 10;
                            else m_Engine.m_cBaseScore += 8;
                        } else if ((m_Engine.m_byIKen & 1) != 0) m_Engine.
                                m_cBaseScore += 10;
                        else if ((m_Engine.m_byIKen & 2) != 0) m_Engine.
                                m_cBaseScore += 4;
                        else if ((m_Engine.m_byKeima1 & 0x28) != 0x28) m_Engine.
                                m_cBaseScore += 8;
                        else m_Engine.m_cBaseScore += 4;
                    }
                }
            } else if ((m_Engine.m_wNearby & 0x034f) == 0x0106) {
                if (IsU1StrDead() == 0) {
                    nInfo = L1D1StrStatus();
                    if (nInfo == 2) {
                        if ((L1StrLibs() == 1) || (D1StrLibs() == 1)) m_Engine.
                                m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore -= 2;
                    } else if ((m_Engine.m_wNearby & 0x0080) != 0) {
                        if (nInfo == 1) m_Engine.m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore += 10;
                    } else {
                        if ((m_Engine.m_wNearby & 0x0020) != 0) m_Engine.
                                m_cBaseScore += 10;
                        else if ((m_Engine.m_wNearby & 0x0010) != 0) m_Engine.
                                m_cBaseScore += 4;
                        else if ((m_Engine.m_wNearby & 0x4000) == 0 ||
                                ((m_Engine.m_byIKen & 0xff) >= 0xc0)) {
                            if (L1StrLibs() >= 2) m_Engine.m_cBaseScore += 10;
                            else m_Engine.m_cBaseScore += 8;
                        } else if ((m_Engine.m_byIKen & 0x80) != 0) m_Engine.
                                m_cBaseScore += 10;
                        else if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.
                                m_cBaseScore += 4;
                        else if ((m_Engine.m_byKeima2 & 0x40) == 0 ||
                                (m_Engine.m_byKeima1 & 1) == 0) m_Engine.
                                m_cBaseScore += 8;
                        else m_Engine.m_cBaseScore += 4;
                    }
                }
            } else if ((m_Engine.m_wNearby & 0x03f1) == 0x0190) {
                if (IsR1StrDead() == 0) {
                    nInfo = L1D1StrStatus();
                    if (nInfo == 2) {
                        if ((L1StrLibs() == 1) || (D1StrLibs() == 1)) m_Engine.
                                m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore -= 2;
                    }
                    if ((m_Engine.m_wNearby & 0x0002) != 0) {
                        if (nInfo == 1) m_Engine.m_cBaseScore += 6;
                        else m_Engine.m_cBaseScore += 10;
                    } else {
                        if ((m_Engine.m_wNearby & 0x0008) != 0)
                            m_Engine.m_cBaseScore += 10;
                        else if ((m_Engine.m_wNearby & 0x0004) != 0)
                            m_Engine.m_cBaseScore += 4;
                        else if ((m_Engine.m_wNearby & 0x0400) == 0 ||
                                ((m_Engine.m_byIKen & 3) == 3)) {
                            if (D1StrLibs() >= 2)
                                m_Engine.m_cBaseScore += 10;
                            else m_Engine.m_cBaseScore += 8;
                        } else if ((m_Engine.m_byIKen & 2) != 0) m_Engine.
                                m_cBaseScore += 10;
                        else if ((m_Engine.m_byIKen & 1) != 0) m_Engine.
                                m_cBaseScore += 4;
                        else if ((m_Engine.m_byKeima1 & 0x14) != 0x14) m_Engine.
                                m_cBaseScore += 8;
                        else m_Engine.m_cBaseScore += 4;
                    }
                }
            } else if (((wTemp = (short) (m_Engine.m_wNearby & 0x03ff)) ==
                    0x0182)
                    || (wTemp == 0x0241)) {
                if (L1D1StrStatus() == 2) {
                    if ((L1StrLibs() < 2) || (D1StrLibs() < 2)) m_Engine.
                            m_cBaseScore += 6;
                    else m_Engine.m_cBaseScore -= 2;
                } else {
                    if ((L1StrLibs() <= 2) || (D1StrLibs() <= 2)) m_Engine.
                            m_cBaseScore += 8;
                    else {
                        if ((m_Engine.m_nPosCode != 3) ||
                                (((m_Engine.m_byIKen & 0x30) != 0x30) &&
                                        ((m_Engine.m_byIKen & 0x0c) != 0x0c))) {
                            m_Engine.m_cBaseScore += 5;
                            wTemp = (short) (m_Engine.m_wNearby & 0x3300);
                            if ((wTemp == 0x1100) || (wTemp == 0x2200))
                                m_Engine.m_cBaseScore += 3;
                        } else m_Engine.m_cBaseScore += 2;
                    }
                }
            } else if ((byTemp = (byte) (m_Engine.m_byAttach & 3)) == 0) {
                bGoto_LEFT_EMPTY = true; //lci
            } else if ((nInfo = L1StrLibs()) < 2) {
                if (byTemp == 2) {
                    if ((m_Engine.m_byAttach & 0x54) == 0 &&
                            (m_Engine.m_byAttach & 0x88) != 0)
                        m_Engine.m_cBaseScore += 4;
                } else if ((m_Engine.m_byAttach & 0xa8) == 0 &&
                        (m_Engine.m_byAttach & 0x44) != 0)
                    m_Engine.m_cBaseScore += 4;
            } else if (nInfo > 2) {
                if (m_Engine.m_byAttach == 0x26) {
                    if ((m_Engine.m_byIKen & 0xff) >= 0xc0) m_Engine.
                            m_cBaseScore += 3;
                    else if (U1StrLibs() <= 2) m_Engine.m_cBaseScore -= 2;
                    else if ((m_Engine.m_byKosumi & 0x41) == 0) {
                        byTemp = (byte) (m_Engine.m_byKosumi & 0x82);
                        if (byTemp == (byte) 0x82) m_Engine.m_cBaseScore -= 2;
                        else {
                            if (byTemp == 2) byConst1 = (byte) (
                                    RDCorner_U1White() - 1);
                            else {
                                byConst1 = LDCorner_U1White();
                                if (byTemp == (byte) 0x80) byConst1 -= 1;
                                else byConst1 += RDCorner_U1White();
                            }

                            if ((byte) byConst1 < 0) m_Engine.m_cBaseScore +=
                                    (byConst1 & 0xff);
                            else if (byTemp != 0) m_Engine.m_cBaseScore +=
                                    ((byConst1 & 0xff) + 2);
                            else if ((m_Engine.m_byIKen & 0x40) == 0) m_Engine.
                                    m_cBaseScore += (byConst1 & 0xff);
                            else {
                                byte byTmp = (15 < byConst1 + 7) ? 15 :
                                        (byte) (byConst1 + 7);
                                m_Engine.m_cBaseScore += (byTmp & 0xff);
                            }
                        }
                    }
                    //goto CONTINUE1;
//                    RotatePattern();
                    continue;
                }

                if (m_Engine.m_byAttach == 0x19) {
                    if ((m_Engine.m_byIKen & 0xff) >= 0xc0) m_Engine.
                            m_cBaseScore += 3;
                    else if (U1StrLibs() <= 2) m_Engine.m_cBaseScore -= 2;
                    else if ((m_Engine.m_byKosumi & 0x82) == 0) {
                        byTemp = (byte) (m_Engine.m_byKosumi & 0x41);
                        if (byTemp == 0x41) m_Engine.m_cBaseScore -= 2;
                        else {
                            if (byTemp == 1) byConst1 = (byte) (
                                    RDCorner_U1Black() - 1);
                            else {
                                byConst1 = LDCorner_U1Black();
                                if (byTemp == 0x40) byConst1 -= 1;
                                else byConst1 += RDCorner_U1Black();
                            }

                            if ((byte) byConst1 < 0) m_Engine.m_cBaseScore +=
                                    (byConst1 & 0xff);
                            else if (byTemp != 0) m_Engine.m_cBaseScore +=
                                    ((byConst1 & 0xff) + 2);
                            else if ((m_Engine.m_byIKen & 0x80) == 0) m_Engine.
                                    m_cBaseScore += (byConst1 & 0xff);
                            else {
                                m_Engine.m_cBaseScore +=
                                        Math.min(15, (byConst1 & 0xff) + 7);
                            }
                        }
                    }
                    //goto CONTINUE1;
//                    RotatePattern();
                    continue;
                }
                NO_SPECIAL:
                bGoto_NO_SPECIAL = true;
            } else {
                //wTemp = (short)(m_Engine.m_wNearby & 0xc3ff);
                if (((wTemp = (short) (m_Engine.m_wNearby & 0xc3ff)) == 0x0019) ||
                        (wTemp == 0x0026) ||
                        ((wTemp = (short) (m_Engine.m_wNearby & 0x3cff)) ==
                                0x0091) || (wTemp == 0x0062))
                    m_Engine.m_cBaseScore += 8;
                else if ((m_Engine.m_wNearby == 0x2811) ||
                        (m_Engine.m_wNearby == 0x1422)) {
                    if (L1U1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                    else m_Engine.m_cBaseScore += 12;
                } else if ((wTemp = (short) (m_Engine.m_wNearby & 0x3f0f)) ==
                        0x1801) {
                    if ((m_Engine.m_wNearby & 0x00a0) != 0 ||
                            (m_Engine.m_wNearby & 0x0050) == 0) {
                        if (L1U1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                        else m_Engine.m_cBaseScore += 12;
                    }
                } else if (wTemp == 0x2402) {
                    if ((m_Engine.m_wNearby & 0x0050) != 0 ||
                            (m_Engine.m_wNearby & 0x00a0) == 0) {
                        if (L1U1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                        else m_Engine.m_cBaseScore += 12;
                    }
                } else if ((m_Engine.m_wNearby == (short) 0x8211) ||
                        (m_Engine.m_wNearby == 0x4122)) {
                    if (L1D1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                    else m_Engine.m_cBaseScore += 12;
                } else if ((wTemp = (short) (m_Engine.m_wNearby & 0xcfc3)) ==
                        0x4201) {
                    if ((m_Engine.m_wNearby & 0x0028) != 0 ||
                            (m_Engine.m_wNearby & 0x0014) == 0) {
                        if (L1D1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                        else m_Engine.m_cBaseScore += 12;
                    }
                } else if (wTemp == (short) 0x8102) {
                    if ((m_Engine.m_wNearby & 0x0014) != 0 ||
                            (m_Engine.m_wNearby & 0x0028) == 0) {
                        if (L1D1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                        else m_Engine.m_cBaseScore += 12;
                    }
                } else if ((m_Engine.m_wNearby & 0xcfc7) == 0x4801) {
                    if (L1U1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                    else {
                        m_Engine.m_cBaseScore += 4;
                        if ((m_Engine.m_byIKen & 0x80) != 0) m_Engine.
                                m_cBaseScore += 6;
                        else if ((m_Engine.m_wKeima & 0x8002) != 0) m_Engine.
                                m_cBaseScore += 2;
                    }
                } else if ((wTemp = (short) (m_Engine.m_wNearby & 0xc3cf)) ==
                        0x4009) {
                    m_Engine.m_cBaseScore += 4;
                    if ((m_Engine.m_byIKen & 0x80) != 0) m_Engine.m_cBaseScore +=
                            6;
                    else if ((m_Engine.m_wKeima & 0x8002) != 0) m_Engine.
                            m_cBaseScore += 2;
                } else if (wTemp == (short) 0x8006) {
                    m_Engine.m_cBaseScore += 4;
                    if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.m_cBaseScore +=
                            6;
                    else if ((m_Engine.m_wKeima & 0x4001) != 0) m_Engine.
                            m_cBaseScore += 2;
                } else if ((m_Engine.m_wNearby & 0xcfcb) == 0x8402) {
                    if (L1U1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                    else {
                        m_Engine.m_cBaseScore += 4;
                        if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.
                                m_cBaseScore += 6;
                        else if ((m_Engine.m_wKeima & 0x4001) != 0) m_Engine.
                                m_cBaseScore += 2;
                    }
                } else if ((m_Engine.m_wNearby & 0x3f4f) == 0x1201) {
                    if (L1D1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                    else {
                        m_Engine.m_cBaseScore += 4;
                        if ((m_Engine.m_byIKen & 8) != 0) m_Engine.m_cBaseScore +=
                                6;
                        else if ((m_Engine.m_wKeima & 0x0280) != 0) m_Engine.
                                m_cBaseScore += 2;
                    }
                } else if ((wTemp = (short) (m_Engine.m_wNearby & 0x3ccf)) ==
                        0x1081) {
                    m_Engine.m_cBaseScore += 4;
                    if ((m_Engine.m_byIKen & 8) != 0) m_Engine.m_cBaseScore +=
                            6;
                    else if ((m_Engine.m_wKeima & 0x0280) != 0) m_Engine.
                            m_cBaseScore += 2;
                } else if (wTemp == 0x2042) {
                    m_Engine.m_cBaseScore += 4;
                    if ((m_Engine.m_byIKen & 4) != 0) m_Engine.m_cBaseScore +=
                            6;
                    else if ((m_Engine.m_wKeima & 0x0140) != 0) m_Engine.
                            m_cBaseScore += 2;
                } else if ((m_Engine.m_wNearby & 0x3f8f) == 0x2102) {
                    if (L1D1StrLibs() < 2) m_Engine.m_cBaseScore -= 4;
                    else {
                        m_Engine.m_cBaseScore += 4;
                        if ((m_Engine.m_byIKen & 4) != 0) m_Engine.m_cBaseScore +=
                                6;
                        else if ((m_Engine.m_wKeima & 0x0140) != 0) m_Engine.
                                m_cBaseScore += 2;
                    }
                } else {
                    if ((wTemp = (short) (m_Engine.m_wNearby & 0x03cf)) == 6) {
                        byParam[0] = m_Engine.m_cBaseScore;
                        LDCorner_L1Black(byParam);
                        m_Engine.m_cBaseScore = byParam[0];
                    } else if (wTemp == 9) {
                        byParam[0] = m_Engine.m_cBaseScore;
                        LDCorner_L1White(byParam);
                        m_Engine.m_cBaseScore = byParam[0];
                    } else if ((wTemp = (short) (m_Engine.m_wNearby & 0x0ccf)) ==
                            0x0042) {
                        byParam[0] = m_Engine.m_cBaseScore;
                        LUCorner_L1Black(byParam);
                        m_Engine.m_cBaseScore = byParam[0];
                    } else if (wTemp == 0x0081) {
                        byParam[0] = m_Engine.m_cBaseScore;
                        LUCorner_L1White(byParam);
                        m_Engine.m_cBaseScore = byParam[0];
                    } else {
                        bGoto_NO_SPECIAL = true;
                    }
                }
            }
//CONTINUE1:
//            RotatePattern();
            if (bGoto_NO_SPECIAL || bGoto_LEFT_EMPTY) {
                if (bGoto_NO_SPECIAL) {
                    //goto NO_SPECIAL;
                    if ((m_Engine.m_byIKen & 0x0c) != 0x0c) {
                        if (m_Engine.m_wNearby == 0x1402) {
                            if ((m_Engine.m_wKeima & 0x0282) == 0) {
                                if ((m_Engine.m_byKeima2 & 1) != 0 &&
                                        (m_Engine.m_byKeima1 & 0x40) != 0)
                                    m_Engine.m_cBaseScore -= 2;
                                else m_Engine.m_cBaseScore += 3;
                            }
                        } else if (m_Engine.m_wNearby == 0x2801) {
                            if ((m_Engine.m_wKeima & 0x0141) == 0) {
                                if ((m_Engine.m_byKeima2 & 2) != 0
                                        && (m_Engine.m_byKeima1 & 0x80) != 0)
                                    m_Engine.m_cBaseScore -= 2;
                                else m_Engine.m_cBaseScore += 3;
                            }
                        } else if ((wTemp = (short) (m_Engine.m_wNearby &
                                0x0fcf)) == 0x0801) {
                            if (L1U1StrLibs() > 2) {
                                if ((m_Engine.m_wNearby & 0xf030) == 0 &&
                                        (m_Engine.m_byIKen & 0x10) == 0 &&
                                        (m_Engine.m_byKeima2 & 4) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                if ((m_Engine.m_byIKen & 8) != 0 &&
                                        (m_Engine.m_byIKen & 3) == 0 &&
                                        (m_Engine.m_byKeima1 & 4) == 0)
                                    m_Engine.m_cBaseScore += 3;
                            }
                        } else if (wTemp == 0x0402) {
                            if (L1U1StrLibs() > 2) {
                                if ((m_Engine.m_wNearby & 0xf030) == 0 &&
                                        (m_Engine.m_byIKen & 0x20) == 0 &&
                                        (m_Engine.m_byKeima2 & 8) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                if ((m_Engine.m_byIKen & 4) != 0 &&
                                        (m_Engine.m_byIKen & 3) == 0 &&
                                        (m_Engine.m_byKeima1 & 8) == 0)
                                    m_Engine.m_cBaseScore += 3;
                            }
                        }
                    }

                    byParam[0] = m_Engine.m_cBaseScore;
                    ret = Pattern_0402(byParam);
                    m_Engine.m_cBaseScore = byParam[0];
                    if (ret == 0) {
                        if (m_Engine.m_nPosCode == 4) {
                            if ((nInfo = U2PosCode()) == 3) {
                                if (L1U1StrLibs() > 4)
                                    m_Engine.m_cBaseScore += 2;
                            } else if (nInfo > 3) {
                                if (D2PosCode() == 3)
                                    m_Engine.m_cBaseScore += 2;
                                else m_Engine.m_cBaseScore++;
                            } else if ((nInfo = L1U1StrLibs()) > 2)
                                m_Engine.m_cBaseScore += 4;
                            else if (nInfo == 2) {
                                if ((m_Engine.m_wNearby & 0x1000) != 0)
                                    m_Engine.m_cBaseScore += 2;
                                else if ((m_Engine.m_byIKen & 4) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                else m_Engine.m_cBaseScore -= 2;
                            }
                        }
                        //goto CONTINUE1;
//                            RotatePattern();
                        continue;
                    }

                    byParam[0] = m_Engine.m_cBaseScore;
                    ret = Pattern_0801(byParam);
                    m_Engine.m_cBaseScore = byParam[0];
                    if (ret == 0) {
                        if (m_Engine.m_nPosCode == 4) {
                            if ((nInfo = U2PosCode()) == 3) {
                                if (L1U1StrLibs() > 4)
                                    m_Engine.m_cBaseScore += 2;
                            } else if (nInfo > 3) {
                                if (D2PosCode() == 3)
                                    m_Engine.m_cBaseScore += 2;
                                else m_Engine.m_cBaseScore++;
                            } else if ((nInfo = L1U1StrLibs()) > 2)
                                m_Engine.m_cBaseScore += 4;
                            else if (nInfo == 2) {
                                if ((m_Engine.m_wNearby & 0x2000) != 0)
                                    m_Engine.m_cBaseScore += 2;
                                else if ((m_Engine.m_byIKen & 8) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                else m_Engine.m_cBaseScore -= 2;
                            }
                        }
                        //goto CONTINUE1;
//                            RotatePattern();
                        continue;
                    }

                    if ((m_Engine.m_byIKen & 0xff) < 0xc0) {
                        if (m_Engine.m_wNearby == 0x4102) {
                            if ((m_Engine.m_wKeima & 0x8082) == 0) {
                                if ((m_Engine.m_byKeima2 & 0x40) != 0 &&
                                        (m_Engine.m_byKeima1 & 1) != 0)
                                    m_Engine.m_cBaseScore -= 2;
                                else
                                    m_Engine.m_cBaseScore += 3;
                            }
                        } else if (m_Engine.m_wNearby == (short) 0x8201) {
                            if ((m_Engine.m_wKeima & 0x4041) == 0) {
                                if ((m_Engine.m_byKeima2 & 0x80) != 0 &&
                                        (m_Engine.m_byKeima1 & 2) != 0)
                                    m_Engine.m_cBaseScore -= 2;
                                else m_Engine.m_cBaseScore += 3;
                            }
                        } else if ((wTemp = (short) (m_Engine.m_wNearby &
                                0x0fcf)) == 0x0201) {
                            if (L1D1StrLibs() > 2) {
                                if ((m_Engine.m_wNearby & 0xf030) == 0 &&
                                        (m_Engine.m_byIKen & 0x10) == 0 &&
                                        (m_Engine.m_byKeima2 & 0x10) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                if ((m_Engine.m_byIKen & 0x80) != 0 &&
                                        (m_Engine.m_byIKen & 3) == 0 &&
                                        (m_Engine.m_byKeima1 & 0x10) == 0)
                                    m_Engine.m_cBaseScore += 3;
                            }
                        } else if (wTemp == 0x0102) {
                            if (L1D1StrLibs() > 2) {
                                if ((m_Engine.m_wNearby & 0xf030) == 0 &&
                                        (m_Engine.m_byIKen & 0x20) == 0 &&
                                        (m_Engine.m_byKeima2 & 0x20) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                if ((m_Engine.m_byIKen & 0x40) != 0 &&
                                        (m_Engine.m_byIKen & 3) == 0 &&
                                        (m_Engine.m_byKeima1 & 0x20) == 0)
                                    m_Engine.m_cBaseScore += 3;
                            }
                        }
                    }

                    byParam[0] = m_Engine.m_cBaseScore;
                    ret = Pattern_0102(byParam);
                    m_Engine.m_cBaseScore = byParam[0];
                    if (ret == 0) {
                        if (m_Engine.m_nPosCode == 4) {
                            if ((nInfo = D2PosCode()) == 3) {
                                if (L1D1StrLibs() > 4)
                                    m_Engine.m_cBaseScore += 2;
                            } else if (nInfo > 3) {
                                if (U2PosCode() == 3)
                                    m_Engine.m_cBaseScore += 2;
                                else m_Engine.m_cBaseScore++;
                            } else if ((nInfo = L1D1StrLibs()) > 2)
                                m_Engine.m_cBaseScore += 4;
                            else if (nInfo == 2) {
                                if ((m_Engine.m_wNearby & 0x4000) != 0)
                                    m_Engine.m_cBaseScore += 2;
                                else if ((m_Engine.m_byIKen & 0x40) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                else m_Engine.m_cBaseScore -= 2;
                            }
                        }
                        //goto CONTINUE1;
//                            RotatePattern();
                        continue;
                    }

                    byParam[0] = m_Engine.m_cBaseScore;
                    ret = Pattern_0201(byParam);
                    m_Engine.m_cBaseScore = byParam[0];
                    if (ret == 0) {
                        if (m_Engine.m_nPosCode == 4) {
                            if ((nInfo = D2PosCode()) == 3) {
                                if (L1D1StrLibs() > 4)
                                    m_Engine.m_cBaseScore += 2;
                            } else if (nInfo > 3) {
                                if (U2PosCode() == 3)
                                    m_Engine.m_cBaseScore += 2;
                                else m_Engine.m_cBaseScore++;
                            } else if ((nInfo = L1D1StrLibs()) > 2)
                                m_Engine.m_cBaseScore += 4;
                            else if (nInfo == 2) {
                                if ((m_Engine.m_wNearby & 0x8000) != 0)
                                    m_Engine.m_cBaseScore += 2;
                                else if ((m_Engine.m_byIKen & 0x80) != 0)
                                    m_Engine.m_cBaseScore += 4;
                                else m_Engine.m_cBaseScore -= 2;
                            }
                        }
                        //goto CONTINUE1;
//                            RotatePattern();
                        continue;
                    }
                }
                LEFT_EMPTY:
                if ((m_Engine.m_wNearby & 0x4bff) == 0x0024) {
                    if (IsU1orR1StrDead() != 0) m_Engine.m_cBaseScore -= 2;
                    else if (((m_Engine.m_byIKen & 0xff) < 0xc0) &&
                            ((m_Engine.m_byIKen & 3) != 3)) {
                        if ((m_Engine.m_wNearby & 0x8400) == 0) {
                            byConst1 = 0;
                            byTemp = (byte) (m_Engine.m_byIKen & 3);
                            if (byTemp == 0) {
                                if ((m_Engine.m_byKeima1 & 0x20) != 0) byConst1 =
                                        6;
                            } else if (byTemp == 2) {
                                if (((m_Engine.m_byKeima1 & 1) != 0) ||
                                        ((m_Engine.m_byIKen & 0x40) != 0))
                                    byConst1 = 6;
                                else if ((m_Engine.m_byIKen & 0x80) != 0)
                                    byConst1 = (byte) 0xFF; //by Jong 2004/8/5
                                else if ((m_Engine.m_byKeima2 & 0x80) != 0) {
                                    //goto CONTINUE1;
//                                            RotatePattern();
                                    continue;
                                } else if ((m_Engine.m_byKeima1 & 0x0a) == 0)
                                    byConst1 = 6;
                            }
                            if (byConst1 == 0) {
                                byTemp = (byte) (m_Engine.m_byIKen & 0xc0);
                                if (byTemp == 0) {
                                    if ((m_Engine.m_byKeima2 & 0x40) != 0)
                                        byConst1 = 6;
                                } else if (byTemp == 0x40) {
                                    if ((m_Engine.m_byKeima1 & 8) != 0 ||
                                            (m_Engine.m_byIKen & 2) != 0)
                                        byConst1 = 6;
                                    else if ((m_Engine.m_byIKen & 1) == 0) {
                                        if ((m_Engine.m_byKeima1 & 0x10) != 0) {
                                            //goto CONTINUE1;
//                                                    RotatePattern();
                                            continue;
                                        }
                                        if ((m_Engine.m_byKeima1 & 5) == 0)
                                            byConst1 = 6;
                                    }
                                }
                            }
                            if (((byConst1 == 0) || (byConst1 == -1)) &&
                                    ((m_Engine.m_wKeima & 0x8010) == 0)) {
                                if ((m_Engine.m_byIKen & 0x81) == 0 &&
                                        ((m_Engine.m_wKeima & 0x2040) == 0 ||
                                                (U1StrLibs() <= 2) || (R1StrLibs() <= 2)))
                                    byConst1 = 3;
                                else byConst1 = 1;
                            }
                            if ((byte) byConst1 > 0) m_Engine.m_cBaseScore +=
                                    (byConst1 & 0xff);
                        }
                    } else {
                        if ((m_Engine.m_byIKen & 0xff) < 0xc0) {
                            if ((ConsiderU1PosInf_Libs() != 0) &&
                                    (m_Engine.m_byKeima1 & 1) != 0)
                                m_Engine.m_cBaseScore -= 4;
                            else if ((m_Engine.m_byIKen & 0x40) != 0)
                                m_Engine.m_cBaseScore += 6;
                            else if ((m_Engine.m_byIKen & 0x80) != 0 ||
                                    (m_Engine.m_wNearby & 0x8000) != 0)
                                m_Engine.m_cBaseScore++;
                            else if ((m_Engine.m_byKeima2 & 0x40) != 0)
                                m_Engine.m_cBaseScore += 6;
                        } else if ((m_Engine.m_byIKen & 3) != 3) {
                            if ((ConsiderR1PosInf_Libs() != 0) &&
                                    ((m_Engine.m_byKeima1 & 8) != 0))
                                m_Engine.m_cBaseScore -= 4;
                            else if ((m_Engine.m_byIKen & 2) != 0)
                                m_Engine.m_cBaseScore += 6;
                            else if ((m_Engine.m_byIKen & 1) != 0 ||
                                    (m_Engine.m_wNearby & 0x0400) != 0)
                                m_Engine.m_cBaseScore++;
                            else if ((m_Engine.m_byKeima1 & 0x20) != 0)
                                m_Engine.m_cBaseScore += 6;
                        } else ConsiderU1PosInf_Libs();
                    }
                } else if ((m_Engine.m_wNearby & 0x87ff) == 0x0018) {
                    if (IsU1orR1StrDead() != 0) m_Engine.m_cBaseScore -= 2;
                    else if (((m_Engine.m_byIKen & 0xff) < 0xc0) &&
                            ((m_Engine.m_byIKen & 3) != 3)) {
                        if ((m_Engine.m_wNearby & 0x4800) == 0) {
                            byConst1 = 0;
                            byTemp = (byte) (m_Engine.m_byIKen & 3);
                            if (byTemp == 0) {
                                if ((m_Engine.m_byKeima1 & 0x10) != 0) byConst1 =
                                        6;
                            } else if (byTemp == 1) {
                                if ((m_Engine.m_byKeima1 & 2) != 0 ||
                                        (m_Engine.m_byIKen & 0x80) != 0)
                                    byConst1 = 6;
                                else if ((m_Engine.m_byIKen & 0x40) != 0)
                                    byConst1 = (byte) 0xFF; //by Jong
                                else if ((m_Engine.m_byKeima2 & 0x40) != 0) {
                                    //goto CONTINUE1;
//                                            RotatePattern();
                                    continue;
                                } else if ((m_Engine.m_byKeima1 & 5) == 0)
                                    byConst1 = 6;
                            }
                            if (byConst1 == 0) {
                                byTemp = (byte) (m_Engine.m_byIKen & 0xc0);
                                if (byTemp == 0) {
                                    if ((m_Engine.m_byKeima2 & 0x80) != 0)
                                        byConst1 = 6;
                                } else if (byTemp == (byte) 0x80) {
                                    if (((m_Engine.m_byKeima1 & 4) != 0) ||
                                            ((m_Engine.m_byIKen & 1) != 0))
                                        byConst1 = 6;
                                    else if ((m_Engine.m_byIKen & 2) == 0) {
                                        if ((m_Engine.m_byKeima1 & 0x20) != 0) {
                                            //goto CONTINUE1;
//                                                    RotatePattern();
                                            continue;
                                        }
                                        if ((m_Engine.m_byKeima1 & 0x0a) == 0)
                                            byConst1 = 6;
                                    }
                                }
                            }
                            if (((byConst1 == 0) || (byConst1 == -1)) &&
                                    (m_Engine.m_wKeima & 0x4020) == 0) {
                                if ((m_Engine.m_byIKen & 0x42) == 0 &&
                                        ((m_Engine.m_wKeima & 0x1080) == 0 ||
                                                (U1StrLibs() <= 2) ||
                                                (R1StrLibs() <= 2)))
                                    byConst1 = 3;
                                else byConst1 = 1;
                            }
                            if ((byte) byConst1 > 0) m_Engine.m_cBaseScore +=
                                    (byConst1 & 0xff);
                        }
                    } else {
                        if ((m_Engine.m_byIKen & 0xff) < 0xc0) {
                            if ((ConsiderU1PosInf_Libs() != 0) &&
                                    (m_Engine.m_byKeima1 & 2) != 0)
                                m_Engine.m_cBaseScore -= 4;
                            else if ((m_Engine.m_byIKen & 0x80) != 0)
                                m_Engine.m_cBaseScore += 6;
                            else if ((m_Engine.m_byIKen & 0x40) != 0 ||
                                    (m_Engine.m_wNearby & 0x4000) != 0)
                                m_Engine.m_cBaseScore++;
                            else if ((m_Engine.m_byKeima2 & 0x80) != 0)
                                m_Engine.m_cBaseScore += 6;
                        } else if ((m_Engine.m_byIKen & 3) != 3) {
                            if ((ConsiderR1PosInf_Libs() != 0) &&
                                    (m_Engine.m_byKeima1 & 4) != 0)
                                m_Engine.m_cBaseScore -= 4;
                            else if ((m_Engine.m_byIKen & 1) != 0)
                                m_Engine.m_cBaseScore += 6;
                            else if ((m_Engine.m_byIKen & 2) != 0 ||
                                    (m_Engine.m_wNearby & 0x0800) != 0)
                                m_Engine.m_cBaseScore++;
                            else if ((m_Engine.m_byKeima1 & 0x10) != 0)
                                m_Engine.m_cBaseScore += 6;
                        } else ConsiderU1PosInf_Libs();
                    }
                } else if (m_Engine.m_nPosCode == 3) {
                    if (((m_Engine.m_byIKen & 0xff) >= 0xc0) &&
                            ((m_Engine.m_wNearby == 0x2400) ||
                                    (m_Engine.m_wNearby == 0x1800)))
                        m_Engine.m_cBaseScore += 3;
                    else if ((m_Engine.m_wNearby & 0x3f5f) == 0x1801) {
                        byTemp = (byte) (m_Engine.m_byIKen & 0xc1);
                        if (L1U1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                        else if ((byTemp & 0xff) >= 0xc0) {
                            if ((byTemp == (byte) 0xc0) &&
                                    (WhoseInfluenceOnL1() != 1))
                                m_Engine.m_cBaseScore += 10;
                        } else if ((m_Engine.m_byIKen & 0x0c) == 0x0c) {
                            if ((m_Engine.m_byKeima1 & 4) == 0 &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        } else if ((m_Engine.m_byDKosumi & 8) != 0 ||
                                (m_Engine.m_byKeima1 & 0xa0) != 0) {
                            m_Engine.m_cBaseScore += 2;
                            if ((m_Engine.m_byIKen & 4) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima2 & 1) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima1 & 4) == 0 &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        }
                    } else if ((m_Engine.m_wNearby & 0x3faf) == 0x2402) {
                        byTemp = (byte) (m_Engine.m_byIKen & 0xc2);
                        if (L1U1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                        else if ((byTemp & 0xff) >= 0xc0) {
                            if ((byTemp == (byte) 0xc0) &&
                                    (WhoseInfluenceOnL1() != 1))
                                m_Engine.m_cBaseScore += 10;
                        } else if ((m_Engine.m_byIKen & 0x0c) == 0x0c) {
                            if ((m_Engine.m_byKeima1 & 8) == 0 &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        } else if ((m_Engine.m_byDKosumi & 4) != 0 ||
                                (m_Engine.m_byKeima1 & 0x50) != 0) {
                            m_Engine.m_cBaseScore += 2;
                            if ((m_Engine.m_byIKen & 8) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima2 & 2) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima1 & 8) == 0 &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        }
                    } else if ((m_Engine.m_wNearby & 0xcfd7) == 0x4201) {
                        byTemp = (byte) (m_Engine.m_byIKen & 0x0d);
                        if (L1D1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                        else if ((byTemp & 0xff) >= 0x0c) {
                            if ((byTemp == 0x0c) && (WhoseInfluenceOnL1() != 1))
                                m_Engine.m_cBaseScore += 10;
                        } else if ((m_Engine.m_byIKen & 0xff) >= 0xc0) {
                            if ((m_Engine.m_byKeima1 & 0x10) == 0 &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        } else if ((m_Engine.m_byDKosumi & 2) != 0 ||
                                (m_Engine.m_byKeima1 & 0x0a) != 0) {
                            m_Engine.m_cBaseScore += 2;
                            if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima2 & 0x40) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima1 & 0x10) == 0 &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        }
                    } else if ((m_Engine.m_wNearby & 0xcfeb) == 0x8102) {
                        if (L1D1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                        else if ((byTemp = (byte) (m_Engine.m_byIKen & 0x0e)) >=
                                0x0c) {
                            if ((byTemp == 0x0c) && (WhoseInfluenceOnL1() != 1))
                                m_Engine.m_cBaseScore += 10;
                        } else if ((m_Engine.m_byIKen & 0xff) >= 0xc0) {
                            if (((m_Engine.m_byKeima1 & 0x20) == 0) &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        } else if ((m_Engine.m_byDKosumi & 1) != 0 ||
                                (m_Engine.m_byKeima1 & 0x05) != 0) {
                            m_Engine.m_cBaseScore += 2;
                            if ((m_Engine.m_byIKen & 0x80) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima2 & 0x80) != 0) m_Engine.
                                    m_cBaseScore++;
                            if ((m_Engine.m_byKeima1 & 0x20) == 0 &&
                                    (L1StrLibs() == 3))
                                m_Engine.m_cBaseScore += 2;
                        }
                    }
                } else if ((wTemp = (short) (m_Engine.m_wNearby & 0xcfff)) ==
                        0x0900) {
                    if (((m_Engine.m_byIKen & 0x20) != 0) &&
                            ((m_Engine.m_byKeima2 & 5) == 0) &&
                            (m_Engine.m_byDKosumi & 0x10) == 0)
                        m_Engine.m_cBaseScore -= 2;

                    if ((m_Engine.m_byKeima2 & 0x20) != 0) {
                        if ((m_Engine.m_wNearby & 0x2000) == 0) m_Engine.
                                m_cBaseScore += 3;
                    } else if ((m_Engine.m_byKeima2 & 0x80) != 0)
                        m_Engine.m_cBaseScore += 3;
                    else if ((m_Engine.m_byDKosumi & 0x80) != 0) {
                        if ((m_Engine.m_byIKen & 0x80) != 0)
                            m_Engine.m_cBaseScore += 5;
                        else m_Engine.m_cBaseScore += 4;
                    } else if ((m_Engine.m_byIKen & 0x30) == 0 &&
                            ((m_Engine.m_wOKeima & 0x3000) == 0x2000))
                        m_Engine.m_cBaseScore += 3;
                } else if (wTemp == (short) 0x8100) {
                    if ((m_Engine.m_byIKen & 8) != 0 &&
                            (m_Engine.m_byKeima2 & 5) == 0 &&
                            (m_Engine.m_byDKosumi & 0x10) == 0)
                        m_Engine.m_cBaseScore -= 2;

                    if ((m_Engine.m_byKeima1 & 0x80) != 0) {
                        if ((m_Engine.m_wNearby & 0x2000) == 0)
                            m_Engine.m_cBaseScore += 3;
                    } else if ((m_Engine.m_byKeima1 & 0x20) != 0)
                        m_Engine.m_cBaseScore += 3;
                    else if ((m_Engine.m_byKeima1 & 0x50) == 0) {
                        if ((m_Engine.m_byDKosumi & 8) != 0) {
                            if ((m_Engine.m_byIKen & 2) != 0) m_Engine.
                                    m_cBaseScore += 5;
                            else m_Engine.m_cBaseScore += 4;
                        } else if ((m_Engine.m_byIKen & 0x0c) == 0 &&
                                ((m_Engine.m_wOKeima & 0x00c0) == 0x0080))
                            m_Engine.m_cBaseScore += 3;
                    }
                } else if (wTemp == 0x0100) {
                    if ((m_Engine.m_wKeima & 0xc030) == 0x8020)
                        m_Engine.m_cBaseScore += 6;
                    else if ((m_Engine.m_wNearby & 0x2000) == 0) {
                        if (((m_Engine.m_wKeima & 0xc0c0) == 0x8080) ||
                                ((m_Engine.m_wKeima & 0x3030) == 0x2020))
                            m_Engine.m_cBaseScore += 4;
                        else if ((m_Engine.m_wKeima & 0xf030) == 0x0020) {
                            if ((m_Engine.m_byDKosumi & 0x80) != 0) {
                                if ((m_Engine.m_byIKen & 0x80) != 0)
                                    m_Engine.m_cBaseScore += 5;
                                else
                                    m_Engine.m_cBaseScore += 4;
                            } else if ((m_Engine.m_byIKen & 0x30) == 0 &&
                                    ((m_Engine.m_wOKeima & 0x3000) == 0x2000))
                                m_Engine.m_cBaseScore += 3;
                        } else if ((m_Engine.m_wKeima & 0xc0f0) == 0x8000) {
                            if ((m_Engine.m_byDKosumi & 8) != 0) {
                                if ((m_Engine.m_byIKen & 2) != 0) m_Engine.
                                        m_cBaseScore += 5;
                                else m_Engine.m_cBaseScore += 4;
                            } else if ((m_Engine.m_byIKen & 0x0c) == 0 &&
                                    ((m_Engine.m_wOKeima & 0x00c0) == 0x0080))
                                m_Engine.m_cBaseScore += 3;
                        }
                    }
                } else if ((wTemp = (short) (m_Engine.m_wNearby & 0xcfff)) ==
                        0x0600) {
                    if ((m_Engine.m_byIKen & 0x10) != 0 &&
                            (m_Engine.m_byKeima2 & 0x0a) == 0 &&
                            (m_Engine.m_byDKosumi & 0x20) == 0)
                        m_Engine.m_cBaseScore -= 2;

                    if ((m_Engine.m_byKeima2 & 0x10) != 0) {
                        if ((m_Engine.m_wNearby & 0x1000) == 0) m_Engine.
                                m_cBaseScore += 3;
                    } else if ((m_Engine.m_byKeima2 & 0x40) != 0) m_Engine.
                            m_cBaseScore += 3;
                    else if ((m_Engine.m_byDKosumi & 0x40) != 0) {
                        if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.
                                m_cBaseScore += 5;
                        else m_Engine.m_cBaseScore += 4;
                    } else if ((m_Engine.m_byIKen & 0x30) == 0 &&
                            ((m_Engine.m_wOKeima & 0x3000) == 0x1000))
                        m_Engine.m_cBaseScore += 3;
                } else if (wTemp == 0x4200) {
                    if (((m_Engine.m_byIKen & 4) != 0) &&
                            ((m_Engine.m_byKeima2 & 0x0a) == 0) &&
                            ((m_Engine.m_byDKosumi & 0x20) == 0))
                        m_Engine.m_cBaseScore -= 2;

                    if ((m_Engine.m_byKeima1 & 0x40) != 0) {
                        if ((m_Engine.m_wNearby & 0x1000) == 0) m_Engine.
                                m_cBaseScore += 3;
                    } else if ((m_Engine.m_byKeima1 & 0x10) != 0) m_Engine.
                            m_cBaseScore += 3;
                    else if ((m_Engine.m_byKeima1 & 0xa0) == 0) {
                        if ((m_Engine.m_byDKosumi & 4) != 0) {
                            if ((m_Engine.m_byIKen & 1) != 0) m_Engine.
                                    m_cBaseScore += 5;
                            else m_Engine.m_cBaseScore += 4;
                        } else if ((m_Engine.m_byIKen & 0x0c) == 0 &&
                                ((m_Engine.m_wOKeima & 0x00c0) == 0x0040))
                            m_Engine.m_cBaseScore += 3;
                    }
                } else if (wTemp == 0x0200) {
                    if ((m_Engine.m_wKeima & 0xc030) == 0x4010) m_Engine.
                            m_cBaseScore += 6;
                    else if ((m_Engine.m_wNearby & 0x1000) == 0) {
                        if (((m_Engine.m_wKeima & 0xc0c0) == 0x4040) ||
                                ((m_Engine.m_wKeima & 0x3030) == 0x1010))
                            m_Engine.m_cBaseScore += 4;
                        else if ((m_Engine.m_wKeima & 0xf030) == 0x0010) {
                            if ((m_Engine.m_byDKosumi & 0x40) != 0) {
                                if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.
                                        m_cBaseScore += 5;
                                else m_Engine.m_cBaseScore += 4;
                            } else if ((m_Engine.m_byIKen & 0x30) == 0 &&
                                    ((m_Engine.m_wOKeima & 0x3000) == 0x1000))
                                m_Engine.m_cBaseScore += 3;
                        } else if ((m_Engine.m_wKeima & 0xc0f0) == 0x4000) {
                            if ((m_Engine.m_byDKosumi & 4) != 0) {
                                if ((m_Engine.m_byIKen & 1) != 0) m_Engine.
                                        m_cBaseScore += 5;
                                else m_Engine.m_cBaseScore += 4;
                            } else if (((m_Engine.m_byIKen & 0x0c) == 0) &&
                                    ((m_Engine.m_wOKeima & 0x00c0) == 0x0040))
                                m_Engine.m_cBaseScore += 3;
                        }
                    }
                } else if ((m_Engine.m_wNearby & 0x3f5f) == 0x1801) {
                    byTemp = (byte) (m_Engine.m_byIKen & 0xc1);
                    if (L1U1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                    else if ((byTemp & 0xff) >= 0xc0) {
                        if ((byTemp == (byte) 0xc0) &&
                                (WhoseInfluenceOnL1() != 1))
                            m_Engine.m_cBaseScore += 10;
                    } else if ((m_Engine.m_byIKen & 0x0c) == 0x0c) {
                        if ((m_Engine.m_byKeima1 & 4) == 0 && (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    } else if ((m_Engine.m_byDKosumi & 8) != 0 ||
                            (m_Engine.m_byKeima1 & 0xa0) != 0) {
                        if ((m_Engine.m_byIKen & 4) != 0) m_Engine.m_cBaseScore +=
                                3;
                        else m_Engine.m_cBaseScore += 2;

                        if ((m_Engine.m_byKeima2 & 1) != 0) m_Engine.
                                m_cBaseScore++;
                        if ((m_Engine.m_byKeima1 & 4) == 0 && (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    }
                } else if ((m_Engine.m_wNearby & 0x3faf) == 0x2402) {
                    byTemp = (byte) (m_Engine.m_byIKen & 0xc2);
                    if (L1U1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                    else if ((byTemp & 0xff) >= 0xc0) {
                        if ((byTemp == (byte) 0xc0) &&
                                (WhoseInfluenceOnL1() != 1))
                            m_Engine.m_cBaseScore += 10;
                    } else if ((m_Engine.m_byIKen & 0x0c) == 0x0c) {
                        if ((m_Engine.m_byKeima1 & 8) == 0 && (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    } else if ((m_Engine.m_byDKosumi & 4) != 0 ||
                            (m_Engine.m_byKeima1 & 0x50) != 0) {
                        if ((m_Engine.m_byIKen & 8) != 0) m_Engine.m_cBaseScore +=
                                3;
                        else m_Engine.m_cBaseScore += 2;

                        if ((m_Engine.m_byKeima2 & 2) != 0) m_Engine.
                                m_cBaseScore++;
                        if ((m_Engine.m_byKeima1 & 8) == 0 && (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    }
                } else if ((m_Engine.m_wNearby & 0xcfd7) == 0x4201) {
                    byTemp = (byte) (m_Engine.m_byIKen & 0x0d);
                    if (L1D1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                    else if ((byTemp & 0xff) >= 0x0c) {
                        if ((byTemp == 0x0c) && (WhoseInfluenceOnL1() != 1))
                            m_Engine.m_cBaseScore += 10;
                    } else if ((m_Engine.m_byIKen & 0xff) >= 0xc0) {
                        if (((m_Engine.m_byKeima1 & 0x10) == 0) &&
                                (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    } else if ((m_Engine.m_byDKosumi & 2) != 0 ||
                            (m_Engine.m_byKeima1 & 0x0a) != 0) {
                        if ((m_Engine.m_byIKen & 0x40) != 0) m_Engine.
                                m_cBaseScore += 3;
                        else m_Engine.m_cBaseScore += 2;

                        if ((m_Engine.m_byKeima2 & 0x40) != 0) m_Engine.
                                m_cBaseScore++;
                        if ((m_Engine.m_byKeima1 & 0x10) == 0 &&
                                (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    }
                } else if ((m_Engine.m_wNearby & 0xcfeb) == 0x8102) {
                    byTemp = (byte) (m_Engine.m_byIKen & 0x0e);
                    if (L1D1StrLibs() <= 2) m_Engine.m_cBaseScore -= 4;
                    else if ((byTemp & 0xff) >= 0x0c) {
                        if ((byTemp == 0x0c) && (WhoseInfluenceOnL1() != 1))
                            m_Engine.m_cBaseScore += 10;
                    } else if ((m_Engine.m_byIKen & 0xff) >= 0xc0) {
                        if ((m_Engine.m_byKeima1 & 0x20) == 0 &&
                                (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    } else if ((m_Engine.m_byDKosumi & 1) != 0 ||
                            (m_Engine.m_byKeima1 & 5) != 0) {
                        if ((m_Engine.m_byIKen & 0x80) != 0) m_Engine.
                                m_cBaseScore += 3;
                        else m_Engine.m_cBaseScore += 2;

                        if ((m_Engine.m_byKeima2 & 0x80) != 0) m_Engine.
                                m_cBaseScore++;
                        if ((m_Engine.m_byKeima1 & 0x20) == 0 &&
                                (L1StrLibs() == 3))
                            m_Engine.m_cBaseScore += 2;
                    }
                }
            }
        }
        return;
    }

    short Pattern_0201(byte[] cScore)
    {
        short	nInfo;
        byte	byTemp;

        if ((m_Engine.m_wNearby & 0x5fff) != 0x0201) return 1;

        if (L1D1StrStatus() == 2)
        {
            cScore[0] -= 2;
            return 0;
        }

        nInfo = L1StrLibs();
        byTemp = (byte)(m_Engine.m_byIKen & 0xc0);
        if (byTemp != (byte)0xc0)
        {
            if ((byTemp == (byte)0x80) || (m_Engine.m_byKosumi & 0x80) != 0)
                cScore[0] ++;
            else if ((nInfo != 2) && ((m_Engine.m_byKeima1 & 0x0e) == 4))
            {
                if ((m_Engine.m_byIKen & 1) != 0 || (m_Engine.m_byKeima1 & 0xb0) != 0)
                {
                    if (nInfo > 2) cScore[0] -= 2;
                    else cScore[0] += 3;
                }
                else if (m_Engine.m_nPosCode == 3) cScore[0] -= 2;
                else if (m_Engine.m_nPosCode < 3) return 1;
                return 0;
            }

            if ((m_Engine.m_byIKen & 0x0c) == 0x0c)
            {
                if (nInfo == 2) cScore[0] += 4;
                else if ((m_Engine.m_byIKen & 1) == 0)
                {
                    nInfo = WhoseInfluenceOnL1();
                    if (nInfo != 1) cScore[0] += 4;
                    if (nInfo < 1) return 1;
                }
                return 0;
            }
        }

        if ((m_Engine.m_wNearby & 0x2000) != 0) cScore[0] ++;
        else if ((m_Engine.m_byIKen & 8) != 0 ||
                (m_Engine.m_byKeima2 & 2) != 0 ||
                ((m_Engine.m_byKeima2 & 0x0c) == 8))
            cScore[0] += 3;
        else
        {
            if ((m_Engine.m_byKeima1 & 0x80) != 0)
            {
                if ((m_Engine.m_byIKen & 1) != 0) cScore[0] ++;
                else
                {
                    cScore[0] += 3;
                    return 0;
                }
            }

            if (nInfo == 2) LUCorner_L1White(cScore);
            else if ((m_Engine.m_byIKen & 1) == 0 &&
                    (m_Engine.m_byKeima1 & 0x50) == 0)
                cScore[0] += 2;
        }
        return	0;
    }

    short D2PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL2[m_Engine.m_nEntry - 1]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }

    short U2PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL2[(m_Engine.m_nEntry + 1) & 3]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }

    byte LDCorner_U1Black()
    {
        byte cScore = 0;
        if ((m_Engine.m_byKeima1 & 0x0a) != 0)
        {
            if ((m_Engine.m_byKeima1 & 2) == 0) cScore += 8;
            else cScore += 6;
        }
        else if ((m_Engine.m_byKeima1 & 5) != 0) cScore --;
        else if ((m_Engine.m_byDKosumi & 2) != 0) cScore += 4;
        else if ((m_Engine.m_byDKosumi & 1) == 0)
        {
            cScore += 2;
            if ((m_Engine.m_byIKen & 1) == 0 && (L1StrLibs() == 3)) cScore += 4;
            else if ((m_Engine.m_byNiKen & 0xff) >= 0xc0) cScore -= 2;
        }
        return cScore;
    }

    byte RDCorner_U1Black()
    {
        byte cScore = 0;
        if ((m_Engine.m_byKeima2 & 0xa0) != 0)
        {
            if ((m_Engine.m_byKeima2 & 0x80) == 0) cScore += 8;
            else cScore += 6;
        }
        else if ((m_Engine.m_byKeima2 & 0x50) != 0) cScore --;
        else if ((m_Engine.m_byDKosumi & 0x80) != 0) cScore += 4;
        else if ((m_Engine.m_byDKosumi & 0x40) == 0)
        {
            cScore += 2;
            if ((m_Engine.m_byIKen & 0x10) == 0 && (R1StrLibs() == 3)) cScore += 4;
            else if ((m_Engine.m_byNiKen & 0xff) >= 0xc0) cScore -= 2;
        }
        return	cScore;
    }

    byte LDCorner_U1White()
    {
        byte cScore = 0;
        if ((m_Engine.m_byKeima1 & 5) != 0)
        {
            if ((m_Engine.m_byKeima1 & 1) == 0) cScore += 8;
            else cScore += 6;
        }
        else if ((m_Engine.m_byKeima1 & 0x0a) != 0) cScore --;
        else if ((m_Engine.m_byDKosumi & 1) != 0) cScore += 4;
        else if ((m_Engine.m_byDKosumi & 2) == 0)
        {
            cScore += 2;
            if ((m_Engine.m_byIKen & 2) == 0 && (L1StrLibs() == 3)) cScore += 4;
            else if ((m_Engine.m_byNiKen & 0xff) >= 0xc0) cScore -= 2;
        }
        return	cScore;
    }

    byte RDCorner_U1White()
    {
        byte cScore = 0;
        if ((m_Engine.m_byKeima2 & 0x50) != 0)
        {
            if ((m_Engine.m_byKeima2 & 0x40) == 0) cScore += 8;
            else cScore += 6;
        }
        else if ((m_Engine.m_byKeima2 & 0xa0) != 0) cScore --;
        else if ((m_Engine.m_byDKosumi & 0x40) != 0) cScore += 4;
        else if ((m_Engine.m_byDKosumi & 0x80) == 0)
        {
            cScore += 2;
            if ((m_Engine.m_byIKen & 0x20) == 0 && (R1StrLibs() == 3)) cScore += 4;
            else if ((m_Engine.m_byNiKen & 0xff) >= 0xc0) cScore -= 2;
        }
        return	cScore;
    }

    short ConsiderR1PosInf_Libs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 2) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return -1;

        if (m_Engine.m_cWeightBoard[nPos] != 0)
        {
            m_Engine.m_cBaseScore += 3;
            return 0;
        }
        if ((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) < 3)
        {
            m_Engine.m_cBaseScore += 5;
            return 0;
        }
        return 1;
    }

    short ConsiderU1PosInf_Libs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 1) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return -1;

        if (m_Engine.m_cWeightBoard[nPos] != 0)
        {
            m_Engine.m_cBaseScore += 3;
            return 0;
        }
        if ((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) < 3)
        {
            m_Engine.m_cBaseScore += 5;
            return 0;
        }
        return 1;
    }

    short R1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 2) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    short U1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 1) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    short IsU1orR1StrDead()
    {
        short	nPos1, nPos2;
        byte	byStr1, byStr2;

        nPos1 = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 1) & 3]]);
        nPos2 = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 2) & 3]]);

        if ((nPos1 < STARTPOS) || (nPos1 >= ENDPOS) || (nPos2 < STARTPOS) || (nPos2 >= ENDPOS) ||
                ((byStr1 = m_Engine.m_byBoard[nPos1]) == INITVALUE) ||
                ((byStr2 = m_Engine.m_byBoard[nPos2]) == INITVALUE))
            return 0;

        return (short)((m_Engine.m_wStatus[byStr1 & 0xff] | m_Engine.m_wStatus[byStr2 & 0xff]) & 0x08);
    }

    short D1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[m_Engine.m_nEntry - 1]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr] & 0xff);
    }

    short IsR1StrDead()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 2) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0;

        return (short)(m_Engine.m_wStatus[byStr & 0xff] & 0x08);
    }

    short IsU1StrDead()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[(m_Engine.m_nEntry + 1) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0;

        return (short)(m_Engine.m_wStatus[byStr & 0xff] & 0x08);
    }

    void RotatePattern()
    {
        m_Engine.m_wOKeima = rolw4(m_Engine.m_wOKeima);

        m_Engine.m_byAttach = rolb2(m_Engine.m_byAttach);
        m_Engine.m_byKosumi = rolb2(m_Engine.m_byKosumi);
        m_Engine.m_wNearby = MAKEWORD((m_Engine.m_byAttach & 0xff),
                (m_Engine.m_byKosumi & 0xff));

        m_Engine.m_wKeima = rolw4(m_Engine.m_wKeima);
        m_Engine.m_byKeima1 = LOBYTE(m_Engine.m_wKeima);
        m_Engine.m_byKeima2 = HIBYTE(m_Engine.m_wKeima);

        m_Engine.m_byNiKen = rolb2(m_Engine.m_byNiKen);

        m_Engine.m_byIKen = rolb2(m_Engine.m_byIKen);
        m_Engine.m_byDKosumi = rolb2(m_Engine.m_byDKosumi);
        m_Engine.m_wIKenDKos = MAKEWORD((m_Engine.m_byIKen & 0xff), (m_Engine.m_byDKosumi & 0xff));
    }

    short L1D1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[m_Engine.m_nEntry & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return (short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    void EvenPatternOnEdge()
    {
        short	wIKenDKos, wKeima, wNearby, wOKeima, wTemp;
        byte	byNiKen, byTemp, byTemp1;
        short	nInfo;

        wIKenDKos = m_Engine.m_wIKenDKos;
        wKeima = m_Engine.m_wKeima;
        byNiKen = m_Engine.m_byNiKen;
        wNearby = m_Engine.m_wNearby;
        wOKeima = m_Engine.m_wOKeima;

        for (m_Engine.m_nEntry = 4; m_Engine.m_nEntry > 0; m_Engine.m_nEntry --)
        {
            if ((m_Engine.m_byAttach & 0xff) >= 0xc0) break;
            RotatePattern();
        }

        m_Engine.m_wNearby &= 0x3c3f;
        m_Engine.m_byAttach = LOBYTE(m_Engine.m_wNearby);
        m_Engine.m_byKosumi = HIBYTE(m_Engine.m_wNearby);

        do
        {
            if ((m_Engine.m_byAttach == 0x26) || (m_Engine.m_byAttach == 0x19)) {
                m_Engine.m_cBaseScore += 6;
                break;
            }

            wTemp = (short)(m_Engine.m_wNearby & 0xf0ff);
            if ((wTemp == 0x2006) || (wTemp == 0x1009)) {
                if (R1U1StrStatus() != 2) m_Engine.m_cBaseScore += 6;
                break;
            }

            wTemp = (short)(m_Engine.m_wNearby & 0x0fff);
            if ((wTemp == 0x0824) || (wTemp == 0x0418)) {
                if (L1U1StrStatus() != 2) m_Engine.m_cBaseScore += 6;
                break;
            }

            if ((m_Engine.m_wNearby == 0x2804) || (m_Engine.m_wNearby == 0x1408)) {
                if ((R1U1StrStatus() != 2) && (L1U1StrStatus() != 2))
                    m_Engine.m_cBaseScore += 6;
                break;
            }

            switch (m_Engine.m_wNearby) {
                case 0x0804:
                    if (((m_Engine.m_byIKen & 0x30) == 0x20) && (L1U1StrStatus() == 0))
                        m_Engine.m_cBaseScore += 4;
                    break;
                case 0x0408:
                    if (((m_Engine.m_byIKen & 0x30) == 0x10) && (L1U1StrStatus() == 0))
                        m_Engine.m_cBaseScore += 4;
                    break;
                case 0x2004:
                    if (((m_Engine.m_byIKen & 3) == 2) && (R1U1StrStatus() == 0))
                        m_Engine.m_cBaseScore += 4;
                    break;
                case 0x1008:
                    if (((m_Engine.m_byIKen & 3) == 1) && (R1U1StrStatus() == 0))
                        m_Engine.m_cBaseScore += 4;
                    break;
            }

            switch (m_Engine.m_wNearby & 0x30ff) {
                case 6:
                    if (((m_Engine.m_byIKen & 0x30) != 0x30) && (L1StrLibs() > 2)) {
                        if ((m_Engine.m_byKeima2 & 8) != 0 || (m_Engine.m_byKeima2 & 5) == 0)
                            m_Engine.m_cBaseScore += 4;
                    }
                    break;
                case 9:
                    if (((m_Engine.m_byIKen & 0x30) != 0x30) && (L1StrLibs() > 2)) {
                        if ((m_Engine.m_byKeima2 & 4) != 0 || (m_Engine.m_byKeima2 & 0x0a) == 0)
                            m_Engine.m_cBaseScore += 4;
                    }
                    break;
            }

            switch (m_Engine.m_wNearby & 0x0cff) {
                case 0x0024:
                    if (((m_Engine.m_byIKen & 3) != 3) && (R1StrLibs() > 2)) {
                        if ((m_Engine.m_byKeima1 & 0x20) != 0 || (m_Engine.m_byKeima1 & 0x50) == 0)
                            m_Engine.m_cBaseScore += 4;
                    }
                    break;
                case 0x0018:
                    if (((m_Engine.m_byIKen & 3) != 3) && (R1StrLibs() > 2)) {
                        if ((m_Engine.m_byKeima1 & 0x10) != 0 || (m_Engine.m_byKeima1 & 0xa0) == 0)
                            m_Engine.m_cBaseScore += 4;
                    }
                    break;
            }

            if ((m_Engine.m_byAttach == 0x15) || (m_Engine.m_byAttach == 0x2a)) {
                nInfo = U1StrLibs();
                if (nInfo < 2) {
                    m_Engine.m_cBaseScore += 8;
                    break;
                }

                byTemp = (byte) R1StrLibs();
                byTemp1 = (byte) L1StrLibs();

                int max = Math.max((byTemp & 0xff), (byTemp1 & 0xff));
                if ((max < 3) && (((byTemp & 0xff) < 2) || ((byTemp1 & 0xff) < 2))) {
                    m_Engine.m_cBaseScore += 8;
                    break;
                }

                if ((byTemp == 1) || (byTemp1 == 1)) {
                    if (nInfo == 2) m_Engine.m_cBaseScore += 8;
                    break;
                }
            }

            if (((wTemp = (short)(m_Engine.m_wNearby & 0x0c0f)) == 0x0805) ||
                    (wTemp == 0x040a))
                nInfo = L1StrLibs();
            else if (((wTemp = (short)(m_Engine.m_wNearby & 0x303c)) == 0x2014) || (wTemp == 0x1028))
                nInfo = R1StrLibs();
            else break;

            if (nInfo < 2) m_Engine.m_cBaseScore += 8;
            else if (m_Engine.m_byWhereCall == 0)
                m_Engine.m_cBaseScore += 4;
        }
        while ( false );
        RETURN1:
        m_Engine.m_wIKenDKos = wIKenDKos;
        m_Engine.m_wKeima = wKeima;
        m_Engine.m_byNiKen = byNiKen;
        m_Engine.m_wNearby = wNearby;
        m_Engine.m_wOKeima = wOKeima;

        m_Engine.m_byIKen = LOBYTE(wIKenDKos);
        m_Engine.m_byDKosumi = HIBYTE(wIKenDKos);
        m_Engine.m_byKeima1 = LOBYTE(wKeima);
        m_Engine.m_byKeima2 = HIBYTE(wKeima);
        m_Engine.m_byAttach = LOBYTE(wNearby);
        m_Engine.m_byKosumi = HIBYTE(wNearby);
        return;
    }

    short R1U1StrStatus()
    {
        short	nPos;
        byte	byStr;
        short	wStatus;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[(m_Engine.m_nEntry + 2) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE) || (byStr == 0))
            return 0;

        wStatus = m_Engine.m_wStatus[byStr & 0xff];

        if (((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) < 2) || (wStatus & 8) != 0) return 2;
        if ((wStatus & 0x8000) == 0) return 1;
        return 0;
    }

    short L2D2StrStatus()
    {
        short	nPos;
        byte	byStr;
        short	wStatus;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL2D2[m_Engine.m_nEntry & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE) || (byStr == 0))
            return 0;

        wStatus = m_Engine.m_wStatus[byStr & 0xff];

        if (((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) < 2) || ((wStatus & 8) != 0)) return 2;
        if ((wStatus & 0x8000) == 0) return 1;
        return 0;
    }

    short L1U1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[(m_Engine.m_nEntry + 1) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    void LUCorner_L1White(byte[] cScore)
    {
        if ((m_Engine.m_byKeima1 & 0x10) == 0)
        {
            if ((m_Engine.m_byKeima1 & 0x40) == 0
                    || (m_Engine.m_wIKenDKos & 0x0404) == 0)
                return;
        }
        else if ((m_Engine.m_byKeima1 & 0x40) != 0)
        {
            if ((m_Engine.m_byDKosumi & 8) != 0) return;
        }
        else if ((m_Engine.m_byKeima1 & 0x80) != 0
                || (m_Engine.m_byDKosumi & 4) == 0) return;

        if (L2StrLibs() < 2) cScore[0] --;
        else cScore[0] += 3;
    }

    void LUCorner_L1Black(byte[] cScore)
    {
        if ((m_Engine.m_byKeima1 & 0x20) == 0)
        {
            if ((m_Engine.m_byKeima1 & 0x80) == 0
                    || (m_Engine.m_wIKenDKos & 0x0808) == 0)
                return;
        }
        else if ((m_Engine.m_byKeima1 & 0x80) != 0)
        {
            if ((m_Engine.m_byDKosumi & 4) != 0)
                return;
        }
        else if ((m_Engine.m_byKeima1 & 0x40) != 0
                || (m_Engine.m_byDKosumi & 8) == 0)
            return;

        if (L2StrLibs() < 2) cScore[0] --;
        else cScore[0] += 3;
    }

    void LDCorner_L1White(byte[] cScore)
    {
        if ((m_Engine.m_byKeima1 & 4) == 0) {
            if ((m_Engine.m_byKeima1 & 1) == 0 ||
                    (m_Engine.m_wIKenDKos & 0x0140) == 0)
                return;
        } else if ((m_Engine.m_byKeima1 & 1) != 0) {
            if ((m_Engine.m_byDKosumi & 2) != 0)
                return;
        } else if ((m_Engine.m_byKeima1 & 2) != 0 ||
                (m_Engine.m_byDKosumi & 1) == 0)
            return;

        if (L2StrLibs() < 2) cScore[0]--;
        else cScore[0] += 3;
    }

    short L2StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL2[m_Engine.m_nEntry & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    void LDCorner_L1Black(byte[] cScore)
    {
        if ((m_Engine.m_byKeima1 & 8) == 0)
        {
            if ((m_Engine.m_byKeima1 & 2) == 0 ||
                    (m_Engine.m_wIKenDKos & 0x0280) == 0)
                return;
        }
        else if ((m_Engine.m_byKeima1 & 2) != 0 )
        {
            if ((m_Engine.m_byDKosumi & 1) != 0)
                return;
        }
        else if ((m_Engine.m_byKeima1 & 1) != 0 ||
                (m_Engine.m_byDKosumi & 2) == 0)
            return;

        if (L2StrLibs() < 2) cScore[0] --;
        else cScore[0] += 3;
    }

    short Pattern_0102(byte[] cScore)
    {
        short	nInfo;
        byte	byTemp;

        if ((m_Engine.m_wNearby & 0xafff) != 0x0102) return 1;

        if (L1D1StrStatus() == 2)
        {
            cScore[0] -= 2;
            return 0;
        }

        nInfo = L1StrLibs();
        byTemp = (byte)(m_Engine.m_byIKen & 0xc0);
        if (byTemp != (byte)0xc0)
        {
            if ((byTemp == 0x40) || ((m_Engine.m_byKosumi & 0x40) != 0))
                cScore[0] ++;
            else if ((nInfo != 2) && ((m_Engine.m_byKeima1 & 0x0d) == 8))
            {
                if (((m_Engine.m_byIKen & 2) != 0)
                        || ((m_Engine.m_byKeima1 & 0x70) != 0))
                {
                    if (nInfo > 2) cScore[0] -= 2;
                    else cScore[0] += 3;
                }
                else if (m_Engine.m_nPosCode == 3) cScore[0] -= 2;
                else if (m_Engine.m_nPosCode < 3) return 1;
                return 0;
            }

            if ((m_Engine.m_byIKen & 0x0c) == 0x0c)
            {
                if (nInfo == 2) cScore[0] += 4;
                else if ((m_Engine.m_byIKen & 2) == 0)
                {
                    nInfo = WhoseInfluenceOnL1();
                    if (nInfo != 1) cScore[0] += 4;
                    if (nInfo < 1) return 1;
                }
                return 0;
            }
        }

        if ((m_Engine.m_wNearby & 0x1000) != 0) cScore[0] ++;
        else if (((m_Engine.m_byIKen & 4) != 0)
                || ((m_Engine.m_byKeima2 & 2) != 0)
                || ((m_Engine.m_byKeima2 & 0x0c) == 4))
            cScore[0] += 3;
        else
        {
            if ((m_Engine.m_byKeima1 & 0x40) != 0)
            {
                if ((m_Engine.m_byIKen & 2) != 0) cScore[0] ++;
                else
                {
                    cScore[0] += 3;
                    return 0;
                }
            }

            if (nInfo == 2)
            {
                LUCorner_L1Black(cScore);
            }
            else if (((m_Engine.m_byIKen & 2) == 0)
                    && ((m_Engine.m_byKeima1 & 0xa0) == 0))
                cScore[0] += 2;
        }
        return 0;
    }

    short WhoseInfluenceOnL1()
    {
        byte cWeight;
        short nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[m_Engine.m_nEntry & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;

        cWeight = m_Engine.m_cWeightBoard[nPos];
        if (cWeight < 0) return 0;
        if (cWeight == 0) return 1;
        return 2;
    }

    short L1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1[m_Engine.m_nEntry & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    short L1D1StrStatus()
    {
        short	nPos;
        byte	byStr;
        short	wStatus;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[m_Engine.m_nEntry & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE) || (byStr == 0))
            return 0;

        wStatus = m_Engine.m_wStatus[byStr & 0xff];

        if (((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) < 2) || (wStatus & 8) != 0) return 2;
        if ((wStatus & 0x8000) == 0) return 1;
        return 0;
    }

    short Pattern_0801(byte[] cScore)
    {
        short	nInfo;
        byte	byTemp;

        if ((m_Engine.m_wNearby & 0x5fff) != 0x0801) return 1;

        if (L1U1StrStatus() == 2)
        {
            cScore[0] -= 2;
            return 0;
        }

        nInfo = L1StrLibs();
        byTemp = (byte)(m_Engine.m_byIKen & 0x0c);
        if (byTemp != 0x0c)
        {
            if ((byTemp == 8) || (m_Engine.m_byKosumi & 0x20) != 0)
                cScore[0] ++;
            else if ((nInfo != 2) && ((m_Engine.m_byKeima1 & 0xb0) == 0x10))
            {
                if ((m_Engine.m_byIKen & 1) != 0 ||
                        (m_Engine.m_byKeima1 & 0x0e) != 0)
                {
                    if (nInfo > 2) cScore[0] -= 2;
                    else cScore[0] += 3;
                }
                else if (m_Engine.m_nPosCode == 3) cScore[0] -= 2;
                else if (m_Engine.m_nPosCode < 3) return 1;
                return 0;
            }

            if ((short)(m_Engine.m_byIKen & 0xff) >= 0xc0)
            {
                if (nInfo == 2) cScore[0] += 4;
                else if ((m_Engine.m_byIKen & 1) == 0)
                {
                    nInfo = WhoseInfluenceOnL1();
                    if (nInfo != 1) cScore[0] += 4;
                    if (nInfo < 1) return 1;
                }
                return 0;
            }
        }

        if ((m_Engine.m_wNearby & 0x8000) != 0) cScore[0] ++;
        else if (((m_Engine.m_byIKen & 0x80) != 0)
                || ((m_Engine.m_byKeima2 & 0x80) != 0)
                || ((m_Engine.m_byKeima2 & 0x30) == 0x20))
            cScore[0] += 3;
        else
        {
            if ((m_Engine.m_byKeima1 & 2) != 0)
            {
                if ((m_Engine.m_byIKen & 1) != 0)
                    cScore[0] ++;
                else
                {
                    cScore[0] += 3;
                    return 0;
                }
            }

            if (nInfo == 2) LDCorner_L1White(cScore);
            else if (((m_Engine.m_byIKen & 1) == 0)
                    && ((m_Engine.m_byKeima1 & 5) == 0))
                cScore[0] += 2;
        }
        return 0;
    }

    short Pattern_0402(byte[] cScore)
    {
        short	nInfo;
        byte	byTemp;

        if ((m_Engine.m_wNearby & 0xafff) != 0x0402) return 1;

        if (L1U1StrStatus() == 2)
        {
            cScore[0] -= 2;
            return 0;
        }

        nInfo = L1StrLibs();
        byTemp = (byte)(m_Engine.m_byIKen & 0x0c);
        if (byTemp != 0x0c)
        {
            if ((byTemp == 4) || (m_Engine.m_byKosumi & 0x10) != 0)
                cScore[0] ++;
            else if ((nInfo != 2) && ((m_Engine.m_byKeima1 & 0x70) == 0x20))
            {
                if ( (m_Engine.m_byIKen & 2) != 0 || (m_Engine.m_byKeima1 & 0x0d) != 0 )
                {
                    if (nInfo > 2) cScore[0] -= 2;
                    else cScore[0] += 3;
                }
                else if (m_Engine.m_nPosCode == 3) cScore[0] -= 2;
                else if (m_Engine.m_nPosCode < 3) return 1;
                return 0;
            }

            if ((m_Engine.m_byIKen & 0xff) >= 0xc0)
            {
                if (nInfo == 2) cScore[0] += 4;
                else if ( (m_Engine.m_byIKen & 2) == 0 )
                {
                    nInfo = WhoseInfluenceOnL1();
                    if (nInfo != 1 ) cScore[0] += 4;
                    if (nInfo < 1) return 1;
                }
                return 0;
            }
        }

        if ((m_Engine.m_wNearby & 0x4000) != 0)
            cScore[0] ++;
        else if (((m_Engine.m_byIKen & 0x40) != 0) ||
                ((m_Engine.m_byKeima2 & 0x40) != 0) ||
                ((m_Engine.m_byKeima2 & 0x30) == 0x10))
            cScore[0] += 3;
        else
        {
            if ( (m_Engine.m_byKeima1 & 1) != 0 )
            {
                if ((m_Engine.m_byIKen & 2) != 0)
                    cScore[0] ++;
                else
                {
                    cScore[0] += 3;
                    return 0;
                }
            }

            if (nInfo == 2) LDCorner_L1Black(cScore);
            else if ((m_Engine.m_byIKen & 2) == 0 &&
                    (m_Engine.m_byKeima1 & 0x0a) == 0)
                cScore[0] += 2;
        }
        return 0;
    }

    short L1U1StrStatus()
    {
        short	nPos;
        byte	byStr;
        short	wStatus;

        nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[(m_Engine.m_nEntry + 1) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) ||
                ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE) || (byStr == 0))
            return 0;

        wStatus = m_Engine.m_wStatus[byStr & 0xff];

        if (((m_Engine.m_byLiberties[byStr & 0xff] & 0xff) < 2) || ((wStatus & 8) != 0)) return 2;
        if ((wStatus & 0x8000) == 0) return 1;
        return 0;
    }

    byte AdjustScore(byte cScore)
    {
        short	wIKenDKos, wNearby, wTemp;

        if (cScore < -3) return cScore;

        wIKenDKos = m_Engine.m_wIKenDKos;
        wNearby = m_Engine.m_wNearby;

        for (m_Engine.m_nEntry = 4; m_Engine.m_nEntry > 0; m_Engine.m_nEntry --)
        {
            wTemp = (short)(m_Engine.m_wNearby & 0x0c0f);
            if ((wTemp == 0x0405) || (wTemp == 0x080a))
            {
                cScore -= 4;
                if (cScore < -4) cScore = -4;
            }
            else if (cScore >= -1)
            {
                if ((wTemp == 5) || (wTemp == 0x000a) ||
                        ((wTemp == 0x0401) && (((m_Engine.m_byIKen & 0x30) != 0x30) || (m_Engine.m_wNearby & 0x0280) == 0)) ||
                        ((wTemp == 0x0404) && (((m_Engine.m_byIKen & 0xff) < 0xc0) || (m_Engine.m_wNearby & 0x2020) == 0)) ||
                        ((wTemp == 0x0802) && (((m_Engine.m_byIKen & 0x30) != 0x30) || (m_Engine.m_wNearby & 0x0140) == 0)) ||
                        ((wTemp == 0x0808) && (((m_Engine.m_byIKen & 0xff) < 0xc0) || (m_Engine.m_wNearby & 0x1010) == 0)))
                {
                    cScore -= 2;
                    if (cScore < -2) cScore = -2;
                }
            }

            if (cScore < -3) break;
            RotatePart();
        }

        m_Engine.m_wIKenDKos = wIKenDKos;
        m_Engine.m_wNearby = wNearby;
        m_Engine.m_byIKen = LOBYTE(wIKenDKos);
        m_Engine.m_byDKosumi = HIBYTE(wIKenDKos);
        m_Engine.m_byAttach = LOBYTE(wNearby);
        m_Engine.m_byKosumi = HIBYTE(wNearby);
        return	cScore;
    }
    /*
        byte AdjustScore(byte cScore) {
            if (cScore < -3)
                return cScore;

            DIST distSave = m_Engine.m_Dist[0];

            int ii;
            short wTemp;
            for (ii = 0; ii < 4; ii++) {
                wTemp = (short) (m_Engine.m_Dist[0].wNearby & 0x0C0F);
                if ( (wTemp == 0x0405) || (wTemp == 0x080A)) {
                    cScore -= 4;
                    if (cScore < -4)
                        cScore = -4;
                } else if (cScore >= -1) {
                    if ( (wTemp == 5) || (wTemp == 0x0a) ||
                        ( (wTemp == 0x0401) &&
                         ( ( (m_Engine.m_Dist[0].wIkenDKos & 0x30) != 0x30) ||
                          ( (m_Engine.m_Dist[0].wNearby & 0x0280) != 0))) ||
                        ( (wTemp == 0x0404) &&
                         ( (LOBYTE(m_Engine.m_Dist[0].wIkenDKos) < 0xc0) ||
                          ( (m_Engine.m_Dist[0].wNearby & 0x2020) != 0))) ||
                        ( (wTemp == 0x0802) &&
                         ( ( (m_Engine.m_Dist[0].wIkenDKos & 0x30) != 0x30) ||
                          ( (m_Engine.m_Dist[0].wNearby & 0x0140) != 0))) ||
                        ( (wTemp == 0x0808) &&
                         ( (LOBYTE(m_Engine.m_Dist[0].wIkenDKos) < 0xc0) ||
                          ( (m_Engine.m_Dist[0].wNearby & 0x1010) != 0)))) {
                        cScore -= 2;
                        if (cScore < -2)
                            cScore = -2;
                    }
                }

                if (cScore < -3)
                    break;
                RotateR90(m_Engine.m_Dist[0], m_Engine.m_Dist[0]);
            }

            m_Engine.m_Dist[0] = distSave;
            return cScore;
        }

        void RotateR90(DIST pSrc, DIST pDst) {
            byte by1, by2;
            by1 = LOBYTE(pSrc.wNearby);
            by2 = HIBYTE(pSrc.wNearby);
            by1 = rolb2(by1);
            by2 = rolb2(by2);
            pDst.wNearby = (short) (((by2 & 0xff) << 8) | by1);

            by1 = LOBYTE(pSrc.wIkenDKos);
            by2 = HIBYTE(pSrc.wIkenDKos);
            by1 = rolb2(by1);
            by2 = rolb2(by2);
            pDst.wIkenDKos = (short) ( (by2 << 8) | by1);

            pDst.wKeima = rolw4(pSrc.wKeima);
            pDst.wOKeima = rolw4(pSrc.wOKeima);
            pDst.byNiken = rolb2(pSrc.byNiken);
        }
     */
    void ACornerEyeBase(short nSidePos1, short nSidePos2, byte byDiagStrNum)
    {
        byte byStrNberber1;
        byte byStrNberber2;
        byte cMainWeight;

        if (m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] >= 0)
            return;

        if (m_Engine.m_byBoard[m_Engine.m_nMainPos] != 0)
            return;

        byStrNberber1 = m_Engine.m_byBoard[nSidePos1];
        byStrNberber2 = m_Engine.m_byBoard[nSidePos2];

        if ((byStrNberber1 != 0) && (!IsEqualColor(byStrNberber1, byDiagStrNum)))
            return;

        if ((byStrNberber2 != 0) && (!IsEqualColor(byStrNberber2, byDiagStrNum)))
            return;

        cMainWeight = m_Engine.m_cWeightBoard[m_Engine.m_nMainPos];

        if (cMainWeight >= 2) {
            if (cMainWeight > 5)
                return;

            m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = 4;

            if (m_Engine.m_cWeightBoard[nSidePos1] == 3) {
                m_Engine.m_cWeightBoard[nSidePos1] = 5;
                return;
            }

            if (m_Engine.m_cWeightBoard[nSidePos2] == 3) {
                m_Engine.m_cWeightBoard[nSidePos2] = 5;
                return;
            }

        } else if (cMainWeight <= -2) {
            if (cMainWeight < -5)
                return;

            m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = -4;

            if (m_Engine.m_cWeightBoard[nSidePos1] == -3) {
                m_Engine.m_cWeightBoard[nSidePos1] = -5;
                return;
            }

            if (m_Engine.m_cWeightBoard[nSidePos2] == -3) {
                m_Engine.m_cWeightBoard[nSidePos2] = -5;
                return;
            }
        }
        return;
    }

    void AcornerSideWeight(short nSidePos, short nDiagPos, byte cWeight )
    {
//	short	deltaX = x1 - x2;
//	short	deltaY = y1 - y2;
        short nPos,deltaPos = (short)(nSidePos - nDiagPos);
        byte cSideWeight;

//	x1 += deltaX;
//	y1 += deltaY;
        nSidePos += deltaPos;

        if (m_Engine.m_byBoard[nSidePos] != 0)
            return;

        cSideWeight = m_Engine.m_cWeightBoard[nSidePos];

//	short	x = x1;
//	short	y = y1;
        nPos = nSidePos;

        if ( cWeight >= 0 )
        {
            if ( cSideWeight != 2 )
                return;

//		x1 += deltaX;
//		y1 += deltaY;
            nSidePos += deltaPos;

            if ( (m_Engine.m_byBoard[nSidePos] == 0) &&
                    (m_Engine.m_cWeightBoard[nSidePos] <= 0) )
                return;

//		x1 = m_byBoardX + deltaX;
//		y1 = m_byBoardY + deltaY;
            nSidePos = (short)(m_Engine.m_nMainPos + deltaPos);

            if ( (m_Engine.m_byBoard[nSidePos] == 0) &&
                    (m_Engine.m_cWeightBoard[nSidePos] <= 0) )
                return;
        }
        else
        {
            if ( cSideWeight != -2 )
                return;

//		x1 += deltaX;
//		y1 += deltaY;
            nSidePos += deltaPos;

            if ( (m_Engine.m_byBoard[nSidePos] == 0) && (m_Engine.m_cWeightBoard[nSidePos] >= 0) )
                return;

//		x1 = m_byBoardX + deltaX;
//		y1 = m_byBoardY + deltaY;
            nSidePos = (short)(m_Engine.m_nMainPos + deltaPos);

            if ( (m_Engine.m_byBoard[nSidePos] == 0) && (m_Engine.m_cWeightBoard[nSidePos] >= 0) )
                return;
        }

        m_Engine.m_cWeightBoard[nPos] = cWeight;
        m_Engine.m_cAreaBoard[nPos] = -2;
        return;
    }

    void ACornerWeight(short nSidePos1, short nSidePos2, short nDiagPos)
    {
        short nSurX,nSurY,nX,nY,nSurCount,nSurPos;
        byte cWeight;
        byte byStrNberber;

        short nColor = (short)((m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] < 0) ? 2 : 1);

        if ( m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] == 0 )
            return;

        nX = (short)(m_Engine.m_nMainPos % 20 - 1);
        nY = (short)(m_Engine.m_nMainPos / 20 - 1);

        for ( nSurCount = 0x13; nSurCount >= 0; nSurCount-- )
        {
            nSurX = (short)(nX + m_Engine.AroundPointPosTable[nSurCount * 2]);
            nSurY = (short)(nY + m_Engine.AroundPointPosTable[nSurCount * 2 +1]);

            if ( ( nSurX < 0 ) || ( nSurY < 0 ) ||
                    ( nSurX >= m_Engine.m_nBoardSize ) ||
                    ( nSurY >= m_Engine.m_nBoardSize ) )
                continue;

            nSurPos = (short)(m_Engine.m_nMainPos + m_Engine.m_cAroundTable[ nSurCount ]);

            byStrNberber = m_Engine.m_byBoard[nSurPos];

            if ( ((byStrNberber & 0xff) > 0) && (!IsEqualColor(byStrNberber, (byte)nColor)) &&
                    ( (m_Engine.m_wStatus[byStrNberber & 0xff] & 4)) == 0 )
                return;
        }

        cWeight = (byte)((nColor == 2) ? -6 : 6);
        m_Engine.m_cWeightBoard[m_Engine.m_nMainPos] = cWeight;
        m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] = -2;

        if ( m_Engine.m_byBoard[nSidePos1] == 0 )
        {
            m_Engine.m_cWeightBoard[nSidePos1] = cWeight;
            m_Engine.m_cAreaBoard[nSidePos1] = -2;
        }
        if ( m_Engine.m_byBoard[nSidePos2] == 0 )
        {
            m_Engine.m_cWeightBoard[nSidePos2] = cWeight;
            m_Engine.m_cAreaBoard[nSidePos2] = -2;
        }
        if ( m_Engine.m_byBoard[nDiagPos] == 0 )
        {
            m_Engine.m_cWeightBoard[nDiagPos] = cWeight;
            m_Engine.m_cAreaBoard[nDiagPos] = -2;
        }

        AcornerSideWeight ( nSidePos1, nDiagPos, cWeight );
        AcornerSideWeight ( nSidePos2, nDiagPos, cWeight );
    }

    void  BackupBaseDatas()
    {
        MEMCPY(m_Engine.m_cTempWeightBoard, m_Engine.m_cWeightBoard, m_Engine.m_cWeightBoard.length);
        m_Engine.m_byTempWhiteGroupCount = m_Engine.m_byWhiteGroupCount;
        m_Engine.m_byTempBlackGroupCount = m_Engine.m_byBlackGroupCount;
        m_Engine.m_nTempDifOfTerritory = m_Engine.m_nDifOfTerritory;
        m_Engine.m_wTempWhiteTSize = m_Engine.m_wWhiteTSize;
        m_Engine.m_wTempBlackTSize = m_Engine.m_wBlackTSize;
    }

    byte BiasPattern_White()
    {
        byte cScore;
        InverseColor();
        cScore = BiasPattern_Black();
        InverseColor();
        return cScore;
    }

    short CalcScoreOfManyMove()
    {
        short nScore;

        m_Engine.m_cWhiteCountChange = (short)(m_Engine.m_byTempWhiteGroupCount - m_Engine.m_byWhiteGroupCount);
        m_Engine.m_cBlackCountChange = (short)(m_Engine.m_byTempBlackGroupCount - m_Engine.m_byBlackGroupCount);
        m_Engine.m_nDeadStoneCount -= m_Engine.m_nOldDeadCount;
        m_Engine.m_nOldDeadCount = 0;

        m_Engine.m_nScoreBase = 0;
        m_Engine.m_nBlackTChange = (short)(m_Engine.m_wTempBlackTSize - m_Engine.m_wBlackTSize);
        m_Engine.m_nWhiteTChange = (short)(m_Engine.m_wTempWhiteTSize - m_Engine.m_wWhiteTSize);
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;

        nScore = GainOfNewMove(m_Engine.m_byWhereCall,m_Engine.m_nScoreBase);

        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
        return nScore;
    }

    void CaseOfStatus11()
    {
        short byStrNum;
        boolean cf;

        for(byStrNum = 1; byStrNum <= 0x7f; byStrNum++)
        {
            if((m_Engine.m_wStatus[byStrNum] & 0x808) != 0)
                continue;
            m_Engine.m_n11GrpCount = 0;

            for( m_Engine.m_nMainPosition = STARTPOS;
                 m_Engine.m_nMainPosition < ENDPOS;
                 m_Engine.m_nMainPosition ++ )
            {
                if( m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xF0 )
                    continue;

                if(((m_Engine.m_nMainPosition > 40 ) &&
                        (byStrNum == m_Engine.m_byBoard[m_Engine.m_nMainPosition - 20])) ||
                        ((m_Engine.m_nMainPosition < (ENDPOS - 20)) &&
                                (byStrNum == m_Engine.m_byBoard[m_Engine.m_nMainPosition + 20])) ||
                        ((m_Engine.m_byBoard[m_Engine.m_nMainPosition-1] != (byte)0xF0) &&
                                (byStrNum == m_Engine.m_byBoard[m_Engine.m_nMainPosition - 1])) ||
                        ((m_Engine.m_byBoard[m_Engine.m_nMainPosition+1] != (byte)0xF0) &&
                                (byStrNum == m_Engine.m_byBoard[m_Engine.m_nMainPosition + 1])))
                {
                    cf = Get11Grp(m_Engine.m_nMainPosition,(byte)byStrNum);
                    if(cf) continue;

                    // In Case The Stone of Status 11 exists in Side and
                    //  the Centre Group Number is 0 or the Color Of the Stone of Status 11 in Side
                    //   and the Centre Group equals.

                    if(m_Engine.m_byBoard[m_Engine.m_nMainPosition] != 0)
                        continue;
                    Get11Grp((short)(m_Engine.m_nMainPosition - 1),(byte)byStrNum );
                    Get11Grp((short)(m_Engine.m_nMainPosition - 20),(byte)byStrNum );
                    Get11Grp((short)(m_Engine.m_nMainPosition + 1),(byte)byStrNum );
                    Get11Grp((short)(m_Engine.m_nMainPosition + 20),(byte)byStrNum );
                }
            }
            if(--m_Engine.m_n11GrpCount <= 0)
                continue;
            do
            {
                byte byFirstGrpNum = m_Engine.m_bySurGrpOf11[m_Engine.m_n11GrpCount];
                short nTempSave  = m_Engine.m_n11GrpCount;
                m_Engine.m_n11GrpCount--;
                do
                {
                    byte bySecondGrpNum = m_Engine.m_bySurGrpOf11[m_Engine.m_n11GrpCount];
                    GroupContactStatus( byFirstGrpNum, bySecondGrpNum );

                }while(--m_Engine.m_n11GrpCount >= 0);
                m_Engine.m_n11GrpCount = nTempSave;
            }while((--m_Engine.m_n11GrpCount) > 0);
        }
    }

    short ChangeCandiScore(short nScoreCom, short nScoreHuman )
    {
        return (short)( 2 * nScoreCom + nScoreHuman );
    }

    short ConsiderD2PosCode(byte[] cScore)
    {
        short nInfo = D2PosCode();
        if (nInfo < 5)
        {
            cScore[0] -= (byte)nInfo;
            return nInfo;
        }

        if (m_Engine.m_nPosCode < 5) return 1;
        cScore[0] --;
        return nInfo;
    }

    short ConsiderU2PosCode(byte[] cScore)
    {
        short nInfo = U2PosCode();
        if (nInfo < 5)
        {
            cScore[0] -= (byte)nInfo;
            return nInfo;
        }

        if (m_Engine.m_nPosCode < 5) return 1;
        cScore[0]--;
        return nInfo;
    }

    void CornerEyeBase()
    {
//	m_byBoardY = 0;
//	m_byBoardX = 0;

        byte byDiagStrNum = m_Engine.m_byBoard[42];
        m_Engine.m_nMainPos = 21;

        if ( byDiagStrNum != 0)
            ACornerEyeBase( (short)41, (short)22, byDiagStrNum );

//	m_byBoardY = 0;
//	m_byBoardX = m_byBoardSize-1;
        m_Engine.m_nMainPos = (short)(20 * 1 + m_Engine.m_nBoardSize);

        byDiagStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPos + 19];

        if ( byDiagStrNum != 0)
            ACornerEyeBase( (short)(m_Engine.m_nMainPos + 20),
                    (short)(m_Engine.m_nMainPos - 1), byDiagStrNum );

//	m_byBoardY = m_byBoardSize-1;
//	m_byBoardX = 0;
        m_Engine.m_nMainPos = (short)(20 * m_Engine.m_nBoardSize + 1);

        byDiagStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPos - 19];

        if ( byDiagStrNum != 0)
            ACornerEyeBase( (short)(m_Engine.m_nMainPos - 20),(short)(m_Engine.m_nMainPos + 1), byDiagStrNum );

//	m_byBoardY = m_byBoardSize-1;
//	m_byBoardX = m_byBoardSize-1;
        m_Engine.m_nMainPos = (short)(20 * m_Engine.m_nBoardSize + m_Engine.m_nBoardSize);

        byDiagStrNum = m_Engine.m_byBoard[m_Engine.m_nMainPos - 21];

        if ( byDiagStrNum != 0)
            ACornerEyeBase( (short)(m_Engine.m_nMainPos - 20),(short)(m_Engine.m_nMainPos - 1), byDiagStrNum );
    }

    short D3PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL3[m_Engine.m_nEntry - 1]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }

    void FourCornerWeight()
    {
//	m_byBoardY = 1;
//	m_byBoardX = m_nBoardSize-2;
        m_Engine.m_nMainPos = (short)(20 * 2 + m_Engine.m_nBoardSize - 1);

        if ((m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] < 0) &&
                (m_Engine.m_byBoard[m_Engine.m_nMainPos] == 0))
            ACornerWeight ( (short)(m_Engine.m_nMainPos - 20),
                    (short)(m_Engine.m_nMainPos + 1),
                    (short)(m_Engine.m_nMainPos - 19) );

//	m_byBoardY = 1;
//	m_byBoardX = 1;
        m_Engine.m_nMainPos = (short)(20 * 2 + 2);

        if ((m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] < 0) &&
                (m_Engine.m_byBoard[m_Engine.m_nMainPos] == 0))
            ACornerWeight ((short)41, (short)22, (short)21);

//	m_byBoardY = m_byBoardSize -2 ;
//	m_byBoardX = 1;
        m_Engine.m_nMainPos = (short)(20 * ( m_Engine.m_nBoardSize - 1 ) + 2);

        if ((m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] < 0) && (m_Engine.m_byBoard[m_Engine.m_nMainPos] == 0))
            ACornerWeight ((short)(m_Engine.m_nMainPos + 20),(short)(m_Engine.m_nMainPos - 1),(short)(m_Engine.m_nMainPos + 19));

//	m_byBoardY = m_byBoardSize-2;
//	m_byBoardX = m_byBoardSize-2;
        m_Engine.m_nMainPos = (short)(20 * ( m_Engine.m_nBoardSize - 1 ) + m_Engine.m_nBoardSize - 1);

        if ((m_Engine.m_cAreaBoard[m_Engine.m_nMainPos] < 0) &&
                (m_Engine.m_byBoard[m_Engine.m_nMainPos] == 0))
            ACornerWeight ((short)(m_Engine.m_nMainPos + 20),
                    (short)(m_Engine.m_nMainPos + 1),
                    (short)(m_Engine.m_nMainPos + 21));
    }

    short GetIniScore()
    {
        m_Engine.m_nNewTerritory = m_Engine.m_nChangedTSize;
        m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall,m_Engine.m_nScoreBase);
        return m_Engine.m_nIniScore;
    }

    short GetPosIndexOf(short nAroundIndex)
    {
        if(nAroundIndex < 4)
        {
            nAroundIndex += m_Engine.m_nRotCount;
            if(nAroundIndex >= 4) nAroundIndex -= 4;
        }
        else if(nAroundIndex < 8)
        {
            nAroundIndex += m_Engine.m_nRotCount;
            if(nAroundIndex >= 8) nAroundIndex -= 4;
        }
        else if(nAroundIndex < 12)
        {
            nAroundIndex += m_Engine.m_nRotCount;
            if(nAroundIndex >= 12) nAroundIndex -= 4;
        }
        else if(nAroundIndex < 20)
        {
            nAroundIndex += 2 * m_Engine.m_nRotCount;
            if(nAroundIndex >= 20) nAroundIndex -= 8;
        }
        else if(nAroundIndex < 24)
        {
            nAroundIndex += m_Engine.m_nRotCount;
            if(nAroundIndex >= 24) nAroundIndex -= 4;
        }
        else if(nAroundIndex < 32)
        {
            nAroundIndex += 2 * m_Engine.m_nRotCount;
            if(nAroundIndex >= 32) nAroundIndex -= 8;
        }
        else
        {
            nAroundIndex += m_Engine.m_nRotCount;
            if(nAroundIndex >= 36) nAroundIndex -= 4;
        }
        return nAroundIndex;
    }

    void GetScOn3Wt(short[] pnScore)
    {
        short i,nScore1,nPos,nScore2,j,nCount = 0;
        short nPosTable[] = new short[4];

        if(pnScore[0] <= 0)
            return;
        m_Engine.m_nPos1 = m_Engine.m_nBoardPos;
        m_Engine.m_nPos2 = m_Engine.m_nPos3 = 0;
        m_Engine.m_nOldDeadCount = 0;
        m_Engine.m_byStrNum = 0xff;
        m_Engine.m_byTurnColor = (byte)m_Engine.m_nComStoneColor;
        for( i=0;i<4;i++)
        {
            nPos= (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]);
            if( /*(!IsInBoard(nPos)) ||*/m_Engine.m_byBoard[nPos] != 0 )
                continue;
            if(m_Engine.m_cWeightBoard[nPos] == 0)
            {
                nPosTable[nCount]= nPos;
                nCount++;
            }
        }

        nScore1 = pnScore[0];

        if(nCount < 1)
            return;
        else if(nCount == 1)
        {
            LoadData();
            m_Engine.m_nBoardPos= m_Engine.m_nPos1;
            SetStone2(m_Engine.m_byTurnColor);
            m_Engine.m_nBoardPos= m_Engine.m_nPos2;
            SetStone2((byte)(m_Engine.m_byTurnColor ^ 3));
            if((m_Engine.m_byNewLiberties & 0xff) < 2)
            {
                LoadData();
                m_Engine.m_nBoardPos= m_Engine.m_nPos1;
                return;
            }
            m_Engine.m_nBoardPos= m_Engine.m_nPos3;
            m_Engine.m_nScoreBase = OldBoardScoreCalc();
            m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
            pnScore[0] = m_Engine.m_nIniScore;
            LoadData();
            m_Engine.m_nBoardPos= m_Engine.m_nPos1;
            return;
        }

        for(i= 0;i < nCount;i++ )
        {
            nScore2 = 0;
            m_Engine.m_nPos2 = nPosTable[i];
            for(j= 0;j < nCount;j++ )
            {
                if(i==j)	continue;
                m_Engine.m_nPos3 = nPosTable[j];
                LoadData();
                m_Engine.m_nBoardPos= m_Engine.m_nPos1;
                SetStone2(m_Engine.m_byTurnColor);
                m_Engine.m_nBoardPos= m_Engine.m_nPos2;
                SetStone2((byte)(m_Engine.m_byTurnColor ^ 3));
                if((m_Engine.m_byNewLiberties & 0xff) < 2) continue;
                m_Engine.m_nBoardPos= m_Engine.m_nPos3;
                SetStone2(m_Engine.m_byTurnColor);
                if((m_Engine.m_byNewLiberties & 0xff) < 2)
                    continue;
                m_Engine.m_nScoreBase = OldBoardScoreCalc();
                m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase);
                if(m_Engine.m_nIniScore > nScore2)
                    nScore2 = m_Engine.m_nIniScore;
            }
            if(nScore2 < nScore1)
                nScore1 = nScore2;
        }
        if(nScore1 < 0)	nScore1 = 0;
        pnScore[0] = nScore1;
        LoadData();
        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
    }

    short GetScoreByThreeStep()
    {
        ReadThreeStep();
        m_Engine.m_byWhiteGroupCount = m_Engine.m_byTempWhiteGroupCount;
        m_Engine.m_byBlackGroupCount = m_Engine.m_byTempBlackGroupCount;
        m_Engine.m_nDifOfTerritory = m_Engine.m_nTempDifOfTerritory;
        m_Engine.m_wBlackTSize = m_Engine.m_wTempBlackTSize;
        m_Engine.m_wWhiteTSize = m_Engine.m_wTempWhiteTSize;
        m_Engine.m_nBoardPos= m_Engine.m_nPos3;
        m_Engine.m_nScoreBase = OldBoardScoreCalc();
        return ResultGain(m_Engine.m_byWhereCall,m_Engine.m_nScoreBase,m_Engine.m_nChangedTSize);
    }

    short GetScoreByTwoStep()
    {
        short nScore;
        byte byStrNum;

        m_Engine.m_nBoardPos = m_Engine.m_nPos2;
        m_Engine.m_nScoreBase = m_Engine.m_nDeadStoneCount;
        m_Engine.m_byTurnColor ^= 3;
        SetStone2(m_Engine.m_byTurnColor);
        OldBoardScoreCalc();

        m_Engine.m_byTurnColor^= 3;
        m_Engine.m_nBoardPos= m_Engine.m_nPos1;

        if(m_Engine.m_nChangedTSize <= 0)
        {
            m_Engine.m_nDeadStoneCount = m_Engine.m_nScoreBase;
            return m_Engine.m_nIniScore;
        }
        m_Engine.m_nChangedTSize -= m_Engine.m_nNewTerritory;
        if(m_Engine.m_nChangedTSize <= 0)
        {
            m_Engine.m_nChangedTSize *= -1;
            if(m_Engine.m_nChangedTSize >= m_Engine.m_nNewTerritory/2)
            {
                m_Engine.m_nDeadStoneCount = m_Engine.m_nScoreBase;
                return m_Engine.m_nIniScore;
            }
        }
        else
        {
            m_Engine.m_nChangedTSize *= -1;
            if(m_Engine.m_nChangedTSize <= -12)
            {
                byStrNum = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
                if((m_Engine.m_nStoneCount[byStrNum & 0xff] != 1) &&
                        ((m_Engine.m_byLiberties[byStrNum & 0xff] & 0xff) < (m_Engine.m_byTempLiberties[byStrNum & 0xff] & 0xff))&&
                        (((m_Engine.m_stGroup[m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos] & 0xff].nAliveDead+1)) > 0xe6))
                    return -2;
            }
        }
        m_Engine.m_nDeadStoneCount = (short)(m_Engine.m_nScoreBase - m_Engine.m_nDeadStoneCount);
        m_Engine.m_nPos3 = 0;

        nScore = ResultGain(m_Engine.m_byWhereCall,(short)-2,m_Engine.m_nChangedTSize);
        if(nScore < 0) return nScore;
        if(m_Engine.m_nIniScore < 0) return m_Engine.m_nIniScore;

        return (short)((m_Engine.m_nIniScore < nScore * 2) ? m_Engine.m_nIniScore : nScore * 2);
    }

    short InfluenceOnL1U1()
    {
        short nPos;

        nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[(m_Engine.m_nEntry + 1) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 1;
        return m_Engine.m_cWeightBoard[nPos];
    }

    short InfluenceOnR1U1()
    {
        short nPos;

        nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[(m_Engine.m_nEntry + 2) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 1;
        return m_Engine.m_cWeightBoard[nPos];
    }

    boolean Is2LinePat1_1()
    {
        short nR1 = GetPosIndexOf((short)2);//R1);
        short nR1Pos = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nR1]);
//	short nR1SEPs = m_byLiberties[ m_byBoard[nR1Pos] ];

        short nR1U1 = GetPosIndexOf((short)6);//R1U1);
        short nR1U1Pos = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nR1U1]);
//	short nR1U1SEPs = m_byLiberties[ m_byBoard[nR1U1Pos] ];

        short nU1 = GetPosIndexOf((short)1);//U1);
        short nU1Pos = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nU1]);
//	short nU1SEPs = m_byLiberties[ m_byBoard[nU1Pos] ];

        short nTemp,nR1D1,nR1D1Pos,nL1;
        byte byPat,byR1Str;

        if( (m_Engine.m_byLiberties[ m_Engine.m_byBoard[nR1Pos] & 0xff ] & 0xff) > 1) return false;
        if( (m_Engine.m_byLiberties[ m_Engine.m_byBoard[nR1U1Pos] & 0xff ] & 0xff) < 2) return false;
        if( (m_Engine.m_byLiberties[ m_Engine.m_byBoard[nU1Pos] & 0xff ] & 0xff) < 2) return false;

        nR1D1 = GetPosIndexOf((short)7); //R1D1);
        nR1D1Pos = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nR1D1]);

        byPat = m_Engine.m_byPat[1];

        if((byPat & 0xc0)==0)
            m_Engine.m_nPos3 = nR1D1Pos;
        else
        {
            nTemp = m_Engine.m_nBoardPos;
//		SAVE_SPOINT;
            byR1Str = m_Engine.m_byBoard[nR1Pos];
            if((byte)(byR1Str & 3) == m_Engine.m_byTurnColor)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch( true /* Pos2 = L1P */);
                m_Engine.m_nBoardPos = nTemp;
//			LOAD_SPOINT;
                return true;
            }
            short wSep[] = new short[1];
            wSep[0] = m_Engine.m_nPos3;
            GetEmptyPos(byR1Str, (short)1, wSep);
            m_Engine.m_nPos3 = wSep[0];
            wSep = null;
            m_Engine.m_nBoardPos = nTemp;
//	    LOAD_SPOINT;
        }
        nL1 = GetPosIndexOf((short)0);//L1);
        m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nL1]);

        m_Engine.m_nIniScore = ResultOfThreeMove();
        return true;
    }

    boolean Is2LinePat1_2()
    {
        short nL1U1,nL1U1Pos,nL1U1SEPs,nU1Pos,nU1,nU1SEPs;
        short nL1D1,nL1D1Pos,nR1;
        short nL1 = GetPosIndexOf( (short)0 );//L1);
        short nL1Pos = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nL1]);
        short nL1SEPs = m_Engine.m_byLiberties[ m_Engine.m_byBoard[nL1Pos] & 0xff ];
        byte byPat;
        byte byL1Str;
        short nTemp;

        if( nL1SEPs > 1) return false;

        nL1U1 = GetPosIndexOf((short)5);//L1U1);
        nL1U1Pos = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nL1U1]);
        nL1U1SEPs = (short)(m_Engine.m_byLiberties[ m_Engine.m_byBoard[nL1U1Pos] & 0xff ] & 0xff);
        if( nL1U1SEPs < 2) return false;

        nU1 = GetPosIndexOf((short)1);//U1);
        nU1Pos = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nU1]);
        nU1SEPs = (short)(m_Engine.m_byLiberties[ m_Engine.m_byBoard[nU1Pos] & 0xff ]);
        if( nU1SEPs < 2) return false;

        nL1D1 = GetPosIndexOf((short)4);//L1D1);
        nL1D1Pos= (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nL1D1]);

        byPat = m_Engine.m_byPat[1];

        if((byPat & 0xc0)==0)
            m_Engine.m_nPos3 = nL1D1Pos;
        else
        {
//	    SAVE_SPOINT;
            nTemp = m_Engine.m_nBoardPos;
            byL1Str = m_Engine.m_byBoard[nL1Pos];
            if((byte)(byL1Str & 3) == m_Engine.m_byTurnColor)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch( false /* Pos2 = L1P */);
                m_Engine.m_nBoardPos = nTemp;
//		LOAD_SPOINT;
                return true;
            }
            short wSEP[] = new short[1];
            wSEP[0] = m_Engine.m_nPos3;
            GetEmptyPos(byL1Str, (short)1, wSEP);
            m_Engine.m_nPos3 = wSEP[0];
            wSEP = null;
            m_Engine.m_nBoardPos = nTemp;
//	    LOAD_SPOINT;
        }
        nR1 = GetPosIndexOf((short)2);//R1);
        m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nR1]);

        m_Engine.m_nIniScore = ResultOfThreeMove();
        return true;
    }

    boolean Is2LinePat2(short nUpSEP)
    {
        short nL1U1 = GetPosIndexOf((short) 5); //L1U1);
        short nL1U1SEP = (short)(m_Engine.m_byLiberties[m_Engine.m_byBoard[m_Engine.m_nBoardPos +
                m_Engine.m_cAroundTable[nL1U1]] & 0xff] & 0xff);
        short wTemp = 0;

        if ((nL1U1SEP < 2) || (nUpSEP < 2))return true;

        if (m_Engine.m_byTurnColor == WHITE) {
            if ((nL1U1SEP == 2) && ((m_Engine.m_byPat[3] & 0x10) == 0)) {
                if ((m_Engine.m_byPat[2] & 1) == 0)
                    m_Engine.m_nIniScore = PS_MINI;
                return true;
            }
            if ((m_Engine.m_byPat[2] & 1) != 0)return true;
            if (nUpSEP >= 3) {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[2] & 0x30) == 0x30) {
                if (IsConerPat())
                    m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[4] & 5) != 0)return true;
            if ((m_Engine.m_byPat[4] & 0x0a) != 0) {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[2] & 8) == 0)return true;
            if ((m_Engine.m_byPat[8] & 0x20) != 0) {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[8] & 0x10) != 0)return true;

            //MEMCPY(&wTemp, ((BYTE*)m_byPat+6), 2);
            wTemp = MAKEWORD((m_Engine.m_byPat[6] & 0xff), (m_Engine.m_byPat[7] & 0xff));

            if ((wTemp & 0x100) != 0)return true;
        } else {
            if ((nL1U1SEP == 2) && ((m_Engine.m_byPat[3] & 0x20) == 0)) {
                if ((m_Engine.m_byPat[2] & 2) == 0)
                    m_Engine.m_nIniScore = PS_MINI;
                return true;
            }
            if ((m_Engine.m_byPat[2] & 2) != 0)return true;
            if (nUpSEP >= 3) {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[2] & 0x30) == 0x30) {
                if (IsConerPat())
                    m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[4] & 0x0a) != 0)return true;
            if ((m_Engine.m_byPat[4] & 5) != 0) {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[2] & 4) == 0)return true;
            if ((m_Engine.m_byPat[8] & 0x10) != 0) {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if ((m_Engine.m_byPat[8] & 0x20) != 0)return true;

            //memcpy(&wTemp, ((BYTE*)m_byPat+6), sizeof(WORD));
            wTemp = MAKEWORD((m_Engine.m_byPat[6] & 0xff), (m_Engine.m_byPat[7] & 0xff));

            if ((wTemp & 0x200) != 0) return true;
        }
        m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
        return true;
    }

    boolean IsConerPat()
    {
        byte byPat;
        if(m_Engine.m_byTurnColor == WHITE)
        {
            byPat = (byte)(m_Engine.m_byPat[4] & 2);
            if( (m_Engine.m_byPat[3] & 0x80) != 0)
            {
                if( byPat == 0)
                    byPat = (byte)(m_Engine.m_byPat[5] & 8);
            }
            else
            {
                if( byPat != 0)
                    byPat = (byte)(m_Engine.m_byPat[5] & 8);
            }
        }
        else
        {
            byPat = (byte)(m_Engine.m_byPat[4] & 1);
            if( (m_Engine.m_byPat[3] & 0x40) != 0)
            {
                if( byPat == 0)
                    byPat = (byte)(m_Engine.m_byPat[5] & 4);
            }
            else
            {
                if( byPat != 0)
                    byPat = (byte)(m_Engine.m_byPat[5] & 4);
            }
        }
        return (byPat != 0);
    }

    short ResultOfThreeMove()
    {
        short nDeadCount = m_Engine.m_nDeadStoneCount;
        ReadThreeStep();
        m_Engine.m_byNewStringNumber = (byte)0xff;
        OldBoardScoreCalc();
        m_Engine.m_nChangedTSize += m_Engine.m_nNewTerritory;
        m_Engine.m_nDeadStoneCount += nDeadCount;
        return CalcScoreOfManyMove();
    }

    short ResultOfTwoLineSearch(boolean bIsLeftPoint)
    {
        short nD1 = GetPosIndexOf((short)3);//D1);
        short nPos;	//L2 Point
        short nDPos,nL1,nR1;
        boolean bDeadFlag;

        m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nD1]);

        if(bIsLeftPoint)
        {
            nL1 = GetPosIndexOf((short)0);//L1);
            nDPos = m_Engine.m_cAroundTable[nL1];
        }
        else
        {
            nR1 = GetPosIndexOf((short)2);//R1);
            nDPos = m_Engine.m_cAroundTable[nR1];
        }
        m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + nDPos);
        nPos = (short)(m_Engine.m_nBoardPos + 2 * nDPos);

        //For Simul Strings : 87-6-29
        if( m_Engine.m_byWhereCall != (byte)0xff )
            return ResultOfThreeMove();
        //For Simul Strings

        if( ((byte)(m_Engine.m_byBoard[nPos] & 1)+1) == m_Engine.m_byTurnColor)
            return ResultOfThreeMove();

        m_Engine.m_nBoardPos= m_Engine.m_nPos2;
        SetStone2((byte)(m_Engine.m_byTurnColor ^ 3));
        m_Engine.m_nBoardPos= (short)(m_Engine.m_nPos3 + nDPos);
        SetStone2(m_Engine.m_byTurnColor);
        m_Engine.m_nBoardPos= (short)(m_Engine.m_nPos1 - nDPos);
        SetStone2((byte)(m_Engine.m_byTurnColor ^ 3));
        m_Engine.m_nBoardPos= m_Engine.m_nPos3;
        SetStone2(m_Engine.m_byTurnColor);

        bDeadFlag = false;
        if((m_Engine.m_byNewLiberties & 0xff) >= 2)
        {
            if(SimulInSecondOnOutCall(m_Engine.m_byNewStringNumber) > 0)
                bDeadFlag = true;
        }
        else
            bDeadFlag = true;
        if(!bDeadFlag)
            m_Engine.m_nPos3+= nDPos;

        m_Engine.m_nScoreBase = m_Engine.m_nDeadStoneCount;
        LoadData();
        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
        SetStone2(m_Engine.m_byTurnColor);
        ReadThreeStep();
        m_Engine.m_nDeadStoneCount += m_Engine.m_nScoreBase;
        OldBoardScoreCalc();
        return CalcScoreOfManyMove();
    }


    short ReadThreeStep()
    {
        short nStr;

        m_Engine.m_nBoardPos= m_Engine.m_nPos2;
        SetStone2((byte)(m_Engine.m_byTurnColor^3));
        m_Engine.m_nOldDeadCount = m_Engine.m_nDeadStoneCount;
        ExpressTempArea();

        m_Engine.m_nBoardPos= m_Engine.m_nPos3;
        if(SetStone1(m_Engine.m_byTurnColor) == IS_OK )
        {
            SetStone2(m_Engine.m_byTurnColor);
            nStr = (short)(m_Engine.m_byNewStringNumber & 0xff);
            m_Engine.m_byNewStringNumber = (byte)0xff;
            return nStr;
        }
        return -1;
    }

    boolean Is2LinePat3(short nUpSEP)
    {
        short wPat;// = *((WORD*)m_byPat);

        short nU1,nU1SEP,nL1U1,nL1U1SEP;
        short wTemp = 0;

        //memcpy(&wPat, ((BYTE*)m_byPat), sizeof(WORD));
        wPat = MAKEWORD((m_Engine.m_byPat[0] & 0xff), (m_Engine.m_byPat[1] & 0xff));

        if(m_Engine.m_byTurnColor == WHITE)
        {
            if(wPat != 0x1808)
            {
                if(wPat != 0x1008)	return false;
                if((m_Engine.m_byPat[2] & 1) != 0)	return true;
            }
        }
        else
        {
            if(wPat != 2404)
            {
                if(wPat != 0x2004)	return false;
                if((m_Engine.m_byPat[2] & 2) != 0)	return true;
            }
        }
        nU1 = GetPosIndexOf((short)1);//U1);
        nU1SEP = (short)(m_Engine.m_byLiberties[m_Engine.m_byBoard[m_Engine.m_nBoardPos+
                m_Engine.m_cAroundTable[nU1]] & 0xff] & 0xff);

        nL1U1 = GetPosIndexOf((short)5);//L1U1);
        nL1U1SEP = (short)(m_Engine.m_byLiberties[m_Engine.m_byBoard[m_Engine.m_nBoardPos+
                m_Engine.m_cAroundTable[nL1U1]] & 0xff] & 0xff);
        if((nL1U1SEP < 2) || (nUpSEP < 2)) return true;

        if(m_Engine.m_byTurnColor == WHITE)
        {
            if((nL1U1SEP == 2) && ((m_Engine.m_byPat[3] & 4) == 0))
            {
                if( (m_Engine.m_byPat[2] & 0x10) == 0)
                    m_Engine.m_nIniScore = PS_MINI;
                return true;
            }
            if( (m_Engine.m_byPat[2] & 0x10) != 0)	return true;
            if( nUpSEP >= 3)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(true);
                return true;
            }
            if( (m_Engine.m_byPat[2] & 3) == 3)
            {
                if(IsConerPat())
                    m_Engine.m_nIniScore = ResultOfTwoLineSearch(true);
                return true;
            }
            if( (m_Engine.m_byPat[3] & 0x50) != 0)	return true;
            if( (m_Engine.m_byPat[3] & 0xa0)!= 0)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(true);
                return true;
            }
            if( (m_Engine.m_byPat[2] & 8) == 0)	return true;
            if( (m_Engine.m_byPat[8] & 8) != 0)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(true);
                return true;
            }
            if( (m_Engine.m_byPat[8] & 4) != 0)	return true;
            //memcpy(&wTemp, ((BYTE*)m_byPat+6), sizeof(WORD));
            wTemp = MAKEWORD((m_Engine.m_byPat[6] & 0xff), (m_Engine.m_byPat[7] & 0xff));
            if( (wTemp & 0x0040) != 0)	return true;
        }
        else
        {
            if((nL1U1SEP == 2) && ((m_Engine.m_byPat[3] & 8) == 0))
            {
                if((m_Engine.m_byPat[2] & 0x20) == 0)
                    m_Engine.m_nIniScore = PS_MINI;
                return true;
            }
            if((m_Engine.m_byPat[2] & 0x20) != 0)	return true;
            if( nUpSEP >= 3)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(true);
                return true;
            }
            if( (m_Engine.m_byPat[2] & 3) == 3)
            {
                if(IsConerPat())
                    m_Engine.m_nIniScore = ResultOfTwoLineSearch(true);
                return true;
            }
            if( (m_Engine.m_byPat[3] & 0xa0) != 0)	return true;
            if( (m_Engine.m_byPat[3] & 0x50)!= 0)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(true);
                return true;
            }
            if( (m_Engine.m_byPat[2] & 4) == 0)	return true;
            if( (m_Engine.m_byPat[8] & 4) != 0)
            {
                m_Engine.m_nIniScore = ResultOfTwoLineSearch(false);
                return true;
            }
            if( (m_Engine.m_byPat[8] & 8) != 0)	return true;
            //memcpy(&wTemp, ((BYTE*)m_byPat+6), sizeof(WORD));
            wTemp = MAKEWORD((m_Engine.m_byPat[6] & 0xff), (m_Engine.m_byPat[7] & 0xff));
            if( (wTemp & 0x0080) != 0)	return true;
        }
        return true;
    }

    boolean IsAtariPat()
    {
        byte byFirstStrNum = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
        //OUTPUT("m_byBoard", m_Engine.m_byBoard, 20);
        //HJ_Debug>>
//        System.out.println("m_nBoardPos = " + m_Engine.m_nBoardPos);
//        System.out.println("byFirstStrNum = " + byFirstStrNum);
        //<<
        short wFirstStatus = m_Engine.m_wStatus[byFirstStrNum & 0xff];
        short nStones = 0;
        short nDStr = 0,i,nSavePos;
        byte byMyStr;
        short nScore1, nScore2;
        short nPatScore;
        short nPosTable[] = new short[8];
        short  nPosCount;

        short nScore;
        short nWeight;
        boolean bFlag;
        short nTemp;
        short nScore3;

        if((m_Engine.m_byWhereCall & 0xff) < 2)
            return false;
        for(i=0;i<m_Engine.m_nDCount;i++)
        {
            if(m_Engine.m_byDifferLiberties[i] == 1)
            {
                if(m_Engine.m_nStoneCount[m_Engine.m_byDifferBuf[i] & 0xff] > nStones)
                {
                    nStones = m_Engine.m_nStoneCount[m_Engine.m_byDifferBuf[i] & 0xff];
                    nDStr = (short)(m_Engine.m_byDifferBuf[i] & 0xff);
                }
            };
        }
        if(nStones == 0) return false;

        short wSEP[] = new short[1];
        wSEP[0] = m_Engine.m_nPos2;
        GetEmptyPos(nDStr, (short)1, wSEP);
        m_Engine.m_nPos2 = wSEP[0];
        wSEP = null;
        m_Engine.m_nOldDeadCount = m_Engine.m_nDeadStoneCount;
        m_Engine.m_nBoardPos= m_Engine.m_nPos2;

//	if(m_byTurnColor == m_nComStoneColor)
//		KillString(nDStr);

        SetStone1(m_Engine.m_byTurnColor);

        if((m_Engine.m_byTurnColor == m_Engine.m_nComStoneColor) && (m_Engine.m_nPaePos != 0))
        {
            nSavePos= m_Engine.m_nBoardPos;
            for(m_Engine.m_nBoardPos= 21;m_Engine.m_nBoardPos < 400;m_Engine.m_nBoardPos++ )
            {
                byMyStr = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
                //HJ_Debug>>
                //System.out.println("byMyStr = " + byMyStr);
                //<<
                if((byMyStr == 0) || (byMyStr == (byte)0xf0)) continue;
                if(IsSameString((byte)nDStr) && (m_Engine.m_wStatus[byMyStr & 0xff] == 0x0101))
                {
                    if(m_Engine.m_nIniScore > 0)
                    {
                        m_Engine.m_nIniScore = (short)Math.max(1, m_Engine.m_nIniScore / 2);
                    }
                    m_Engine.m_nBoardPos= nSavePos;
                    return true;
                }
            }
            m_Engine.m_nBoardPos= nSavePos;
        }

        if(m_Engine.m_byTurnColor == m_Engine.m_nComStoneColor)
            KillString((byte)nDStr);
        SetStone2(m_Engine.m_byTurnColor);

        m_Engine.m_byNewStringNumber = (byte)0xff;

        m_Engine.m_wBlackTSize = m_Engine.m_wTempBlackTSize;
        m_Engine.m_wWhiteTSize = m_Engine.m_wTempWhiteTSize;
        m_Engine.m_nDifOfTerritory = m_Engine.m_nTempDifOfTerritory;
        m_Engine.m_byBlackGroupCount = m_Engine.m_byTempBlackGroupCount;
        m_Engine.m_byWhiteGroupCount = m_Engine.m_byTempWhiteGroupCount;

        m_Engine.m_nDeadStoneCount += m_Engine.m_nOldDeadCount;
        m_Engine.m_nOldDeadCount = 0;

        nScore1 = OldBoardScoreCalc();
        if(nScore1 >= 0)
            nScore1 = ResultGain(m_Engine.m_byWhereCall,m_Engine.m_nScoreBase,m_Engine.m_nChangedTSize);

        LoadData();
        m_Engine.m_wStatus[byFirstStrNum & 0xff] = wFirstStatus;
        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
        SetStone2(m_Engine.m_byTurnColor);

        if(SimulInSecondOnOutCall((byte)nDStr) <= 0)
        {
            m_Engine.m_nBoardPos= m_Engine.m_nPos1;
            return false;
        }
        if(SimulInFirstOnOutCall((byte)nDStr) <= 0)
        {
            m_Engine.m_nBoardPos= m_Engine.m_nPos1;
            return false;
        }
        m_Engine.m_nPos2= m_Engine.m_nBoardPos;

        ReadTwoStep(byFirstStrNum);
        if(m_Engine.m_nIniScore >= 0)
        {
            nScore2 = OldBoardScoreCalc();
            if(nScore2 > 0)
            {
                m_Engine.m_nPos3 = 0;
                nScore2 = ResultGain(m_Engine.m_byWhereCall, (short)0, m_Engine.m_nChangedTSize);
                if(nScore2 < 0) m_Engine.m_nIniScore = nScore2;
                else
                {
                    if(nScore2 * 2 > nScore1)
                    {
                        m_Engine.m_nIniScore = nScore1;
                        if(m_Engine.m_nIniScore < 0)
                            m_Engine.m_nIniScore = 0;
                        return true;
                    }
                    if(nScore1 > nScore2 * 2)
                        nScore2 *= 2;
                    if((m_Engine.m_nIniScore >= 0) && (m_Engine.m_nIniScore > nScore2))
                        m_Engine.m_nIniScore = nScore2;
                }
            }
            else m_Engine.m_nIniScore = nScore2;
        }

        nPatScore = -100;
        nPosCount = 0;

        for(i=0;i<8;i++)
        {
            m_Engine.m_nBoardPos= (short)(m_Engine.m_nPos1 + m_Engine.m_cAroundTable[i]);
            if( /*IsInBoard(m_nBoardPos)) ||*/
                    (m_Engine.m_byBoard[m_Engine.m_nBoardPos] != 0) ||
                            (m_Engine.m_nBoardPos == m_Engine.m_nPaePos))	continue;
            SetStone1(m_Engine.m_byTurnColor);
            if(((m_Engine.m_byNewLiberties & 0xff) < 1) ||
                    (m_Engine.m_byNewLiberties == 1) && (m_Engine.m_nDeadStoneCount == 0)) continue;

            nScore = 0;//PatternScore(m_byTurnColor);
            nWeight = m_Engine.m_cWeightBoard[m_Engine.m_nBoardPos];

            nWeight = (short)(( nWeight > 0 )? nWeight:-nWeight);

            switch(nWeight)
            {
                case 0: break;
                case 2: break;
                case 1: nScore -= 3;	break;
                case 9: nScore -= 3;	break;
                case 3: nScore--;		break;
                default: nScore -= nWeight -3;
            }
            if(nScore < nPatScore)	continue;
            if(nScore > nPatScore)
            {
                nPatScore = nScore;
                nPosCount = 0;
            }
            nPosTable[nPosCount]= m_Engine.m_nBoardPos;
            nPosCount++;
        }

        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
        m_Engine.m_nScoreBase = (m_Engine.m_nIniScore < 0)? 0:m_Engine.m_nIniScore;

        if(nPosCount == 0)
        {
            if(m_Engine.m_nIniScore > 0)
                m_Engine.m_nIniScore = (short)(m_Engine.m_nIniScore * 4 / 3);
            return true;
        }

        bFlag = false;
        while(nPosCount > 0)
        {
            nPosCount--;
            ReadTwoStep(byFirstStrNum);
            m_Engine.m_nPos3 = nPosTable[nPosCount];
            nTemp = m_Engine.m_nDeadStoneCount;
            m_Engine.m_nBoardPos= m_Engine.m_nPos3;
            SetStone2(m_Engine.m_byTurnColor);
//Add 1998.11.8 - Begin
            if((m_Engine.m_byPosBoard[m_Engine.m_nPos1] == 2) &&
                    (m_Engine.m_nDeadStoneCount == 0))
                m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xff] = (short)0xff01;
//Add 1998.11.8 - End
            m_Engine.m_nDeadStoneCount += nTemp;
            m_Engine.m_nOldDeadCount = 0;
            m_Engine.m_byNewStringNumber = (byte)0xff;
            ExpressTempArea();
//		m_nBoardPos= m_nPos1;
            nScore3 = OldBoardScoreCalc();
            if(nScore3 < 0)	continue;
            bFlag = true;
            nScore3 = ResultGain(m_Engine.m_byWhereCall, m_Engine.m_nScoreBase, m_Engine.m_nChangedTSize);
            if( (nScore3 < m_Engine.m_nScoreBase) || (nScore3 < 0) )
                continue;
            nScore3 = (short)((nScore3 - m_Engine.m_nScoreBase + 1)/2 + m_Engine.m_nScoreBase);
            if(nScore3 >= nScore1)
            {
                m_Engine.m_nIniScore = nScore1;
                return true;
            }
            m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore > nScore3) ?
                    m_Engine.m_nIniScore : nScore3);
        }

        if(!bFlag)
        {
            if(m_Engine.m_nIniScore >= 0)
                m_Engine.m_nIniScore = -1;
            return true;
        }
        if((m_Engine.m_nIniScore >= 0) &&
                (m_Engine.m_nIniScore < nScore1) && (nScore1 > 0) &&
                (m_Engine.m_byTurnColor == m_Engine.m_nComStoneColor) &&
                ( nScore1 - m_Engine.m_nIniScore > 0x25))
            m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + nScore1) / 2);

        return true;
    }

    void ReadTwoStep(short nStr)
    {
        short wStatus;
        //H.Joon-2007/04/19 Temp>>
        if ( nStr >= MAX_STRINGCOUNT )
            return;
        //<<
        wStatus = m_Engine.m_wStatus[nStr];
        LoadData();
        m_Engine.m_wStatus[nStr] = wStatus;

        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
        SetStone2(m_Engine.m_byTurnColor);
        m_Engine.m_nOldDeadCount = m_Engine.m_nDeadStoneCount;

        m_Engine.m_nBoardPos= m_Engine.m_nPos2;
        SetStone2((byte)(m_Engine.m_byTurnColor^3));
        m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xff] = (short)0xff01;

        m_Engine.m_byNewStringNumber = (byte)0xff;
        m_Engine.m_nDeadStoneCount = (short)(m_Engine.m_nOldDeadCount - m_Engine.m_nDeadStoneCount);
        m_Engine.m_nOldDeadCount = 0;
        ExpressTempArea();

        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
    }

    boolean IsKeimaPat()
    {
        short i;
        short wPat;

        PatternDataOf(m_Engine.m_byPat, m_Engine.m_nBoardPos);
        m_Engine.m_nRotCount=0;
        for( i= 0;i < 4;i++ )
        {
            //memcpy(&wPat, ((BYTE*)m_byPat), sizeof(WORD));
            wPat = MAKEWORD((m_Engine.m_byPat[0] & 0xff), (m_Engine.m_byPat[1] & 0xff));
//		wPat = *((WORD*)m_byPat);
            if( m_Engine.m_byTurnColor == WHITE)
            {
                if((wPat & 0x4fff) == 0x0608)
                    return IsKeimaType1(true);
                if((wPat & 0xf1ff) == 0x9008)
                    return IsKeimaType1(false);
                if((wPat & 0x0f0f) == 0x0208)
                    return IsKeimaType2(true);
                if((wPat & 0xf03c) == 0x8008)
                    return IsKeimaType2(false);
            }
            else
            {
                if((wPat & 0x4fff) == 0x0904)
                    return IsKeimaType1(true);
                if((wPat & 0xf1ff) == 0x6004)
                    return IsKeimaType1(false);
                if((wPat & 0x0f0f) == 0x0104)
                    return IsKeimaType2(true);
                if((wPat & 0xf03c) == 0x4004)
                    return IsKeimaType2(false);
            }
            RotateLocalPattern();
        }
        return false;
    }

    boolean RotateLocalPattern()
    {
        short wTemp = 0;
        m_Engine.m_byPat[0] = rorb2(m_Engine.m_byPat[0]);
        m_Engine.m_byPat[1] = rorb2(m_Engine.m_byPat[1]);
        m_Engine.m_byPat[2] = rorb2(m_Engine.m_byPat[2]);

        //memcpy(&wTemp, ((BYTE*)m_Engine.m_byPat+3), sizeof(WORD));
        wTemp = MAKEWORD((m_Engine.m_byPat[3] & 0xff), (m_Engine.m_byPat[4] & 0xff));
        wTemp = rorw4(wTemp);
        //memcpy( ((BYTE*)m_byPat+3),&wTemp, sizeof(WORD));
        m_Engine.m_byPat[3] = LOBYTE(wTemp);
        m_Engine.m_byPat[4] = HIBYTE(wTemp);
//	*((WORD*)(m_byPat+3)) = rorw4(*((WORD*)(m_byPat+3)));
        m_Engine.m_byPat[5] = rorb2(m_Engine.m_byPat[5]);
        //memcpy(&wTemp, ((BYTE*)m_byPat+6), sizeof(WORD));
        wTemp = MAKEWORD((m_Engine.m_byPat[6] & 0xff), (m_Engine.m_byPat[7] & 0xff));
        wTemp = rorw4(wTemp);
        //memcpy( ((BYTE*)m_byPat+6),&wTemp, sizeof(WORD));
        m_Engine.m_byPat[6] = LOBYTE(wTemp);
        m_Engine.m_byPat[7] = HIBYTE(wTemp);
//	*((WORD*)(m_byPat+6)) = rorw4(*((WORD*)(m_byPat+6)));
        m_Engine.m_byPat[8] = rorb2(m_Engine.m_byPat[8]);
        m_Engine.m_nRotCount++;
//	ASSERT(m_nRotCount <= 4);
        return true;
    }

    boolean IsOneLinePat()
    {
        short i,nPatType,nL1,nR1;
        short nScore,nScore1,nScore2, temp;
//	WORD w;
        short wTemp;

        switch(m_Engine.m_byPosBoard[m_Engine.m_nBoardPos])
        {
//	case 0:	return TRUE;
            case 1:	return true;
//	case 1: break;
            case 2: break;
            default: return false;
        }

        PatternDataOf(m_Engine.m_byPat, m_Engine.m_nBoardPos);
        m_Engine.m_nRotCount=0;
        for( i=0;i<4;i++ )
        {
            if((m_Engine.m_byPat[0] & 0xff) >= 0xc0) break;
            RotateLocalPattern();
        }
//	ASSERT(i<4);
//	w = *((WORD*)(m_byPat + 3));
        //memcpy(&wTemp, ((BYTE*)m_byPat+3), sizeof(WORD));
        wTemp = MAKEWORD((m_Engine.m_byPat[3] & 0xff), (m_Engine.m_byPat[4] & 0xff));
        wTemp = rolw2(wTemp);
        //memcpy( ((BYTE*)m_byPat+3),&wTemp, sizeof(WORD));
        m_Engine.m_byPat[3] = LOBYTE(wTemp);
        m_Engine.m_byPat[4] = HIBYTE(wTemp);
//	*((WORD*)(m_byPat + 3)) = w;

        nPatType = 0;
        if(m_Engine.m_byTurnColor == WHITE)
        {
            if( ((m_Engine.m_byPat[0] & 3)== 0) && ((m_Engine.m_byPat[1] & 8)!= 0) &&
                    ((m_Engine.m_byPat[3] & 0x20)==0) && ((m_Engine.m_byPat[3] & 0x10)!=0))
                nPatType |= 1;
            if( ((m_Engine.m_byPat[0] & 0x30)==0) && ((m_Engine.m_byPat[1] & 0x20)!=0) &&
                    ((m_Engine.m_byPat[4] & 8) == 0) && ((m_Engine.m_byPat[4] & 4) != 0))
                nPatType |= 2;
        }
        else
        {
            if( ((m_Engine.m_byPat[0] & 3)== 0) && ((m_Engine.m_byPat[1] & 4)!= 0) &&
                    ((m_Engine.m_byPat[3] & 0x10)==0) && ((m_Engine.m_byPat[3] & 0x20)!=0))
                nPatType |= 1;
            if( ((m_Engine.m_byPat[0] & 0x30)==0) && ((m_Engine.m_byPat[1] & 0x10)!=0) &&
                    ((m_Engine.m_byPat[4] & 4) == 0) && ((m_Engine.m_byPat[4] & 8) != 0))
                nPatType |= 2;
        }
        if(nPatType == 0)	return false;

        nL1 = GetPosIndexOf((short)0);//L1);
        nR1 = GetPosIndexOf((short)2);//R1);
        if(nPatType < 3)
        {
            if(nPatType == 1)
                m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nL1]);
            else
                m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nR1]);

            nScore = GetScoreByTwoStep();
            if(nScore > m_Engine.m_nIniScore)
                m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + nScore) / 2);
            else
                m_Engine.m_nIniScore = nScore;
            return true;
        }
        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] &= 0xffffffef;
        m_Engine.m_nPos2= (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nL1]);
        m_Engine.m_nPos3= (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nR1]);
        nScore1 = GetScoreByThreeStep();

        LoadData();
        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
        SetStone2(m_Engine.m_byTurnColor);
        ExpressTempArea();
        temp = m_Engine.m_nPos2; m_Engine.m_nPos2 = m_Engine.m_nPos3;	m_Engine.m_nPos3 = temp;
        nScore2 = GetScoreByThreeStep();

        m_Engine.m_nIniScore = (nScore1 < nScore2) ? nScore1 : nScore2;
        return true;
    }

    boolean IsToviPat1()
    {
        PatternDataOf(m_Engine.m_byPat, m_Engine.m_nBoardPos);
        if( m_Engine.m_byTurnColor == WHITE)
        {
            if(((m_Engine.m_byPat[0] & 3)==0) &&
                    ((m_Engine.m_byPat[2] & 1)!=0) &&
                    ((m_Engine.m_byPat[2] & 2)==0) &&
                    ((m_Engine.m_byPat[1] & 0x0a)==0x0a) )
                m_Engine.m_nBoardPos--;
            else if(((m_Engine.m_byPat[0] & 0x0c)==0) &&
                    ((m_Engine.m_byPat[2] & 4)!=0) &&
                    ((m_Engine.m_byPat[2] & 8)==0) &&
                    ((m_Engine.m_byPat[1] & 0x28)==0x28) )
                m_Engine.m_nBoardPos-= 20;
            else if(((m_Engine.m_byPat[0] & 0x30)==0) &&
                    ((m_Engine.m_byPat[2] & 0x10)!=0) &&
                    ((m_Engine.m_byPat[2] & 0x20)==0) &&
                    ((m_Engine.m_byPat[1] & 0xa0)==0xa0) )
                m_Engine.m_nBoardPos++;
            else if(((m_Engine.m_byPat[0] & 0xc0)==0) &&
                    ((m_Engine.m_byPat[2] & 0x40)!=0) &&
                    ((m_Engine.m_byPat[2] & 0x80)==0) &&
                    ((m_Engine.m_byPat[1] & 0x82)==0x82) )
                m_Engine.m_nBoardPos+= 20;
            else return false;
        }
        else
        {
            if(((m_Engine.m_byPat[0] & 3)==0) && ((m_Engine.m_byPat[2] & 2)!=0) && ((m_Engine.m_byPat[2] & 1)==0) && ((m_Engine.m_byPat[1] & 5)==5) )
                m_Engine.m_nBoardPos--;
            else if(((m_Engine.m_byPat[0] & 0x0c)==0) && ((m_Engine.m_byPat[2] & 8)!=0) && ((m_Engine.m_byPat[2] & 4)==0) && ((m_Engine.m_byPat[1] & 0x14)==0x14) )
                m_Engine.m_nBoardPos -= 20;
            else if(((m_Engine.m_byPat[0] & 0x30)==0) && ((m_Engine.m_byPat[2] & 0x20)!=0) && ((m_Engine.m_byPat[2] & 0x10)==0) && ((m_Engine.m_byPat[1] & 0x50)==0x50) )
                m_Engine.m_nBoardPos++;
            else if(((m_Engine.m_byPat[0] & 0xc0)==0) && ((m_Engine.m_byPat[2] & 0x80)!=0) && ((m_Engine.m_byPat[2] & 0x40)==0) && ((m_Engine.m_byPat[1] & 0x41)==0x41) )
                m_Engine.m_nBoardPos+= 20;
            else return false;
        }
        m_Engine.m_nPos2 = m_Engine.m_nBoardPos;
        m_Engine.m_nIniScore = GetScoreByTwoStep();
        return true;
    }

    boolean IsToviPat2()
    {
        short wPat;

        PatternDataOf(m_Engine.m_byPat, m_Engine.m_nBoardPos);
        //memcpy(&wPat, ((BYTE*)m_byPat), sizeof(WORD));
        wPat = MAKEWORD((m_Engine.m_byPat[0] & 0xff), (m_Engine.m_byPat[1] & 0xff));
//	wPat = *((WORD*)m_byPat);
        if(m_Engine.m_byTurnColor == WHITE)
        {
            //Pat 1 type
            if( ((wPat & 0x0f03)==0x0a00) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-21] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+19]))
                m_Engine.m_nBoardPos--;
            else if( ((wPat & 0x3c0c)==0x2800) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-21] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-19]))
                m_Engine.m_nBoardPos-= 20;
            else if( ((wPat & 0xf030)==0xa000) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-19] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+21]))
                m_Engine.m_nBoardPos++;
            else if( ((wPat & 0xc3c0)==0x8200) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+19] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+21]))
                m_Engine.m_nBoardPos+= 20;
                //Pat 2 type
            else if( ((wPat & 0x03c3)==0x0082) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-1] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+20]))
                m_Engine.m_nBoardPos+= 19;
            else if( ((wPat & 0x0c0f)==0x000a) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-1] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-20]))
                m_Engine.m_nBoardPos-= 21;
            else if( ((wPat & 0x303c)==0x0028) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-20] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+1]))
                m_Engine.m_nBoardPos-= 19;
            else if( ((wPat & 0xc0f0)==0x00a0) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+1] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+20]))
                m_Engine.m_nBoardPos+= 21;
            else return false;
        }
        else
        {
            //Pat 1 type
            if( ((wPat & 0x0f03)==0x0500) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-21] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+19]))
                m_Engine.m_nBoardPos--;
            else if( ((wPat & 0x3c0c)==0x1400) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-21] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-19]))
                m_Engine.m_nBoardPos-= 20;
            else if( ((wPat & 0xf030)==0x5000) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-19] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+21]))
                m_Engine.m_nBoardPos++;
            else if( ((wPat & 0xc3c0)==0x4100) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+19] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+21]))
                m_Engine.m_nBoardPos+= 20;
                //Pat 2 type
            else if( ((wPat & 0x03c3)==0x0041) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-1] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+20]))
                m_Engine.m_nBoardPos+= 19;
            else if( ((wPat & 0x0c0f)==0x0005) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-1] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-20]))
                m_Engine.m_nBoardPos-= 21;
            else if( ((wPat & 0x303c)==0x0014) &&
                    (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos-20] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+1]))
                m_Engine.m_nBoardPos-= 19;
            else if( ((wPat & 0xc0f0)==0x0050) && (m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+1] != m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos+20]))
                m_Engine.m_nBoardPos+= 21;
            else return false;
        }
        m_Engine.m_nPos2 = m_Engine.m_nBoardPos;
        m_Engine.m_nIniScore = GetScoreByTwoStep();
        return true;
    }

    boolean IsTukePat()
    {
        byte byL1Str,byR1Str;
        short nScore1,nPos,nScore2;
        byte byU1Str;
        byte byD1Str;
        short wTemp = 0;

        if(m_Engine.m_nDeadStoneCount == 1)	return false;
        PatternDataOf(m_Engine.m_byPat, m_Engine.m_nBoardPos);

        do
        {
            if (m_Engine.m_byTurnColor == WHITE) {
                if ((m_Engine.m_byPat[0] & 0xcc) != 0) {
                    if ((m_Engine.m_byPat[0] & 0x33) != 0 ||
                            ((m_Engine.m_byPat[0] & 0xcc) != 0x88))
                        return false;
                    byU1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos - 20];
                    byD1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos + 20];
                    if ((m_Engine.m_byLiberties[byU1Str & 0xff] == 1) ||
                            (m_Engine.m_byLiberties[byD1Str & 0xff] == 1))
                        return false;
                    if ((m_Engine.m_byPat[1] & 5) == 0) {
                        m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos - 1);
                        m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos + 1);
                        //memcpy( & wTemp, ((BYTE * ) m_byPat), sizeof(WORD));
                        wTemp = MAKEWORD((m_Engine.m_byPat[0] & 0xff),
                                (m_Engine.m_byPat[1] & 0xff));
                        if ((wTemp & 0x5000) == 0) break;
                    } else {
                        if ((m_Engine.m_byPat[1] & 0x50) != 0) return false;
                        m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + 1);
                        m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos - 1);
                    }
                    m_Engine.m_nIniScore = ReadTukePat();
                    return true;
                }
                if ((m_Engine.m_byPat[0] & 0x33) != 0x22)return false;
                byL1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos - 1];
                byR1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos + 1];
                if ((m_Engine.m_byLiberties[byL1Str & 0xff] == 1) ||
                        (m_Engine.m_byLiberties[byR1Str & 0xff] == 1))
                    return false;
                if ((m_Engine.m_byPat[1] & 0x14) == 0) {
                    m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos - 20);
                    m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos + 20);
                    //memcpy( & wTemp, ((BYTE * ) m_byPat), sizeof(WORD));
                    wTemp = MAKEWORD((m_Engine.m_byPat[0] & 0xff),
                            (m_Engine.m_byPat[1] & 0xff));
                    if ((wTemp & 0x4100) == 0) break;
                } else {
                    if ((m_Engine.m_byPat[1] & 0x41) != 0) return false;
                    m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + 20);
                    m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos - 20);
                }
            } else {
                if ((m_Engine.m_byPat[0] & 0xcc) != 0) {
                    if ((m_Engine.m_byPat[0] & 0x33) != 0 ||
                            ((m_Engine.m_byPat[0] & 0xcc) != 0x44))
                        return false;
                    byU1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos - 20];
                    byD1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos + 20];
                    if ((m_Engine.m_byLiberties[byU1Str & 0xff] == 1) ||
                            (m_Engine.m_byLiberties[byD1Str & 0xff] == 1))
                        return false;
                    if ((m_Engine.m_byPat[1] & 0x0a) == 0) {
                        m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos - 1);
                        m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos + 1);
                        //memcpy(&wTemp, ((BYTE*)m_byPat), sizeof(WORD));
                        wTemp = MAKEWORD((m_Engine.m_byPat[0] & 0xff),
                                (m_Engine.m_byPat[1] & 0xff));
                        if ((wTemp & 0xa000) == 0) break;
                    } else {
                        if ((m_Engine.m_byPat[1] & 0xa0) != 0)
                            return false;
                        m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + 1);
                        m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos - 1);
                    }
                    m_Engine.m_nIniScore = ReadTukePat();
                    return true;
                }
                if ((m_Engine.m_byPat[0] & 0x33) != 0x11)return false;
                byL1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos - 1];
                byR1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos + 1];
                if ((m_Engine.m_byLiberties[byL1Str & 0xff] == 1) ||
                        (m_Engine.m_byLiberties[byR1Str & 0xff] == 1))
                    return false;
                if ((m_Engine.m_byPat[1] & 0x28) == 0) {
                    m_Engine.m_nPos2 = (short) (m_Engine.m_nBoardPos - 20);
                    m_Engine.m_nPos3 = (short) (m_Engine.m_nBoardPos + 20);
                    //memcpy(&wTemp, ((BYTE*)m_byPat), sizeof(WORD));
                    wTemp = MAKEWORD((m_Engine.m_byPat[0] & 0xff), (m_Engine.m_byPat[1] & 0xff));
                    if ((wTemp & 0x8200) == 0) break;
                } else {
                    if ((m_Engine.m_byPat[1] & 0x82) != 0)return false;
                    m_Engine.m_nPos2 = (short) (m_Engine.m_nBoardPos + 20);
                    m_Engine.m_nPos3 = (short) (m_Engine.m_nBoardPos - 20);
                }
            }
            m_Engine.m_nIniScore = ReadTukePat();
            return true;
        }
        while ( false );
        $STEP4:

        nScore1 = ReadTukePat();

        LoadData();
        m_Engine.m_nBoardPos= m_Engine.m_nPos1;
        SetStone2(m_Engine.m_byTurnColor);
        nPos = m_Engine.m_nPos2; m_Engine.m_nPos2 = m_Engine.m_nPos3; m_Engine.m_nPos3 = nPos;
        m_Engine.m_nScoreBase = m_Engine.m_nDeadStoneCount;
        ReadThreeStep();
        m_Engine.m_nDeadStoneCount += m_Engine.m_nScoreBase;
        m_Engine.m_byNewStringNumber = (byte)0xff;
        OldBoardScoreCalc();
        nScore2 = CalcScoreOfManyMove();

        m_Engine.m_nIniScore = (short)Math.min(nScore1, nScore2);
        return true;
    }

    boolean IsTwoLinePat()
    {
        short i,nStr;
        byte byNum;
        short nStrNum,nPos,nEnemyStr,nGroupNum,nU1,nU1SEPs;
        byte byPatForAdd[] = new byte[9];
        short wPat8;
        byte byPatTest0,byPatTest1;
        short wTemp;

//	if(m_byWhereCall < 2) return FALSE;
//	if(m_byPosBoard[m_nBoardPos] != 2) return FALSE;
        if(m_Engine.m_byPosBoard[m_Engine.m_nBoardPos] != 3) return false;
        PatternDataOf(m_Engine.m_byPat, m_Engine.m_nBoardPos);

        MEMCPY( byPatForAdd, m_Engine.m_byLocalPattern[m_Engine.m_nBoardPos], byPatForAdd.length );
        m_Engine.m_nRotCount=0;
        for( i=0;i<4;i++)
        {
            if((m_Engine.m_byPat[2] & 0xff) >= 0xc0) break;
            RotateLocalPattern();

            //by Jong 2004/8/6

            //memcpy(&wTemp, ((BYTE*)byPatForAdd + 3), sizeof(WORD));
            wTemp = MAKEWORD((byPatForAdd[3] & 0xff), (byPatForAdd[4] & 0xff));

            wTemp = rorw4(wTemp);

            byPatForAdd[3] = LOBYTE(wTemp);
            byPatForAdd[4] = HIBYTE(wTemp);

            //memcpy(&wTemp, ((BYTE*)byPatForAdd + 6), sizeof(WORD));
            wTemp = MAKEWORD((byPatForAdd[6] & 0xff), (byPatForAdd[7] & 0xff));

            wTemp = rorw4(wTemp);

            //memcpy( ((BYTE*)byPatForAdd + 6), &wTemp, sizeof(WORD));
            byPatForAdd[6] = LOBYTE(wTemp);
            byPatForAdd[7] = HIBYTE(wTemp);
        }

//	wPat8 = *((WORD*)m_byPat);
        //memcpy(&wPat8, ((BYTE*)m_byPat), sizeof(WORD));
        wPat8 = MAKEWORD((m_Engine.m_byPat[0] & 0xff), (m_Engine.m_byPat[1] & 0xff));
        byPatTest0=(byte)((LOBYTE(wPat8) | HIBYTE(wPat8)) & 0xcf);
        byPatTest1=(byte)((LOBYTE(wPat8) | (rorb2(HIBYTE(wPat8)))) & 0xfc);

        if(m_Engine.m_byTurnColor == WHITE)
        {
            if((m_Engine.m_nComStoneColor == WHITE) && (m_Engine.m_byWhereCall == (byte)0xff) &&
                    (m_Engine.m_stGroup[m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos]].nAliveDead == 0))
            {
//1998-8-8 Begin
                if((wPat8 & 0xc3ff) == 0x0201)
                {
                    i = GetPosIndexOf( (short)4 );//L1D1);
                    nStr = (short)(m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if((m_Engine.m_nStoneCount[nStr] == 1) && (m_Engine.m_byLiberties[nStr] == 2) &&
                            (m_Engine.m_byTempLiberties[m_Engine.m_byNewStringNumber & 0xff] == 2))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                        return true;
                    }
                }
                if((wPat8 & 0xc3ff) == 0x8010)
                {
                    i = GetPosIndexOf( (short)7 );//R1D1);
                    nStr = (short)(m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if((m_Engine.m_nStoneCount[nStr] == 1) && (m_Engine.m_byLiberties[nStr] == 2) &&
                            (m_Engine.m_byTempLiberties[m_Engine.m_byNewStringNumber & 0xff] == 2))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                        return true;
                    }
                }
//1998-8-8 End
                if( ((wPat8 & 0xcbfb)==0x0020) && (byPatTest0 == 0x04) && (m_Engine.m_nIniScore > 0))
                {
                    i = GetPosIndexOf( (short)2 );//R1);
                    byNum = m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]];
                    if(m_Engine.m_stGroup[byNum].nAliveDead == 0)
                    {
                        m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                        m_Engine.m_nIniScore *= 15;
                        return true;
                    }
                }
                if( ((wPat8 & 0xe3fb)==0x0002) && (byPatTest1==0x04) && (m_Engine.m_nIniScore > 0))
                {
                    i = GetPosIndexOf( (short)0 );//L1);
                    byNum = m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]];
                    if(m_Engine.m_stGroup[byNum & 0xff].nAliveDead == 0)
                    {
                        m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                        m_Engine.m_nIniScore *= 15;
                        return true;
                    }
                }
                if( ((wPat8 & 0xf3ff) == 0x9050 ) && (m_Engine.m_nIniScore >= -1) )
                {
                    m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                    m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                    return true;
                }
                if( ((wPat8 & 0xcfff) == 0x0641 ) && (m_Engine.m_nIniScore >= -1) )
                {
                    m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                    m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                    return true;
                }
//2 - Line
                if( ((wPat8 & 0x0fc7) == 0) && ((m_Engine.m_byPat[2] & 0xc3) == 0xc1) && ((byPatForAdd[3] & 3) == 2))
                {
                    i = GetPosIndexOf((short)12);
                    nStrNum= (short)(m_Engine.m_byBoard[ m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if( ((m_Engine.m_wStatus[nStrNum] & 0x8000) != 0) && ((m_Engine.m_byLiberties[nStrNum] & 0xff) >= 3))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
                if( ((wPat8 & 0xf0f4) == 0) && ((m_Engine.m_byPat[2] & 0xf0) == 0xd0) && ((byPatForAdd[4] & 0xfc) == 0xf8))
                {
                    i = GetPosIndexOf((short)17);
                    nStrNum = (short)(m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if( ((m_Engine.m_wStatus[nStrNum] & 0x8000) != 0) &&
                            ((m_Engine.m_byLiberties[nStrNum] & 0xff) >= 3))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
//2Line --------------
// -------------------

                if( (wPat8 & 0xf3ff) ==0x1201)
                {
                    i = GetPosIndexOf((short)4);
                    nPos= (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]);
                    nEnemyStr = (short)(m_Engine.m_byBoard[nPos] & 0xff);
                    nGroupNum = (short)(m_Engine.m_byGroupBoard[nPos] & 0xff);

                    if(((m_Engine.m_byLiberties[nEnemyStr] & 0xff) > 2) &&
                            (m_Engine.m_stGroup[nGroupNum].nAliveDead == 0))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
                if( (wPat8 & 0xcfff) ==0x8410)
                {
                    i = GetPosIndexOf((short)7);
                    nPos= (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]);
                    nEnemyStr = (short)(m_Engine.m_byBoard[nPos] & 0xff);
                    nGroupNum = (short)(m_Engine.m_byGroupBoard[nPos] & 0xff);
                    if(((m_Engine.m_byLiberties[nEnemyStr] & 0xff) > 2) &&
                            (m_Engine.m_stGroup[nGroupNum].nAliveDead == 0))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
//2Line --------------
// -------------------
            }
            if((wPat8 & 0x33ff) == 0x1028)	return Is2LinePat1_1();
            if((wPat8 & 0xccff) == 0x040a)	return Is2LinePat1_2();
            if((m_Engine.m_byPat[2] & 0x11) == 0x11)	return false;
            if(wPat8 == 0x2408) return Is2LinePat2((short)3);
            if(wPat8 != 0x0408) return Is2LinePat3((short)3);
            if((m_Engine.m_byPat[2] & 0x10) != 0)
            {
                m_Engine.m_nIniScore = GetIniScore();
                return true;
            }
        }
        else
        {
            if((m_Engine.m_byTurnColor==m_Engine.m_nComStoneColor)  &&
                    (m_Engine.m_byWhereCall == (byte)0xff) &&
                    (m_Engine.m_stGroup[m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos] & 0xff].nAliveDead == 0))
            {
//1998-8-8 Begin
                if((wPat8 & 0xc3ff) == 0x0102)
                {
                    i = GetPosIndexOf((short)4);//L1D1);
                    nStr = (short)(m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if((m_Engine.m_nStoneCount[nStr] == 1) &&
                            (m_Engine.m_byLiberties[nStr] == 2) &&
                            (m_Engine.m_byTempLiberties[m_Engine.m_byNewStringNumber & 0xff] == 2))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                        return true;
                    }
                }
                if((wPat8 & 0xc3ff) == 0x4020)
                {
                    i = GetPosIndexOf((short)7);//R1D1);
                    nStr = (short)(m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if((m_Engine.m_nStoneCount[nStr] == 1) &&
                            (m_Engine.m_byLiberties[nStr] == 2) &&
                            (m_Engine.m_byTempLiberties[m_Engine.m_byNewStringNumber & 0xff] == 2))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                        return true;
                    }
                }
//1998-8-8 End
                if( ((wPat8 & 0xc7f7)==0x0010) && (byPatTest0==0x08) && (m_Engine.m_nIniScore > 0))
                {
                    i = GetPosIndexOf( (short)2 );//R1);
                    byNum = m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]];
                    if(m_Engine.m_stGroup[byNum & 0xff].nAliveDead == 0)
                    {
                        m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                        m_Engine.m_nIniScore *= 15;
                        return true;
                    }
                }
                if( ((wPat8 & 0xd3f7)==0x0001) && (byPatTest1==0x08) && (m_Engine.m_nIniScore > 0))
                {
                    i = GetPosIndexOf( (short)0 );//L1);
                    byNum = m_Engine.m_byGroupBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]];
                    if(m_Engine.m_stGroup[byNum & 0xff].nAliveDead == 0)
                    {
                        m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                        m_Engine.m_nIniScore *= 15;
                        return true;
                    }
                }
                if( ((wPat8 & 0xf3ff) == 0x60a0 ) && (m_Engine.m_nIniScore >= -1) )
                {
                    m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                    m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                    return true;
                }
                if( ((wPat8 & 0xcfff) == 0x0982 ) && (m_Engine.m_nIniScore >= -1) )
                {
                    m_Engine.g_byTwoPat |= m_Engine.m_byTurnColor;
                    m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 2) * 15);
                    return true;
                }
//2 - Line
                if( ((wPat8 & 0x0fcb) == 0) &&
                        ((m_Engine.m_byPat[2] & 0xc3) == 0xc2) &&
                        ((byPatForAdd[3] & 3) == 1))
                {
                    i = GetPosIndexOf((short)12);
                    nStrNum= (short)(m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if( ((m_Engine.m_wStatus[nStrNum] & 0x8000) != 0) &&
                            ((m_Engine.m_byLiberties[nStrNum] & 0xff) >= 3))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
                if( ((wPat8 & 0xf0f8) == 0) &&
                        ((m_Engine.m_byPat[2] & 0xf0) == 0xe0) &&
                        ((byPatForAdd[4] & 0xfc) == 0xf4))
                {
                    i = GetPosIndexOf((short)17);
                    nStrNum= (short)(m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]] & 0xff);
                    if( ((m_Engine.m_wStatus[nStrNum] & 0x8000) != 0) &&
                            ((m_Engine.m_byLiberties[nStrNum] & 0xff) >= 3))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
//2Line --------------
// -------------------
                if( (wPat8 & 0xf3ff) == 0x2102)
                {
                    i = GetPosIndexOf((short)4);
                    nPos= (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]);
                    nEnemyStr = (short)(m_Engine.m_byBoard[nPos] & 0xff);
                    nGroupNum = (short)(m_Engine.m_byGroupBoard[nPos] & 0xff);
                    if(((m_Engine.m_byLiberties[nEnemyStr] & 0xff) > 2) &&
                            (m_Engine.m_stGroup[nGroupNum].nAliveDead == 0))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
                if( (wPat8 & 0xcfff) == 0x4820)
                {
                    i = GetPosIndexOf((short)7);
                    nPos= (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]);
                    nEnemyStr = (short)(m_Engine.m_byBoard[nPos] & 0xff);
                    nGroupNum = (short)(m_Engine.m_byGroupBoard[nPos] & 0xff);

                    if(((m_Engine.m_byLiberties[nEnemyStr] & 0xff) > 2) &&
                            (m_Engine.m_stGroup[nGroupNum].nAliveDead == 0))
                    {
                        m_Engine.m_nIniScore = (short)((m_Engine.m_nIniScore + 1) * 20);
                        return true;
                    }
                }
            }
            if((wPat8 & 0x33ff) == 0x2014)	return Is2LinePat1_1();
            if((wPat8 & 0xccff) == 0x0805)	return Is2LinePat1_2();
            if((m_Engine.m_byPat[2] & 0x22) == 0x22)	return false;
            if(wPat8 == 0x1804)	return Is2LinePat2((short)3);
            if(wPat8 != 0x0804)	return Is2LinePat3((short)3);
            if((m_Engine.m_byPat[2] & 0x20) != 0)
            {
                m_Engine.m_nIniScore = GetIniScore();
                return true;
            }
        }
        nU1 = GetPosIndexOf( (short)1 );//U1);
        nU1SEPs = (short)(m_Engine.m_byLiberties[ m_Engine.m_byBoard[m_Engine.m_nBoardPos +
                m_Engine.m_cAroundTable[nU1]] & 0xff ] & 0xff);
        return Is2LinePat2(nU1SEPs);
    }

    short L2D1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL1U2[m_Engine.m_nEntry - 1]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    short L2D2PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL2D2[m_Engine.m_nEntry & 3]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }

    short L2U1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundR1U2[m_Engine.m_nEntry - 1]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    short L2U2PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL2D2[(m_Engine.m_nEntry + 1) & 3]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }

    short PatternScore(short nColor)
    {
        m_Engine.m_cBaseScore = 0;
        return (byte)(LOBYTE(GetScorePattern( nColor)));
    }

    short R1D1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[m_Engine.m_nEntry - 1]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    short R1U1StrLibs()
    {
        short	nPos;
        byte	byStr;

        nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL1D1[(m_Engine.m_nEntry + 2) & 3]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || ((byStr = m_Engine.m_byBoard[nPos]) == INITVALUE))
            return 0xff;

        if (byStr == 0) return 0;
        return	(short)(m_Engine.m_byLiberties[byStr & 0xff] & 0xff);
    }

    short R2PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL2[(m_Engine.m_nEntry + 2) & 3]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }

    short RecalcScore(short nColor,short nScore)
    {
        return nScore;
//	if(m_byPosBoard[m_nBoardPos] < 4)
//		return nScore;
    /*
            m_nPos1 = m_nBoardPos;
            m_nPos2 = m_nPos3 = 0;
            m_nOldDeadCount = 0;
            m_byStrNum = 0xff;
            m_byTurnColor = (BYTE)nColor;

            SetStone2(m_byTurnColor);
            if(m_byNewLiberties < 1)	return nScore;
            if((m_nDeadStoneCount > 0) ||
                    (m_nStoneCount[m_byNewStringNumber] != 1))
                    return nScore;

            m_byStrNum = m_byNewStringNumber;
            m_nScoreBase = OldBoardScoreCalc(11111);
            short nScore1 = GainOfNewMove(m_byWhereCall,m_nScoreBase);
            m_nIniScore = nScore1 * 2;
            signed char cWeightBoard[420];
            memset(cWeightBoard, -1, sizeof(cWeightBoard));
            short nPos;
            for(short i= 0;i < 36;i++ )
            {
                    nPos= m_nBoardPos + m_cAroundTable[i];
//		if(!IsInBoard(nPos))
                    if( m_byBoard[nPos] == INITVALUE )
                            continue;
                    if(m_byBoard[nPos])
                    {
                            cWeightBoard[nPos] = 0;
                            continue;
                    }
                    short w = abs(m_cWeightBoard[nPos]);
                    if(w > 2)
                            cWeightBoard[nPos] = -2;
                    cWeightBoard[nPos] = w + 1;
            }

            short nCount = 0;
            short nScore3 = 0;
            short nCount2 = 0;
            short nScore2, j;
            for(i= 0;i < 36;i++ )
            {
                    nPos= m_nBoardPos + m_cAroundTable[i];
//		if(!IsInBoard(nPos))
                    if(m_byBoard[nPos] == INITVALUE )
                            continue;
                    signed char w0 = cWeightBoard[nPos];
                    if(w0 < 1)	continue;
                    LoadData();
                    m_nBoardPos= m_nPos1;
                    SetStone2(m_byTurnColor);

                    m_nPos2= m_nBoardPos= nPos;
                    SetStone2(m_byTurnColor ^ 3);
                    if(m_byNewLiberties < 3)
                            goto $NEXT;
                    m_nScoreBase = OldBoardScoreCalc(11111);
                    nScore2 = GainOfNewMove(m_byWhereCall, m_nScoreBase);
                    if(nScore2 > 0)	goto $NEXT;

                    short nWeightBoard1[420];
                    memcpy(nWeightBoard1, m_cWeightBoard, sizeof(nWeightBoard1));
                    for(j=0;j<36;j++)
                    {
                            m_nBoardPos= m_nPos1;
                            short nPos1 = m_nBoardPos + m_cAroundTable[j];
//			if(!IsInBoard(nPos1))
//			if(m_byBoard[nPos1] == INITVALUE )
//				continue;
                            if(m_byBoard[nPos1])	continue;
                            if(abs(nWeightBoard1[nPos1]) > 2)	continue;
                            LoadData();
                            SetStone2(m_byTurnColor);
                            m_nBoardPos= m_nPos2;
                            SetStone2(m_byTurnColor ^ 3);
                            m_nBoardPos= nPos1;
                            SetStone2(m_byTurnColor);
                            if(m_byNewLiberties < 3) continue;
                            m_nScoreBase = OldBoardScoreCalc(11111);
                            short nTempScore = GainOfNewMove(m_byWhereCall, m_nScoreBase);
                            if(nTempScore > nScore3)
                                    nScore3 = nTempScore;
                            nCount2++;
                            if(nCount2 > 4)
                                    break;
                    }
    $NEXT:
                    if(nScore2 <= -2)
                            nScore3 /= 2;
                    else if(nScore2 >= 0)
                            nScore3 = nScore3 * 5 / 4;
                    if(nScore3 < m_nIniScore)
                            m_nIniScore = nScore3;
                    m_nBoardPos= m_nPos1;
                    nCount++;
                    if(nCount > 4) break;
            }
            LoadData();
            m_nBoardPos= m_nPos1;
            nScore = m_nIniScore;

            return nScore;
            */
    }

    short ReadTukePat()
    {
        short nDeadCount = m_Engine.m_nDeadStoneCount;

        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        m_Engine.m_lBitBoard[m_Engine.m_nBoardPos] |= 0x0c;
        ReadThreeStep();
        m_Engine.m_byNewStringNumber = (byte)0xff;
        OldBoardScoreCalc();
        m_Engine.m_nChangedTSize += m_Engine.m_nNewTerritory;
        m_Engine.m_nDeadStoneCount += nDeadCount;

        m_Engine.m_cWhiteCountChange = (short)(m_Engine.m_byTempWhiteGroupCount - m_Engine.m_byWhiteGroupCount);
        m_Engine.m_cBlackCountChange = (short)(m_Engine.m_byTempBlackGroupCount - m_Engine.m_byBlackGroupCount);
        m_Engine.m_nScoreBase = 0;
        m_Engine.m_nDeadStoneCount -= m_Engine.m_nOldDeadCount;
        m_Engine.m_nOldDeadCount = 0;
        m_Engine.m_nBlackTChange = (short)(m_Engine.m_wTempBlackTSize - m_Engine.m_wBlackTSize);
        m_Engine.m_nWhiteTChange = (short)(m_Engine.m_wTempWhiteTSize - m_Engine.m_wWhiteTSize);
        m_Engine.m_nNewTerritory = (short)m_Engine.m_nChangedTSize;

        m_Engine.m_nIniScore = GainOfNewMove(m_Engine.m_byWhereCall,m_Engine.m_nScoreBase);
        return m_Engine.m_nIniScore;
    }

    void  RestorBaseDatas()
    {
        MEMCPY(m_Engine.m_cWeightBoard, m_Engine.m_cTempWeightBoard, m_Engine.m_cWeightBoard.length);
        m_Engine.m_byWhiteGroupCount = m_Engine.m_byTempWhiteGroupCount;
        m_Engine.m_byBlackGroupCount = m_Engine.m_byTempBlackGroupCount;
        m_Engine.m_nDifOfTerritory = m_Engine.m_nTempDifOfTerritory;
        m_Engine.m_wWhiteTSize = m_Engine.m_wTempWhiteTSize;
        m_Engine.m_wBlackTSize = m_Engine.m_wTempBlackTSize;
    }


    void RotatePart()
    {
        m_Engine.m_byAttach = rolb2(m_Engine.m_byAttach);
        m_Engine.m_byKosumi = rolb2(m_Engine.m_byKosumi);
        m_Engine.m_wNearby = MAKEWORD((m_Engine.m_byAttach & 0xff), (m_Engine.m_byKosumi & 0xff));

        m_Engine.m_byIKen = rolb2(m_Engine.m_byIKen);
        m_Engine.m_wIKenDKos = MAKEWORD((m_Engine.m_byIKen & 0xff), (m_Engine.m_byDKosumi & 0xff));
    }

    void SaveMainData()
    {
        MEMCPY( m_Engine.m_cTempWeightBoard,m_Engine.m_cWeightBoard,m_Engine.m_cWeightBoard.length );
        MEMCPY( m_Engine.m_byTempBoard,m_Engine.m_byBoard,m_Engine.m_byBoard.length );
        MEMCPY( m_Engine.m_byTempLiberties,m_Engine.m_byLiberties,m_Engine.m_byLiberties.length );
        MEMCPY( m_Engine.m_nTempStoneCount,m_Engine.m_nStoneCount,m_Engine.m_nStoneCount.length );
        MEMCPY( m_Engine.m_wTempStatus,m_Engine.m_wStatus,m_Engine.m_wStatus.length );
        m_Engine.m_byTempWhiteGroupCount = m_Engine.m_byWhiteGroupCount;
        m_Engine.m_byTempBlackGroupCount = m_Engine.m_byBlackGroupCount;
        m_Engine.m_nTempDifOfTerritory = m_Engine.m_nDifOfTerritory;
        m_Engine.m_wTempWhiteTSize = m_Engine.m_wWhiteTSize;
        m_Engine.m_wTempBlackTSize = m_Engine.m_wBlackTSize;
        m_Engine.m_nTempPaePos = m_Engine.m_nPaePos;
        m_Engine.m_nTempDeadStoneCount = m_Engine.m_nDeadStoneCount;
    }

    long Step()
    {
//	if( m_listStone.GetCount(11111) == m_nStoneCounter )
//		return 0;// Pak
        m_Engine.m_bIsInControl = true;

//	POSITION	position = m_listStone.FindIndex( m_nStoneCounter );
//	CPadukStone *pStone = m_listStone.GetAt( position );
//	assert( pStone != NULL );
//	WORD wPos = MAKEWORD( (BYTE)(pStone->m_pointPos.y), (BYTE)(pStone->m_pointPos.x) );
//	PlaceStone( wPos, pStone->m_nStoneColor );

        m_Engine.m_bIsInControl = false;
        m_Engine.m_bReStart = true;

        return 0;
    }

    boolean  SurSearch(short byColor, byte cSubWeight, short[] pnFlagOfOppoStone )
    {
        int nSideNum, nSidePos;
        byte bySideStrNum;

        pnFlagOfOppoStone[0] = 0;

        //HJ_Debug>>
        //System.out.println("m_nBoardPos = " + m_Engine.m_nBoardPos);
        //<<
        for (nSideNum = 0; nSideNum < 4; nSideNum++) {
            //New Addition: m_nBoardPos --> m_nMainPos
            nSidePos = m_Engine.m_nMainPos + m_Engine.m_cAroundTable[nSideNum];
            if (m_Engine.byStandardBoard[nSidePos] != 0)
                continue;

            bySideStrNum = m_Engine.m_byBoard[nSidePos];

            if (bySideStrNum == 0) {
                pnFlagOfOppoStone[0] = 1;
                if (m_Engine.m_cWeightBoard[nSidePos] == cSubWeight)
                    return true;
                //upversion
                continue;
            }

            if ((m_Engine.m_byLiberties[bySideStrNum & 0xff] & 0xff) == 0x01)
                continue;

            if (((bySideStrNum ^ byColor) & 1) != 0)
                pnFlagOfOppoStone[0] = 1;
        }
        return false;
    }

    void  TempAreaOR(short nSurPos )
    {
        if( m_Engine.byStandardBoard[nSurPos] != 0 )
            return;

        if ( m_Engine.m_byBoard[nSurPos] == 0 )
            m_Engine.m_cAreaBoard[nSurPos] |= 0xFE ;
        return;
    }

    short SeeItself(short nGrp)
    {
        short	wPoint;
        short	nScore = 0;
        short	nOppScore, nMyScore, nTempScore;

        for (wPoint = STARTPOS; wPoint < ENDPOS; wPoint ++)
        {
            if ((m_Engine.m_byBoard[wPoint] != 0) ||
                    (StnOfGrpInNeighbor(wPoint, nGrp) == 0))
                continue;
            if (((nOppScore = m_Engine.m_nOppScoreBoard[wPoint]) <= -2) ||
                    ((nMyScore = m_Engine.m_nMyScoreBoard[wPoint]) >= 0))
                continue;
            nTempScore = (short)((nOppScore + 2) * 2 + (nMyScore + 2));
            if (nTempScore <= nScore) continue;
            nScore = nTempScore;
        }
        return nScore;
    }

    short StnOfGrpInNeighbor(short wPoint, short nGrp)
    {
        if ((m_Engine.m_byBoard[wPoint - 1] != 0) &&
                ((m_Engine.m_byTempGroupBoard[wPoint - 1] & 0xff) == nGrp))
            return 1;
        if ((m_Engine.m_byBoard[wPoint + 1] != 0) &&
                ((m_Engine.m_byTempGroupBoard[wPoint + 1] & 0xff) == nGrp))
            return 1;
        if ((m_Engine.m_byBoard[wPoint - 20] != 0) &&
                ((m_Engine.m_byTempGroupBoard[wPoint - 20] & 0xff) == nGrp))
            return 1;
        if ((m_Engine.m_byBoard[wPoint + 20] != 0) &&
                ((m_Engine.m_byTempGroupBoard[wPoint + 20] & 0xff) == nGrp))
            return 1;
        return 0;
    }

    void SaveData()
    {
        SaveMainData();
        MEMCPY( m_Engine.m_byTempLocalPattern,m_Engine.m_byLocalPattern,m_Engine.m_byLocalPattern.length);
    }

    boolean IsKeimaType2(boolean bIsLeftKeima)
    {
        short nL1, nL1U1, nR1, nR1U1, nU1;
        byte byU1Str;
        byte cWeight;

        if (bIsLeftKeima) {
            nL1 = GetPosIndexOf((short)0); //L1);
            nL1U1 = GetPosIndexOf((short)5); //L1U1);
            m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nL1]);
            m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nL1U1]);
        } else {
            nR1 = GetPosIndexOf((short)2); //R1);
            nR1U1 = GetPosIndexOf((short)6); //R1U1);
            m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nR1]);
            m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nR1U1]);
        }
        nU1 = GetPosIndexOf((short)1); //U1);
        byU1Str = m_Engine.m_byBoard[m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[nU1]];
        if (((m_Engine.m_byLiberties[byU1Str & 0xff] & 0xff) < 2) ||
                (m_Engine.m_wStatus[byU1Str & 0xff] & 0x0008) != 0)
            return false;
        if ((m_Engine.m_byWhereCall & 0xff) > 2) {
            cWeight = m_Engine.m_cWeightBoard[m_Engine.m_nPos1];
            cWeight = (byte)((cWeight > 0) ? cWeight : -cWeight);

            if (cWeight <= 5)
                return ReadKeimaType2();
        }
        m_Engine.m_nIniScore = GetScoreByTwoStep();
        return true;
    }

    boolean ReadKeimaType1(short nStonePos)
    {
        byte byStoneNum, byFirstStr,byU1DifStr;
        boolean bDead;
        byte cWeight1, cWeight2;

//	ASSERT(m_byWhereCall > 2);

        m_Engine.m_nBoardPos = m_Engine.m_nPos2;
        SetStone2((byte)(m_Engine.m_byTurnColor ^ 3));

        byStoneNum = m_Engine.m_byBoard[ nStonePos ];
        bDead = true;
        if( (m_Engine.m_byLiberties[byStoneNum & 0xff] & 0xff) > 3)
            bDead = false;
        else if((m_Engine.m_byLiberties[byStoneNum & 0xff] & 0xff) > 1)
        {
            if(SimulInSecondOnOutCall(byStoneNum) <= 0)
                bDead = false;
        }

        if(bDead)
        {
            byFirstStr = m_Engine.m_byBoard[ m_Engine.m_nPos1 ];
            if((m_Engine.m_byLiberties[byFirstStr & 0xff] & 0xff) < 2)
            {
                m_Engine.m_nIniScore = PS_MINI;
                return true;
            }
            if(((m_Engine.m_byLiberties[byFirstStr & 0xff] & 0xff) < 4) &&
                    (SimulInSecondOnOutCall(byFirstStr) > 0))
            {
                m_Engine.m_nIniScore = PS_MINI;
                return true;
            }
            if(SimulInFirstOnOutCall(byStoneNum) < 0)
            {
                m_Engine.m_nIniScore = PS_MINI;
                return true;
            }
            m_Engine.m_nPos3 = m_Engine.m_nBoardPos;
        }
        m_Engine.m_nBoardPos= (short)(m_Engine.m_nPos1 - m_Engine.m_nPos2 + nStonePos);
        byU1DifStr = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
        bDead = false;
        if((m_Engine.m_byLiberties[byU1DifStr & 0xff] & 0xff) < 2)
            bDead = true;
        else if(((m_Engine.m_byLiberties[byU1DifStr & 0xff] & 0xff) < 4) &&
                (SimulInSecondOnOutCall(byU1DifStr) > 0))
            bDead = true;

        if(!bDead)
        {
            m_Engine.m_nBoardPos = m_Engine.m_nPos2;
            ExpressTempArea();
            m_Engine.m_nBoardPos= m_Engine.m_nPos3;
            SetStone2(m_Engine.m_byTurnColor);
            m_Engine.m_wStatus[m_Engine.m_byNewStringNumber & 0xff] = (short)0xff01;

            m_Engine.m_byWhiteGroupCount = m_Engine.m_byTempWhiteGroupCount;
            m_Engine.m_byBlackGroupCount = m_Engine.m_byTempBlackGroupCount;
            m_Engine.m_wBlackTSize = m_Engine.m_wTempBlackTSize;
            m_Engine.m_wWhiteTSize = m_Engine.m_wTempWhiteTSize;
            m_Engine.m_nDifOfTerritory = m_Engine.m_nTempDifOfTerritory;
            m_Engine.m_byNewStringNumber = (byte)0xff;

            m_Engine.m_nScoreBase = OldBoardScoreCalc();
        }
        else
        {
            LoadData();
            m_Engine.m_nBoardPos = m_Engine.m_nPos1;
            SetStone2(m_Engine.m_byTurnColor);

            ExpressTempArea();
            BoardWeightCalc();
            if(m_Engine.m_byTurnColor == WHITE)
                m_Engine.m_cWeightBoard[ m_Engine.m_nPos2 ]= 1;
            else
                m_Engine.m_cWeightBoard[ m_Engine.m_nPos2 ] = -1;

            m_Engine.m_nScoreBase = BoardGroupScoreCalc();
        }
        m_Engine.m_nIniScore = ResultGain(m_Engine.m_byWhereCall,m_Engine.m_nScoreBase,m_Engine.m_nChangedTSize);

//Add
        if(!bDead)
        {
            cWeight1 = m_Engine.m_cWeightBoard[m_Engine.m_nPos1];
            cWeight1 = ( cWeight1 > 0 ) ? cWeight1: (byte)-cWeight1;

            cWeight2 = m_Engine.m_cWeightBoard[m_Engine.m_nPos3];
            cWeight2 = ( cWeight1 > 0 )? cWeight2: (byte)-cWeight2;

            if((cWeight1 + cWeight2) >= 4)
                m_Engine.m_nIniScore /= 2;
        }
        return true;
    }

    boolean ReadKeimaType2()
    {
        short nThirdStr,nCatSize,i,nPos,nScore;
        short nFirstSEP;
        byte byNum;
        byte byFirstStr;

        m_Engine.m_nScoreBase = m_Engine.m_nDeadStoneCount;
        nThirdStr = ReadThreeStep();

//Add 1998-8-12
//  m_nBoardPos == m_nPos3;
        nCatSize = 0;
        for(i=0;i<4;i++)
        {
            nPos= (short)(m_Engine.m_nBoardPos + m_Engine.m_cAroundTable[i]);
//		if(!IsInBoard(nPos)) continue;
            if((byte)m_Engine.m_byBoard[nPos] <= 0) continue;
            if(((m_Engine.m_byBoard[nPos] & 1) + 1) != m_Engine.m_byTurnColor) continue;

            byNum = m_Engine.m_byGroupBoard[nPos];
            if((m_Engine.m_stGroup[byNum & 0xff].nAliveDead) > 0xf0)
            {
                nCatSize = m_Engine.m_stGroup[byNum].nTotalSize;
                break;
            }
        }
//Add 1998-8-12

        do
        {
            if ((m_Engine.m_byNewLiberties & 0xff) < 2) {
                break;
            } else {
                if (((m_Engine.m_byNewLiberties & 0xff) < 4) &&
                        (SimulInSecondOnOutCall((byte) nThirdStr) >= 0))
                    break;
                m_Engine.m_wStatus[nThirdStr] = (short) 0xff01;
                m_Engine.m_nBoardPos = m_Engine.m_nPos1;
                byFirstStr = m_Engine.m_byBoard[m_Engine.m_nBoardPos];
                nFirstSEP = m_Engine.m_byLiberties[byFirstStr & 0xff];
                if (nFirstSEP < 2) break;
                if ((nFirstSEP < 4) && (SimulInSecondOnOutCall(byFirstStr) > 0))
                    break;
                m_Engine.m_wStatus[byFirstStr & 0xff] = (short) 0xff01;

                m_Engine.m_byNewStringNumber = (byte) 0xff;
                nScore = OldBoardScoreCalc();
                if (m_Engine.m_nChangedTSize < 0) {
                    m_Engine.m_nChangedTSize += m_Engine.m_nNewTerritory;
                    m_Engine.m_nDeadStoneCount -=
                            (m_Engine.m_nOldDeadCount - m_Engine.m_nScoreBase);
                    m_Engine.m_nOldDeadCount = 0;
                    m_Engine.m_nIniScore = ResultGain(m_Engine.m_byWhereCall, (short)0,
                            m_Engine.m_nChangedTSize);
                } else
                    m_Engine.m_nIniScore = nScore;
                if ((nCatSize != 0) && (m_Engine.m_nIniScore > 0))
                    m_Engine.m_nIniScore += nCatSize / 2;

                return true;
            }
        } while(false);
        $DEAD:
        ReadTwoStep((short)(m_Engine.m_byNewStringNumber & 0xff));
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        ExpressTempArea();
        BoardWeightCalc();

        if (m_Engine.m_byTurnColor == BLACK) {
            if (m_Engine.m_cWeightBoard[m_Engine.m_nPos3] < 4)
                m_Engine.m_cWeightBoard[m_Engine.m_nPos3] = 1;
        } else {
            if (m_Engine.m_cWeightBoard[m_Engine.m_nPos3] > -4)
                m_Engine.m_cWeightBoard[m_Engine.m_nPos3] = -1;
        }
        nScore = BoardGroupScoreCalc();
        m_Engine.m_nOldDeadCount = 0;
        if (nScore < 0) {
            m_Engine.m_nIniScore = nScore;
            return true;
        }
        if (m_Engine.m_nChangedTSize >= m_Engine.m_nNewTerritory)
            return true;

        m_Engine.m_nIniScore = ResultGain(m_Engine.m_byWhereCall, (short)0,
                m_Engine.m_nChangedTSize);

        if (m_Engine.m_nIniScore < 0)
            return true;
        m_Engine.m_nBoardPos = m_Engine.m_nPos1;
        if ((m_Engine.m_byLiberties[m_Engine.m_byBoard[m_Engine.m_nBoardPos] & 0xff] & 0xff) < 2)
            return true;

        if (m_Engine.m_cWeightBoard[m_Engine.m_nBoardPos] != 0)
            m_Engine.m_nIniScore = (short)(m_Engine.m_nIniScore * 3 / 2);
        else
            m_Engine.m_nIniScore *= 2;

        return true;
    }


    boolean IsKeimaType1(boolean bIsLeftKeima)
    {
        short nL1 = GetPosIndexOf((short)0);//L1);
        short nR1 = GetPosIndexOf((short)2);//R1);
        short nR1U1 = GetPosIndexOf((short)6);//R1U1);
        short nL1U1 = GetPosIndexOf((short)5);//L1U1);
        short nStonePos,nU1;
        byte byStr1,byStr2;

        if(bIsLeftKeima)
        {
            m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nL1]);
            m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nR1]);
            nStonePos= (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nL1U1]);
        }
        else
        {
            m_Engine.m_nPos2 = (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nR1]);
            m_Engine.m_nPos3 = (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nL1]);
            nStonePos= (short)(m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nR1U1]);
        }
        byStr1 = m_Engine.m_byBoard[nStonePos];
        if(((m_Engine.m_byLiberties[byStr1 & 0xff] & 0xff) < 2) ||
                (m_Engine.m_wStatus[byStr1 & 0xff] & 0x00008) != 0)
            return false;

        nU1 = GetPosIndexOf((short)1);//U1);
        byStr2 = m_Engine.m_byBoard[ m_Engine.m_nBoardPos+m_Engine.m_cAroundTable[nU1] ];
        if(((m_Engine.m_byLiberties[byStr2 & 0xff] & 0xff) < 2) ||
                (m_Engine.m_wStatus[byStr2 & 0xff] & 0x0008) != 0)
            return false;

        if((m_Engine.m_byWhereCall & 0xff) > 2)
            return ReadKeimaType1(nStonePos);
        m_Engine.m_nIniScore = GetScoreByTwoStep();
        return true;
    }

    void PatternDataOf(byte[] pbyData, short nPos)
    {
        MEMCPY(pbyData, m_Engine.m_byLocalPattern[nPos], 9);
    }

    short U3PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL3[(m_Engine.m_nEntry + 1) & 3]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }

    short WhoseInfluenceOnL2D1()
    {
        byte cWeight;
        short nPos = (short)(m_Engine.m_nMainPosi + m_Engine.m_cAroundTable[m_Engine.nAroundL1U2[m_Engine.m_nEntry - 1]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;

        cWeight = m_Engine.m_cWeightBoard[nPos];
        if (cWeight < 0) return 0;
        if (cWeight == 0) return 1;
        return 2;
    }

    short WhoseInfluenceOnL2U1()
    {
        byte cWeight;
        short nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundR1U2[m_Engine.m_nEntry - 1]]);
        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;

        cWeight = m_Engine.m_cWeightBoard[nPos];
        if (cWeight < 0) return 0;
        if (cWeight == 0) return 1;
        return 2;
    }

    byte BiasPattern_Black()
    {
        byte	cScore = 0;
        short	nInfo = 0;
        byte	byTemp = 0, byTemp1 = 0;
        short	wTemp = 0;
        byte    byParam[] = new byte[1];

        if (m_Engine.m_nPosCode < 2)
            return 0;

        if (m_Engine.m_nPosCode == 2)
        {
            for (m_Engine.m_nEntry = 4; m_Engine.m_nEntry > 0; m_Engine.m_nEntry --)
            {
                if ((m_Engine.m_byAttach & 0xff) >= 0xc0) break;
                RotatePattern();
            }

            wTemp = (short)(m_Engine.m_wNearby & 0x3c3f);

            boolean bGoto_NEARBY_STONE = false;

            if (wTemp != 0) {
                bGoto_NEARBY_STONE = true;
            } else if ((m_Engine.m_byIKen & 8) == 0 ||
                    (m_Engine.m_wKeima & 0x0140) == 0) {
                byTemp1 = 0;

                byTemp = (byte) (m_Engine.m_byKeima1 & 0x30);
                wTemp = (byte) (m_Engine.m_wOKeima & 0x0030);
                if ((byTemp == 0x20) || ((byTemp == 0) && (wTemp == 0x0020)))
                    byTemp1 = 1;
                else if ((byTemp == 0) && (wTemp == 0) &&
                        ((m_Engine.m_byKeima1 & 0x40) == 0) &&
                        ((m_Engine.m_byDKosumi & 4) != 0)) {
                    cScore -= 4;
                } else {

                    byTemp = (byte) (m_Engine.m_byKeima2 & 0x0c);
                    wTemp = (byte) (m_Engine.m_wOKeima & 0x0c00);

                    if ((byTemp1 == 1) || (byTemp == 8) ||
                            ((byTemp == 0) && (wTemp == 0x0800))) {
                        if (((m_Engine.m_wKeima & 0x0140) != 0) ||
                                ((m_Engine.m_byIKen & 4) != 0) ||
                                ((m_Engine.m_byDKosumi & 3) == 1) ||
                                ((m_Engine.m_byDKosumi & 0x0c) == 4))
                            cScore -= 4;
                    } else if ((byTemp == 0) &&
                            (wTemp == 0) &&
                            ((m_Engine.m_byKeima2 & 1) == 0)) {
                        if ((m_Engine.m_byDKosumi & 0x10) != 0)
                            cScore -= 4;
                        else {
                            bGoto_NEARBY_STONE = true;
                        }
                    }
                }
            } else cScore -= 6;

            if (bGoto_NEARBY_STONE) {
                byTemp = LOBYTE(wTemp);
                byTemp1 = HIBYTE(wTemp);

                if (byTemp == 9) {
                    if (((byTemp1 & 0x30) == 0) && ((nInfo = L1StrLibs()) >= 2)) {
                        if (U1StrLibs() != 2) {
                            if ((m_Engine.m_byKeima2 & 0x0a) == 0) cScore += 2;
                        } else {
                            if (nInfo > 3) cScore += 2;
                            if ((m_Engine.m_byKeima2 & 0x0a) == 0x0a)
                                cScore += 4;
                        }
                    }
                } else if (byTemp == 0x18) {
                    if (((byTemp1 & 0x0c) == 0) && ((nInfo = R1StrLibs()) >= 2)) {
                        if (U1StrLibs() != 2) {
                            if ((m_Engine.m_byKeima1 & 0xa0) == 0)
                                cScore += 2;
                        } else {
                            if (nInfo > 3) cScore += 2;
                            if ((m_Engine.m_byKeima1 & 0xa0) == 0xa0)
                                cScore += 4;
                        }
                    }
                } else if ((byTemp &= 0x0c) == 0) {
                    if (((byTemp1 & 4) != 0) && ((m_Engine.m_byAttach & 2) != 0)) {
                        if ((m_Engine.m_byWhereCall == (byte) 0xff) && (L1StrLibs() == 2))
                            cScore += 6;
                    } else if ((byTemp1 & 0x10) != 0) {
                        if ((m_Engine.m_byWhereCall == (byte) 0xff) &&
                                ((m_Engine.m_byAttach & 0x20) != 0) &&
                                (R1StrLibs() == 2))
                            cScore += 6;
                    } else if (((m_Engine.m_wKeima & 0x0280) != 0) ||
                            ((m_Engine.m_byIKen & 8) != 0) ||
                            ((m_Engine.m_byDKosumi & 0x28) != 0) ||
                            ((m_Engine.m_wOKeima & 0x0280) != 0) ||
                            ((m_Engine.m_byNiKen & 8) != 0)) {
                        if (((wTemp & 0x0c03) == 0) && ((m_Engine.m_byIKen & 2) == 0)) {
                            if ((m_Engine.m_byIKen & 1) != 0) cScore += 2;
                            else if (((m_Engine.m_byKeima1 & 0x30) == 0) &&
                                    ((m_Engine.m_byNiKen & 2) == 0)) {
                                if (((m_Engine.m_byNiKen & 1) != 0) ||
                                        ((m_Engine.m_wOKeima & 0x0010) != 0))
                                    cScore += 2;
                            }
                        }

                        if (((wTemp & 0x3030) == 0) && ((m_Engine.m_byIKen & 0x20) == 0)) {
                            if ((m_Engine.m_byIKen & 0x10) != 0)
                                cScore += 2;
                            else if (((m_Engine.m_byKeima2 & 0x0c) == 0) &&
                                    ((m_Engine.m_byNiKen & 0x20) == 0)) {
                                if (((m_Engine.m_byNiKen & 0x10) != 0) ||
                                        ((m_Engine.m_wOKeima & 0x0400) != 0))
                                    cScore += 2;
                            }
                        }
                    }
                } else if (byTemp == 8) {
                    if (wTemp == 0x0408) {
                        if (InfluenceOnL1U1() != 0) cScore -= 2;
                        else if ((nInfo = U1StrLibs()) < 2) cScore += 2;
                        else if (nInfo == 2) {
                            if ((m_Engine.m_byKeima2 & 0x0a) == 0x0a) cScore += 4;
                        } else if ((m_Engine.m_byKeima2 & 0x0a) == 0) cScore += 2;
                    } else if (wTemp == 0x1008) {
                        if (InfluenceOnR1U1() != 0) cScore -= 2;
                        else if ((nInfo = U1StrLibs()) < 2) cScore += 2;
                        else if (nInfo == 2) {
                            if ((m_Engine.m_byKeima1 & 0xa0) == 0xa0) cScore += 4;
                        } else if ((m_Engine.m_byKeima1 & 0xa0) == 0) cScore += 2;
                    }
                } else if (m_Engine.m_byWhereCall == (byte) 0xff) {
                    if ((((m_Engine.m_byAttach & 2) != 0) && (L1StrLibs() == 2)) ||
                            (((m_Engine.m_byAttach & 0x20) != 0) && (R1StrLibs() == 2)))
                        cScore += 6;
                }
            }

            while (m_Engine.m_nEntry > 0)
            {
                RotatePattern();
                m_Engine.m_nEntry --;
            }
            return cScore;
        }

        boolean bPat1, bPat2, bPat3, bPat4, bPat5, bContinue;

        for (m_Engine.m_nEntry = 4; m_Engine.m_nEntry > 0; m_Engine.m_nEntry --)
        {
            bPat1 = false;
            bPat2 = false;
            bPat3 = false;
            bPat4 = false;
            bPat5 = false;
            bContinue = false;

            if (m_Engine.m_nPosCode == 3)
            {
                if (((m_Engine.m_wNearby == 0x001a) &&
                        (m_Engine.m_byIKen == (byte)0xc1) &&
                        ((m_Engine.m_wKeima & 0xc013) == 0xc013)) ||
                        ((m_Engine.m_wNearby == 0x0029) &&
                                (m_Engine.m_byIKen == (byte)0xd0) &&
                                ((m_Engine.m_wKeima & 0xc403) == 0xc403)))
                    cScore += 10;
                else if (((m_Engine.m_wNearby == 0x0025) &&
                        (m_Engine.m_byIKen == (byte)0xc2) &&
                        ((m_Engine.m_wKeima & 0xc023) == 0xc023)) ||
                        ((m_Engine.m_wNearby == 0x0016) &&
                                (m_Engine.m_byIKen == (byte)0xe0) &&
                                ((m_Engine.m_wKeima & 0xc803) == 0xc803)))
                    cScore += 8;
            }

            byTemp1 = (byte)(m_Engine.m_byIKen & 3);

            while (true)
            {
                if (byTemp1 == 3)
                {
                    if (m_Engine.m_wNearby == 0)
                    {
                        if ((m_Engine.m_byIKen & 0x20) != 0)
                        {
                            if ((m_Engine.m_byKeima2 & 3) == 1)
                                byTemp = 2;
                            else
                                byTemp = 0;
                            if ((m_Engine.m_byKeima2 & 0xc0) == 0x40)
                                byTemp ^= 2;
                            cScore += (byTemp & 0xff);
                        }
                    }
                    else if (m_Engine.m_wNearby == 0x10)
                    {
                        if ((m_Engine.m_byIKen & 8) == 0)
                        {
                            if ((m_Engine.m_byIKen & 0x80) == 0)
                                cScore -= 2;
                            else if ((m_Engine.m_byKeima2 & 2) != 0)
                                cScore += 2;
                        }
                        else if (((m_Engine.m_byIKen & 0x80) == 0) &&
                                ((m_Engine.m_byKeima2 & 0x80) != 0))
                            cScore += 2;
                    }
                    else if ((m_Engine.m_wNearby & 0x5fff) == 0x0020)
                    {
                        if ((m_Engine.m_wNearby & 0xa000) != 0)
                            cScore -= 2;
                        if ((m_Engine.m_byIKen & 4) != 0)
                        {
                            if ((m_Engine.m_wNearby & 0x2000) != 0)
                                cScore -= 2;
                            else if ((m_Engine.m_byKeima2 & 0x0a) == 0)
                                cScore += 4;
                        }
                        else if (((m_Engine.m_byIKen & 0x40) == 0) ||
                                ((m_Engine.m_wNearby & 0x8000) != 0))
                            cScore -= 2;
                        else if ((m_Engine.m_byKeima2 & 0xa0) == 0)
                            cScore += 4;
                    }
                    else if ((m_Engine.m_wNearby & 0x7fff) == 0x1020)
                    {
                        if (((m_Engine.m_byIKen & 0x0c) != 0x0c) &&
                                ((R1StrLibs() <= 2) || ((m_Engine.m_byIKen & 4) != 0) ||
                                        ((m_Engine.m_byKeima2 & 1) != 0) || (R1U1StrLibs() > 2)))
                            cScore += 2;
                    }
                    else if ((m_Engine.m_wNearby & 0xdfff) == 0x4020)
                    {
                        if (((m_Engine.m_byIKen & 0xff) < 0xc0) &&
                                ((R1StrLibs() <= 2) || ((m_Engine.m_byIKen & 0x40) != 0) ||
                                        ((m_Engine.m_byKeima2 & 0x80) != 0) || (R1D1StrLibs() > 2)))
                            cScore += 2;
                    }
                    else if ((m_Engine.m_wNearby & 0x0023) == 0)
                    {
                        byTemp = (byte)(m_Engine.m_byAttach & 0xcc);
                        if (byTemp == 8)
                        {
                            if ((m_Engine.m_wNearby & 0x0400) != 0)
                                cScore += 2;
                            else if ((m_Engine.m_wNearby & 0x8000) == 0)
                            {
                                byTemp1 = 0;
                                if ((m_Engine.m_wNearby & 0x0800) == 0)
                                {
                                    if ((m_Engine.m_wNearby & 0x1010) != 0)
                                        byTemp1 = 2;
                                    else if (((m_Engine.m_wNearby & 0x2000) == 0) &&
                                            ((m_Engine.m_byIKen & 0x10) != 0))
                                        byTemp1 = 6;
                                }
                                if ((byTemp1 == 0) && (((m_Engine.m_wNearby & 0x4100) != 0) ||
                                        ((m_Engine.m_byIKen & 0xc0) == 0x40)))
                                    byTemp1 = 6;
                                cScore += (byTemp1 & 0xff);
                            }
                        }
                        else if (byTemp == (byte)0x80)
                        {
                            if ((m_Engine.m_wNearby & 0x0100) != 0)
                                cScore += 2;
                            else if ((m_Engine.m_wNearby & 0x2000) == 0)
                            {
                                byTemp1 = 0;
                                if ((m_Engine.m_wNearby & 0x0200) == 0)
                                {
                                    if ((m_Engine.m_wNearby & 0x4010) != 0)
                                        byTemp1 = 2;
                                    else if (((m_Engine.m_wNearby & 0x8000) == 0) &&
                                            ((m_Engine.m_byIKen & 0x10) != 0))
                                        byTemp1 = 6;
                                }
                                if ((byTemp1 == 0) && (((m_Engine.m_wNearby & 0x1400) != 0) ||
                                        ((m_Engine.m_byIKen & 0x0c) == 4)))
                                    byTemp1 = 6;
                                cScore += (byTemp1 & 0xff);
                            }
                        }
                        else
                        {
                            if ((m_Engine.m_wNearby & 0x0800) != 0)
                            {
                                if (((m_Engine.m_wNearby & 0x00e8) == 0) &&
                                        (((m_Engine.m_wNearby & 0x4100) != 0) ||
                                                ((m_Engine.m_byIKen & 0xc0) == 0x40)))
                                    cScore += 2;
                            }
                            else if ((m_Engine.m_wNearby & 0x0200) != 0)
                            {
                                if (((m_Engine.m_wNearby & 0x00ac) == 0) &&
                                        (((m_Engine.m_wNearby & 0x1400) != 0) ||
                                                ((m_Engine.m_byIKen & 8) == 4)))
                                    cScore += 2;
                            }
                            else if (((m_Engine.m_byIKen & 0x0c) == 4) &&
                                    (((wTemp = (short)(m_Engine.m_wNearby & 0xafff)) == 0x2000) ||
                                            (wTemp == (short)0xa000)))
                            {
                                if (((m_Engine.m_byKeima2 & 1) != 0) ||
                                        (((m_Engine.m_byKeima2 & 2) == 0) &&
                                                ((m_Engine.m_byNiKen & 8) == 0) &&
                                                (((m_Engine.m_byNiKen & 4) != 0) ||
                                                        ((m_Engine.m_wOKeima & 0x0100) != 0))))
                                    cScore += 4;
                            }
                            else if (((m_Engine.m_byIKen & 0xc0) == 0x40) &&
                                    (((wTemp = (short)(m_Engine.m_wNearby & 0xafff)) == (short)0x8000) ||
                                            (wTemp == (short)0xa000)))
                            {
                                if (((m_Engine.m_byKeima2 & 0x40) != 0) ||
                                        (((m_Engine.m_byKeima2 & 0x80) == 0) &&
                                                ((m_Engine.m_byNiKen & 0x80) == 0) &&
                                                (((m_Engine.m_byNiKen & 0x40) != 0) ||
                                                        ((m_Engine.m_wOKeima & 0x4000) != 0))))
                                    cScore += 4;
                            }
                        }
                    }
                    bContinue = true;
                    break;
                }

                if (byTemp1 == 0)
                {
                    if (((m_Engine.m_wNearby & 0x0c07) == 0) &&
                            ((m_Engine.m_byKeima1 & 0x7c) == 8))
                    {
                        if (((m_Engine.m_byIKen & 0x0c) == 0) &&
                                ((m_Engine.m_byDKosumi & 4) == 0))
                        {
                            if ((m_Engine.m_byNiKen & 1) == 0)
                            {
                                if ((m_Engine.m_wOKeima & 0x0014) != 0)
                                    cScore -= 2;
                            }
                            else if ((m_Engine.m_wOKeima & 0x0010) == 0)
                            {
                                if ((m_Engine.m_byNiKen & 0x0c) != 0x0c)
                                    cScore --;
                                else
                                    cScore -= 2;
                            }
                        }
                    }
                    else if (((m_Engine.m_wNearby & 0x0343) == 0) &&
                            ((m_Engine.m_byKeima1 & 0x3d) == 0x20))
                    {
                        if (((m_Engine.m_byIKen & 0xc0) == 0) &&
                                ((m_Engine.m_byDKosumi & 1) == 0))
                        {
                            if ((m_Engine.m_byNiKen & 1) == 0)
                            {
                                if ((m_Engine.m_wOKeima & 0x0014) != 0)
                                    cScore -= 2;
                            }
                            else if ((m_Engine.m_wOKeima & 4) == 0)
                            {
                                if ((m_Engine.m_byNiKen & 0xff) < 0xc0)
                                    cScore --;
                                else
                                    cScore -= 2;
                            }
                        }
                    }
                    bPat4 = true;
                    break;
                }

                if (L1StrLibs() == 2)
                {
                    byTemp = 0;
                    if (m_Engine.m_wNearby == 0x0122)
                    {
                        if ((m_Engine.m_byIKen & 0x40) != 0)
                            byTemp = 6;
                        else if (L1D1StrLibs() > 2)
                            byTemp = 4;
                    }
                    else if (m_Engine.m_wNearby == 0x0422)
                    {
                        if ((m_Engine.m_byIKen & 4) != 0) byTemp = 6;
                        else if (L1U1StrLibs() > 2) byTemp = 4;
                    }
                    if (byTemp != 0)
                    {
                        cScore += (byTemp & 0xff);
                        bContinue = true;
                        break;
                    }
                }

                if (byTemp1 == 1)
                {
                    wTemp = (short)(m_Engine.m_wNearby & 3);
                    if ((wTemp == 2) && ((L1StrLibs() != 2) ||
                            ((m_Engine.m_wNearby & 0xa020) == 0)))
                    {
                        byTemp1 = 0;
                        if (((m_Engine.m_wNearby & 0x0a88) == 0) &&
                                ((m_Engine.m_byKeima1 & 0x28) == 0))
                        {
                            if ((byTemp = (byte)(m_Engine.m_byKosumi & 5)) == 0)
                            {
                                if ((m_Engine.m_byIKen & 0xff) >= 0xc0)
                                {
                                    if ((m_Engine.m_wNearby & 0x8fac) == 0)
                                        cScore += 4;
                                }
                                else if ((m_Engine.m_byIKen & 0x0c) == 0x0c)
                                {
                                    if ((m_Engine.m_wNearby & 0x2fe8) == 0)
                                        cScore += 4;
                                }
                                else cScore -= 6;
                            }
                            else if (byTemp == 4)
                            {
                                if ((m_Engine.m_wNearby & 0x0040) == 0)
                                    byTemp1 = 1;
                            }
                            else if (byTemp == 1)
                            {
                                if ((m_Engine.m_wNearby & 4) == 0)
                                    byTemp1 = 2;
                            }
                        }
                        else if (((m_Engine.m_wNearby & 0x0280) == 0) &&
                                ((m_Engine.m_byKeima1 & 8) == 0))
                        {
                            if (((m_Engine.m_wNearby & 0x0100) == 0) &&
                                    (((m_Engine.m_wNearby & 0x0400) == 0) ||
                                            ((m_Engine.m_wNearby & 0x0040) == 0)))
                                byTemp1 = 1;
                        }
                        else if (((m_Engine.m_wNearby & 0x0808) == 0) &&
                                ((m_Engine.m_byKeima1 & 0x20) == 0))
                        {
                            if (((m_Engine.m_wNearby & 0x0400) == 0) &&
                                    (((m_Engine.m_wNearby & 0x0100) == 0) ||
                                            ((m_Engine.m_wNearby & 4) == 0)))
                                byTemp1 = 2;
                        }
                        if (byTemp1 == 1)
                        {
                            if (((m_Engine.m_byKeima1 & 2) != 0) ||
                                    ((byTemp = (byte)(m_Engine.m_byKeima1 & 5)) == 0) ||
                                    ((byTemp != 5) && ((m_Engine.m_wNearby & 0x0040) == 0)))
                            {
                                if ((m_Engine.m_wNearby & 0xf03c) == 0x2004)
                                    cScore -= 4;
                                else
                                    cScore -= 6;
                            }
                        }
                        else if (byTemp1 == 2)
                        {
                            if (((m_Engine.m_byKeima1 & 0x80) != 0) ||
                                    ((byTemp = (byte)(m_Engine.m_byKeima1 & 0x50)) == 0) ||
                                    ((byTemp != 0x50) && ((m_Engine.m_wNearby & 4) == 0)))
                            {
                                if ((m_Engine.m_wNearby & 0xf0f0) == (short)0x8040)
                                    cScore -= 4;
                                else
                                    cScore -= 6;
                            }
                        }
                    }

                    if (wTemp != 0)
                    {
                        bPat1 = true;
                        break;
                    }

                    if (m_Engine.m_wNearby != 0)
                    {
                        if ((m_Engine.m_wNearby & 0x0500) == 0)
                        {
                            if ((byTemp = (byte)(m_Engine.m_byKeima1 & 0x3c)) != 0x28)
                            {
                                if (((byTemp & 0x0c) == 0) || ((byTemp & 0x30) == 0))
                                {
                                    if (L2StrLibs() <= 2) cScore -= 6;
                                }
                            }
                            else cScore -= 4;
                        }

                        if ((byTemp = (byte)(m_Engine.m_byKosumi & 0x0a)) == 0x0a)
                        {
                            cScore -= 4;
                            bContinue = true;
                            break;
                        }

                        if (byTemp != 0)
                        {
                            wTemp = (short)(m_Engine.m_wNearby & 0x0fcf);
                            if (((m_Engine.m_byKeima1 & 4) != 0) && (wTemp == 0x0804))
                            {
                                if (L1U1StrStatus() != 2)
                                    cScore += 14;
                                bContinue = true;
                                break;
                            }
                            if (((m_Engine.m_byKeima1 & 0x10) != 0) && (wTemp == 0x0240))
                            {
                                if (L1D1StrStatus() != 2)
                                    cScore += 14;
                                bContinue = true;
                                break;
                            }
                        }

                        if (((nInfo = L2StrLibs()) > 2) ||
                                ((nInfo == 2) && ((m_Engine.m_byKeima1 & 0x14) != 0)))
                        {
                            wTemp = (short)(m_Engine.m_wNearby & 0x0f57);
                            if (((wTemp == 0x0400) &&
                                    ((m_Engine.m_byKeima1 & 0x20) != 0) &&
                                    (((m_Engine.m_byKeima1 & 0x40) != 0) ||
                                            ((m_Engine.m_byKeima1 & 0x80) == 0)) &&
                                    (WhoseInfluenceOnL2U1() == 1)) ||
                                    ((wTemp == 0x0100) && ((m_Engine.m_byKeima1 & 8) != 0) &&
                                            (((m_Engine.m_byKeima1 & 1) != 0) ||
                                                    ((m_Engine.m_byKeima1 & 2) == 0)) &&
                                            (WhoseInfluenceOnL2D1() == 1)))
                            {
                                if (nInfo == 2) cScore -= 2;
                                if (((m_Engine.m_byIKen & 0xff) >= 0xc0) ||
                                        ((m_Engine.m_byIKen & 0x0c) == 0x0c))
                                    cScore += 2;
                                if ((m_Engine.m_wNearby == 0x0108) ||
                                        (m_Engine.m_wNearby == 0x0480))
                                {
                                    cScore += 9;
                                    bContinue = true;
                                    break;
                                }
                                cScore += 4;
                                if ((m_Engine.m_byKeima1 & 0x14) != 0)
                                    cScore += 2;
                            }
                        }

                        if (m_Engine.m_wNearby == 0x0080)
                        {
                            if (((m_Engine.m_byIKen & 0x0c) == 0) &&
                                    ((m_Engine.m_wKeima & 0x02e0) == 0x0080) &&
                                    (((m_Engine.m_byKeima1 & 1) == 0) ||
                                            ((m_Engine.m_byKeima1 & 4) != 0)))
                            {
                                cScore += 15;
                                bPat1 = true;
                                break;
                            }
                        }
                        else if (m_Engine.m_wNearby == 8)
                        {
                            if (((m_Engine.m_byIKen & 0xc0) == 0) &&
                                    ((m_Engine.m_wKeima & 0x800b) == 2) &&
                                    (((m_Engine.m_byKeima1 & 0x40) == 0) ||
                                            ((m_Engine.m_byKeima1 & 0x10) != 0)))
                            {
                                cScore += 15;
                                bPat1 = true;
                                break;
                            }
                        }
                        else if ((m_Engine.m_wNearby & 0x3f7f) == 0x1000)
                        {
                            if ((m_Engine.m_byIKen & 0x0c) == 0x0c)
                            {
                                if ((m_Engine.m_wNearby & 0x0080) != 0)
                                    cScore += 4;
                            }
                            else if ((m_Engine.m_byKeima1 & 0x10) == 0)
                            {
                                if ((m_Engine.m_byKeima1 & 0x80) != 0)
                                    cScore += 6;
                                if ((m_Engine.m_wNearby & 0x0080) != 0)
                                    cScore += 4;
                            }
                        }
                        else if ((m_Engine.m_wNearby & 0xcff7) == 0x4000)
                        {
                            if ((m_Engine.m_byIKen & 0xff) >= 0xc0)
                            {
                                if ((m_Engine.m_wNearby & 8) != 0)
                                    cScore += 4;
                            }
                            else if ((m_Engine.m_byKeima1 & 4) == 0)
                            {
                                if ((m_Engine.m_byKeima1 & 2) != 0)
                                    cScore += 6;
                                if ((m_Engine.m_wNearby & 8) != 0)
                                    cScore += 4;
                            }
                        }
                        bPat4 = true;
                        break;
                    }

                    if (((m_Engine.m_byNiKen & 3) != 3) &&
                            ((m_Engine.m_byKeima1 & 0x28) == 0))
                    {
                        if (((m_Engine.m_byKeima1 & 4) == 0) &&
                                ((m_Engine.m_byDKosumi & 3) == 2))
                        {
                            byTemp = 0;
                            if ((m_Engine.m_byKeima1 & 0x10) != 0) byTemp = 1;
                            else if ((m_Engine.m_byDKosumi & 4) != 0) cScore += 2;
                            else if ((m_Engine.m_byDKosumi & 8) == 0) byTemp = 1;
                            else cScore += 8;
                            if (byTemp != 0)
                            {
                                if ((m_Engine.m_byKeima1 & 0x40) != 0)
                                    cScore += 2;
                                else if ((m_Engine.m_byKeima1 & 0x80) != 0)
                                {
                                    if ((m_Engine.m_byKeima1 & 2) != 0)
                                        cScore += 2;
                                    else if ((m_Engine.m_byKeima1 & 0x10) != 0)
                                        cScore += 4;
                                    else if ((m_Engine.m_byIKen & 0x80) == 0)
                                        cScore += 6;
                                }
                                else if (((m_Engine.m_wOKeima & 0x0040) != 0) ||
                                        (((m_Engine.m_wOKeima & 0x0080) == 0) &&
                                                ((m_Engine.m_byNiKen & 8) == 0)))
                                    cScore += 2;
                                else
                                    cScore += 6;
                            }
                        }
                        else if (((m_Engine.m_byKeima1 & 0x10) == 0) &&
                                ((m_Engine.m_byDKosumi & 0x0c) == 8))
                        {
                            if (((m_Engine.m_byDKosumi & 1) != 0) ||
                                    ((m_Engine.m_byKeima1 & 1) != 0))
                                cScore += 2;
                            else if ((m_Engine.m_byKeima1 & 2) != 0)
                            {
                                if ((m_Engine.m_byKeima1 & 0x80) != 0) cScore += 2;
                                else if ((m_Engine.m_byKeima1 & 4) != 0) cScore += 4;
                                else if ((m_Engine.m_byIKen & 8) == 0) cScore += 6;
                            }
                            else if (((m_Engine.m_wOKeima & 1) != 0) ||
                                    (((m_Engine.m_wOKeima & 2) == 0) &&
                                            ((m_Engine.m_byNiKen & 0x80) == 0)))
                                cScore += 2;
                            else cScore += 6;
                        }
                        else if ((m_Engine.m_byIKen & 0x88) != 0)
                            cScore ++;
                        else if ((m_Engine.m_byKeima1 & 0x82) != 0)
                        {
                            byTemp = (byte)(m_Engine.m_byKeima1 & 0x82);

                            if (byTemp == (byte)0x82)
                                cScore += 2;
                            else if (byTemp == 2)
                            {
                                if ((m_Engine.m_byNiKen & 0x0c) != 0x0c)
                                {
                                    if ((m_Engine.m_wOKeima & 0x0080) != 0) cScore += 2;
                                    else if ((m_Engine.m_nPosCode < 5) || (D2PosCode() != 4))
                                        cScore ++;
                                    else cScore --;
                                }
                            }
                            else if ((m_Engine.m_byNiKen & 0xff) < 0xc0)
                            {
                                if ((m_Engine.m_wOKeima & 2) != 0) cScore += 2;
                                else if ((m_Engine.m_nPosCode < 5) || (U2PosCode() != 4))
                                    cScore ++;
                                else cScore --;
                            }
                        }
                        else if ((m_Engine.m_wOKeima & 0x00c0) != 0x0080)
                        {
                            if (((m_Engine.m_byNiKen & 0xff) < 0xc0) &&
                                    ((m_Engine.m_wOKeima & 2) != 0))
                                cScore ++;
                        }
                        else cScore ++;
                    }
                    bPat4 = true;
                    break;
                }

                if (L2StrLibs() < 2)
                {
                    bPat4 = true;
                    break;
                }

                if ((m_Engine.m_wNearby & 3) != 0)
                {
                    if ((m_Engine.m_wNearby & 0xdfff) == 0x0801)
                    {
                        if (((m_Engine.m_byIKen & 0x0c) != 4) ||
                                ((m_Engine.m_byKeima2 & 1) == 0))
                        {
                            if (((m_Engine.m_byKeima1 & 0x10) != 0) ||
                                    ((m_Engine.m_byKeima1 & 1) == 0))
                                cScore += 6;
                            else if ((m_Engine.m_byKeima1 & 2) != 0)
                                cScore += 2;
                            else
                            {
                                byTemp = 0;
                                byParam[0] = byTemp;
                                LDCorner_L1White(byParam);
                                byTemp = byParam[0];
                                byTemp += (((byte)byTemp / 2) & 0xff);
                                cScore += (10 - (byTemp & 0xff));
                            }
                        }
                    }
                    else if ((m_Engine.m_wNearby & 0x7fff) == 0x0201)
                    {
                        if (((m_Engine.m_byIKen & 0xc0) != 0x40) ||
                                ((m_Engine.m_byKeima2 & 0x40) == 0))
                        {
                            if (((m_Engine.m_byKeima1 & 4) != 0) ||
                                    ((m_Engine.m_byKeima1 & 0x40) == 0))
                                cScore += 6;
                            else if ((m_Engine.m_byKeima1 & 0x80) != 0)
                                cScore += 2;
                            else
                            {
                                byTemp = 0;
                                byParam[0] = byTemp;
                                LUCorner_L1White(byParam);
                                byTemp = byParam[0];
                                byTemp += (((byte)byTemp / 2) & 0xff);
                                cScore += (10 - (byTemp & 0xff));
                            }
                        }
                    }
                    else
                    {
                        bPat5 = true;
                        break;
                    }
                }
                else
                {
                    if ((m_Engine.m_byKeima1 & 0x14) != 0)
                    {
                        byTemp = (byte)(m_Engine.m_byKeima1 & 0x14);
                        nInfo = -1;
                        if (byTemp == 0x10)
                        {
                            if ((m_Engine.m_wNearby & 0x0c0c) == 0)
                                nInfo = L2U1StrLibs();
                        }
                        else if (byTemp == 4)
                        {
                            if ((m_Engine.m_wNearby & 0x03c0) == 0)
                                nInfo = L2D1StrLibs();
                        }
                        else
                        {
                            if ((m_Engine.m_wNearby & 0x0fcc) == 0) cScore -= 6;
                            else if ((m_Engine.m_wNearby & 0x03c0) == 0) nInfo = L2D1StrLibs();
                            else if ((m_Engine.m_wNearby & 0x0c0c) == 0) nInfo = L2U1StrLibs();
                        }

                        if (nInfo == 2) cScore -= 6;
                        else if (nInfo > 2)
                        {
                            if (((m_Engine.m_byIKen & 0x44) == 0) &&
                                    ((m_Engine.m_wKeima & 0x4141) == 0))
                            {
                                if (nInfo == 4) cScore -= 2;
                                else if (nInfo < 4) cScore -= 4;
                            }
                        }
                    }
                    else
                    {
                        if (((m_Engine.m_wNearby & 0x0c0c) == 0) &&
                                ((m_Engine.m_wOKeima & 0x0010) != 0) &&
                                ((m_Engine.m_byKeima1 & 0x60) == 0) &&
                                ((m_Engine.m_byDKosumi & 4) == 0))
                            byTemp = (byte)~byTemp;
                        if (((m_Engine.m_wNearby & 0x03c0) == 0) &&
                                ((m_Engine.m_wOKeima & 4) != 0) &&
                                ((m_Engine.m_byKeima1 & 9) == 0) &&
                                ((m_Engine.m_byDKosumi & 1) == 0))
                            byTemp = (byte)~byTemp;

                        cScore += (byTemp & 0xff);
                        if ((m_Engine.m_wNearby == 0) &&
                                (m_Engine.m_nPosCode <= 4) &&
                                ((m_Engine.m_byDKosumi & 0xff) < 0xc0) &&
                                ((m_Engine.m_byIKen & 0x88) == 0)) {
                            byTemp = 0;
                            if ((nInfo = D2PosCode()) < 3)
                                byTemp = 1;
                            else if (nInfo > 3) {
                                nInfo = U2PosCode();
                                if (nInfo < 3) byTemp = 2;
                                else if (nInfo == 3) {
                                    if (((m_Engine.m_byIKen & 0x40) == 0) &&
                                            ((m_Engine.m_byKeima1 & 1) == 0)) {
                                        if ((m_Engine.m_byKeima2 & 0x40) != 0)
                                            cScore += 2;
                                        byTemp = 1;
                                    } else if (((m_Engine.m_byIKen & 0x0c) == 0) &&
                                            ((m_Engine.m_byKeima1 & 0xc0) == 0)) {
                                        if ((m_Engine.m_byKeima2 & 1) != 0)
                                            cScore += 2;
                                        cScore += 2;
                                    }
                                }
                            } else if (((m_Engine.m_byIKen & 4) == 0) &&
                                    ((m_Engine.m_byKeima1 & 0x40) == 0)) {
                                if ((m_Engine.m_byKeima2 & 1) != 0)
                                    cScore += 2;
                                byTemp = 2;
                            } else if (((m_Engine.m_byIKen & 0xc0) == 0) &&
                                    ((m_Engine.m_byKeima1 & 3) == 0)) {
                                if ((m_Engine.m_byKeima2 & 0x40) != 0)
                                    cScore += 2;
                                cScore += 2;
                            }
                            if (byTemp == 1) {
                                if (((m_Engine.m_byIKen & 4) != 0) ||
                                        ((m_Engine.m_wKeima & 0x0140) != 0))
                                    cScore += 2;
                            } else if (byTemp == 2) {
                                if (((m_Engine.m_byIKen & 0x40) != 0) ||
                                        ((m_Engine.m_wKeima & 0x4001) != 0))
                                    cScore += 2;
                            }
                        }
                    }
                    bPat4 = true;
                    break;
                }
                bContinue = true;
                break;
            }

            //----------------- PATT4-----------------------------------------
//PATT4:
            if ( bPat4 )
            {
                byTemp1 = 0;
                if (((m_Engine.m_byKeima1 & 8) == 0) ||
                        ((m_Engine.m_wNearby & 0xc3c3) != 0))
                    byTemp1 = 1;
                else if ((m_Engine.m_wKeima & 0xc003) != 0) byTemp1 = 2;
                else if ((m_Engine.m_byIKen & 0xc0) != 0) byTemp1 = 1;
                else if ((m_Engine.m_byNiKen & 0xff) < 0xc0)
                {
                    if (((m_Engine.m_byNiKen & 0x40) != 0) ||
                            ((m_Engine.m_wOKeima & 0x4000) != 0))
                        byTemp1 = 1;
                    else if ((m_Engine.m_wOKeima & 1) != 0)
                        cScore -= 2;
                    else if (m_Engine.m_nPosCode == 3)
                        cScore --;
                    else if ((m_Engine.m_byIKen & 1) != 0)
                        byTemp1 = 2;
                    else
                    {
                        byParam[0] = cScore;
                        short nRet = ConsiderD2PosCode(byParam);
                        cScore = byParam[0];
                        if (((m_Engine.m_wNearby & 0xe3ff) == 0) &&
                                (nRet == 1) &&
                                ((m_Engine.m_byKeima1 & 0x20) == 0) &&
                                ((m_Engine.m_byNiKen & 3) == 0) &&
                                ((m_Engine.m_wOKeima & 0x0030) == 0))
                            cScore++;
                    }
                }
                else if ((m_Engine.m_byKeima1 & 0x10) != 0)
                {
                    if ((m_Engine.m_byIKen & 0x14) == 0)
                    {
                        cScore -= 4;
                        bPat4 = false;
                        bPat1 = true;
                    }

                    if ( bPat4 )
                    {
                        bPat4 = false;
                        bPat5 = true;
                    }
                }

                if ( bPat4  )
                {
                    if ((byTemp1 == 2) &&
                            (m_Engine.m_wNearby == 0) &&
                            ((m_Engine.m_byIKen & 0xc0) == 0) &&
                            ((m_Engine.m_byKeima1 & 1) != 0))
                    {
                        if ((m_Engine.m_byKeima2 & 0x80) != 0) cScore -= 2;
                        else if ((m_Engine.m_byNiKen & 0x80) != 0) cScore --;
                        else if (((m_Engine.m_byKeima2 & 0x40) != 0) ||
                                ((m_Engine.m_byNiKen & 0x40) != 0))
                            cScore += 2;
                        else if ((m_Engine.m_wOKeima & 0x8000) != 0)
                            cScore --;
                        else if (((m_Engine.m_byDKosumi & 2) != 0) &&
                                ((m_Engine.m_wOKeima & 1) == 0))
                            cScore -= 2;
                        else if (((m_Engine.m_wOKeima & 0x4000) != 0) ||
                                ((D2PosCode() == 3) &&
                                        ((m_Engine.m_byDKosumi & 1) != 0)) ||
                                (R2PosCode() <= 2))
                            cScore += 2;
                        else cScore --;
                    }

                    if ((m_Engine.m_wNearby & 0x3c0f) != 0)
                    {
                        if ((m_Engine.m_wNearby & 0xcfff) == 0x0801)
                        {
                            if ((m_Engine.m_byKeima1 & 0x20) != 0)
                            {
                                if (((m_Engine.m_byKeima1 & 2) != 0) ||
                                        ((m_Engine.m_byKeima1 & 5) == 0))
                                {
                                    cScore += 2;
                                    bPat4 = false;
                                    bContinue = true;
                                }
                            }
                        }
                        else if (((m_Engine.m_wNearby & 0x3fff) == 0x0201) && ((m_Engine.m_byKeima1 & 8) != 0))
                        {
                            if (((m_Engine.m_byKeima1 & 0x80) != 0) || ((m_Engine.m_byKeima1 & 0x50) == 0))
                            {
                                cScore += 2;
                                bPat4 = false;
                                bContinue = true;
                            }
                        }
                    }
                    else if ((m_Engine.m_byKeima1 & 0x20) != 0)
                    {
                        byTemp1 = 0;
                        if ((m_Engine.m_wKeima & 0x03c0) != 0) byTemp1 = 1;
                        else if ((m_Engine.m_byIKen & 0x0c) == 0)
                        {
                            if ((m_Engine.m_byNiKen & 0x0c) == 0x0c)
                            {
                                if (((m_Engine.m_byKeima1 & 4) != 0) &&
                                        ((m_Engine.m_byIKen & 0x50) == 0))
                                    cScore -= 4;
                            }
                            else if (((m_Engine.m_byNiKen & 4) == 0) &&
                                    ((m_Engine.m_wOKeima & 0x0100) == 0))
                            {
                                if ((m_Engine.m_wOKeima & 0x0040) != 0)
                                    cScore -= 2;
                                else if (m_Engine.m_nPosCode == 3)
                                    cScore--;
                                else if ((m_Engine.m_byIKen & 1) != 0) byTemp1 = 1;
                                else {
                                    byParam[0] = cScore;
                                    short nRet = ConsiderU2PosCode(byParam);
                                    cScore = byParam[0];
                                    if (((m_Engine.m_wNearby & 0xbcff) == 0) &&
                                            (nRet == 1)) {
                                        if (((m_Engine.m_byKeima1 & 8) == 0) &&
                                                ((m_Engine.m_byNiKen & 3) == 0) &&
                                                ((m_Engine.m_wOKeima & 0x000c) == 0))
                                            cScore++;
                                    }
                                }
                            }
                        }
                        if ((byTemp1 != 0) &&
                                (m_Engine.m_wNearby == 0) &&
                                ((m_Engine.m_byIKen & 0x0c) == 0) &&
                                ((m_Engine.m_byKeima1 & 0x40) != 0))
                        {
                            if ((m_Engine.m_byKeima2 & 2) != 0)
                                cScore -= 2;
                            else if ((m_Engine.m_byNiKen & 8) != 0)
                                cScore --;
                            else if (((m_Engine.m_byKeima2 & 1) != 0) ||
                                    ((m_Engine.m_byNiKen & 4) != 0))
                                cScore += 2;
                            else if ((m_Engine.m_wOKeima & 0x0200) != 0)
                                cScore --;
                            else if (((m_Engine.m_byDKosumi & 8) != 0) &&
                                    ((m_Engine.m_wOKeima & 0x0040) == 0))
                                cScore -= 2;
                            else if (((m_Engine.m_wOKeima & 0x0100) != 0) ||
                                    ((U2PosCode() == 3) &&
                                            ((m_Engine.m_byDKosumi & 4) != 0)) ||
                                    (R2PosCode() < 3))
                                cScore += 2;
                            else cScore --;
                        }
                    }

                    if ( bPat4 )
                    {
                        bPat4 = false;
                        bPat5 = true;
                    }
                }

                if ( bPat4 )
                {
                    bPat4 = false;
                    bPat5 = true;
                }
            }
            //----------------------------------------------------------------------------------------------

//PATT5:
            //----------------------------- PATT5 ----------------------------------------------------------
            if ( bPat5 )
            {
                if ((m_Engine.m_byIKen & 1) == 0)
                {
                    if ((m_Engine.m_byKeima1 & 0x0c) == 4)
                    {
                        if ((m_Engine.m_wNearby & 0x0703) == 0x0200)
                        {
                            if ((m_Engine.m_byAttach & 0xf8) == 0x60) cScore += 2;
                            if ((m_Engine.m_byIKen & 2) != 0) cScore -= 2;
                            else if ((m_Engine.m_wNearby & 0x0080) != 0) cScore -= 6;
                            else if ((m_Engine.m_byKeima1 & 0x10) != 0) cScore -= 3;
                            else if ((m_Engine.m_byKeima1 & 2) != 0) cScore -= 6;
                            else if ((m_Engine.m_byKeima1 & 1) != 0) cScore -= 2;
                            else cScore -= 6;
                            bPat5 = false;
                            bPat3 = true;
                        }
                        if ( bPat5 )
                        {
                            if ((m_Engine.m_wNearby & 0x03c3) == 2)
                            {
                                if ((m_Engine.m_wNearby & 0xf03c) == 0x2004) cScore += 2;
                                if ((m_Engine.m_byKeima1 & 2) != 0) cScore -= 6;
                                else if ((m_Engine.m_byKeima1 & 1) != 0) cScore -= 2;
                                else if (((m_Engine.m_byIKen & 0x40) == 0) ||
                                        ((m_Engine.m_wNearby & 0x8000) != 0))
                                    cScore -= 6;
                                else cScore -= 2;
                                bPat5 = false;
                                bPat2 = true;
                            }
                        }
                    }

                    if ( bPat5 )
                    {
                        if ((m_Engine.m_byKeima1 & 0x30) == 0x10)
                        {
                            if ((m_Engine.m_wNearby & 0x0d03) == 0x0800)
                            {
                                if ((m_Engine.m_byAttach & 0xbc) == 0x24)
                                    cScore += 2;
                                if ((m_Engine.m_byIKen & 2) != 0)
                                    cScore -= 2;
                                else if ((m_Engine.m_wNearby & 8) != 0)
                                    cScore -= 6;
                                else if ((m_Engine.m_byKeima1 & 4) != 0)
                                    cScore -= 3;
                                else if ((m_Engine.m_byKeima1 & 0x80) != 0)
                                    cScore -= 6;
                                else if ((m_Engine.m_byKeima1 & 0x40) != 0)
                                    cScore -= 2;
                                else
                                    cScore -= 6;
                                bPat5 = false;
                                bPat3 = true;
                            }
                            if ( bPat5 )
                            {
                                if ((m_Engine.m_wNearby & 0x0c0f) == 2)
                                {
                                    if ((m_Engine.m_wNearby & 0xf0f0) == 0x8040) cScore += 2;
                                    if ((m_Engine.m_byKeima1 & 0x80) != 0) cScore -= 6;
                                    else if ((m_Engine.m_byKeima1 & 0x40) != 0) cScore -= 2;
                                    else if (((m_Engine.m_byIKen & 4) == 0) ||
                                            ((m_Engine.m_wNearby & 0x2000) != 0))
                                        cScore -= 6;
                                    else
                                        cScore -= 2;
                                    bPat5 = false;
                                    bPat2 = true;
                                }
                            }
                        }
                    }
                }

                if ( bPat5 )
                {
                    if ((m_Engine.m_wNearby & 0xbbff) == 0x2000)
                    {
                        nInfo = L2D2PosCode();
                        if (nInfo == 1)
                        {
                            cScore += 2;
                            bPat5 = false;
                            bContinue = true;
                        }

                        if ( bPat5 )
                        {
                            byTemp = 0;
                            if ((m_Engine.m_wNearby & 0x4400) != 0) {
                                if (m_Engine.m_wNearby == 0x6000) {
                                    if (L2U2PosCode() == 1) cScore += 2;
                                    else if ((m_Engine.m_byKeima1 & 0x5a) == 0) {
                                        cScore--;
                                        byTemp = 1;
                                    }
                                } else if (m_Engine.m_wNearby == 0x2400) {
                                    if (R2D2PosCode() == 1) cScore += 2;
                                    else if ((m_Engine.m_wKeima & 0x500a) == 0) {
                                        cScore--;
                                        byTemp = 2;
                                    }
                                }
                            } else {
                                if ((m_Engine.m_byIKen & 2) == 0) {
                                    if ((m_Engine.m_byIKen & 0xff) >= 0xc0) {
                                        bPat5 = false;
                                        bPat2 = true;
                                    }

                                    if (bPat5) {
                                        if ((m_Engine.m_byIKen & 0x80) == 0)
                                            byTemp = 3;
                                    }
                                }
                                if (bPat5) {
                                    if ((byTemp != 3) && (nInfo != 2) &&
                                            ((m_Engine.m_wKeima & 0x1040) == 0))
                                        cScore -= 4;
                                }
                            }

                            if (bPat5) {
                                if (byTemp != 0) {
                                    if ((byTemp == 3) && ((m_Engine.m_wKeima & 0x5050) == 0))
                                        cScore -= 2;
                                    if ((byTemp & 1) != 0) {
                                        if (((m_Engine.m_byIKen & 0x0c) != 0) ||
                                                ((m_Engine.m_wKeima & 0x03c0) != 0) ||
                                                ((m_Engine.m_wOKeima & 0x0040) != 0)) {
                                            if ((m_Engine.m_wNearby & 0x4000) == 0)
                                                byTemp = 2;
                                        } else if ((m_Engine.m_byNiKen & 4) != 0) {
                                            if ((m_Engine.m_byIKen & 1) == 0)
                                                cScore--;
                                        } else if (((m_Engine.m_byNiKen & 8) != 0) ||
                                                ((m_Engine.m_wOKeima & 0x0100) == 0)) {
                                            if ((m_Engine.m_wNearby & 0x4000) == 0) byTemp = 2;
                                        } else cScore -= 2;
                                    }
                                    if (byTemp == 2) {
                                        if (((m_Engine.m_byIKen & 0x30) == 0) &&
                                                ((m_Engine.m_byKeima2 & 0x3c) == 0) &&
                                                ((m_Engine.m_wOKeima & 0x1000) == 0)) {
                                            if ((m_Engine.m_byNiKen & 0x10) == 0) {
                                                if (((m_Engine.m_byNiKen & 0x20) == 0) &&
                                                        ((m_Engine.m_wOKeima & 0x0400) != 0))
                                                    cScore -= 2;
                                            } else if ((m_Engine.m_byIKen & 0x40) == 0)
                                                cScore--;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if ((m_Engine.m_nPosCode != 3) &&
                            ((m_Engine.m_byIKen & 0x30) == 0) &&
                            ((m_Engine.m_byNiKen & 0x30) == 0))
                    {
                        nInfo = -1;
                        if (((m_Engine.m_wNearby & 0xf3ff) == 9) &&
                                ((m_Engine.m_byKeima2 & 0x0c) == 0) &&
                                ((m_Engine.m_wOKeima & 0x0c00) == 0))
                        {
                            nInfo = U3PosCode();
                        }
                        else if (((m_Engine.m_wNearby & 0xfcff) == 0x0081) &&
                                ((m_Engine.m_byKeima2 & 0x30) == 0) &&
                                ((m_Engine.m_wOKeima & 0x3000) == 0))
                        {
                            nInfo = D3PosCode();
                        }
                        if (nInfo != -1)
                        {
                            if (nInfo == 2) cScore -= 2;
                            else if (nInfo == 3) cScore -= 4;
                            else
                            {
                                bPat5 = false;
                                bContinue = true;
                            }
                        }
                    }

                    if ( bPat5 )
                    {
                        bPat5 = false;
                        bPat1 = true;
                    }
                }
            }

            //-----------------------------------------------------------------------

            //-------------------- PATT1 --------------------------------------------------
//PATT1:
            if ( bPat1 )
            {
                if ((m_Engine.m_byIKen & 0xff) < 0xc0)
                {
                    if (((m_Engine.m_byDKosumi & 1) != 0) &&
                            (L2D2StrStatus() == 0) &&
                            ((m_Engine.m_byKeima1 & 5) == 0) &&
                            ((m_Engine.m_wNearby & 0x0341) == 0))
                    {
                        cScore --;

                        byTemp = (byte)(m_Engine.m_byAttach & 0x82);
                        if (byTemp == (byte)0x82)
                        {
                            bPat1 = false;
                            bContinue = true;
                        }

                        if ( bPat1 )
                        {
                            byTemp1 = (byte)(m_Engine.m_byKeima1 & 0x0a);
                            if (byTemp1 == 0x0a)
                            {
                                bPat1 = false;
                                bPat2 = true;
                            }

                            if ( bPat1 )
                            {
                                byTemp = (byte)(rolb1(byTemp) | byTemp1);
                                if ((m_Engine.m_byIKen & 2) != 0)
                                {
                                    if (((byTemp1 = (byte)(byTemp & 0x0c)) == 0) ||
                                            (byTemp1 == 0x0c))
                                        cScore -= 3;
                                }
                                else if ((m_Engine.m_byIKen & 0x80) != 0)
                                {
                                    if (((byTemp1 = (byte)(byTemp & 3)) == 0) ||
                                            (byTemp1 == 3)) cScore -= 3;
                                }
                                else if ((byTemp != 0) ||
                                        (((m_Engine.m_byKosumi & 0x44) == 0) &&
                                                ((m_Engine.m_wKeima & 0x4010) == 0) &&
                                                ((m_Engine.m_byNiKen & 0x41) == 0) &&
                                                ((m_Engine.m_wOKeima & 0x0005) == 0)))
                                    cScore -= 2;
                            }
                        }
                    }

                    if ( bPat1 )
                    {
                        if (((m_Engine.m_byIKen & 2) == 0) &&
                                ((m_Engine.m_byIKen & 0x0c) != 0x0c) &&
                                (m_Engine.m_wNearby == 0x20))
                        {
                            if ((m_Engine.m_byIKen & 0xbe) == 4) {
                                if (m_Engine.m_wKeima == 0) {
                                    if (((m_Engine.m_byNiKen & 2) == 0) &&
                                            ((m_Engine.m_wOKeima & 0x0008) == 0)) {
                                        cScore += 2;
                                        if (((m_Engine.m_byDKosumi & 8) != 0) ||
                                                ((m_Engine.m_wOKeima & 0x0020) != 0))
                                            cScore += 4;
                                    }
                                } else if ((m_Engine.m_wKeima & 0xceaa) == 0x4000)
                                    cScore += 10;
                                else if ((m_Engine.m_byKeima1 & 0xbf) == 0) {
                                    if (((m_Engine.m_byNiKen & 2) == 0) &&
                                            ((m_Engine.m_wOKeima & 0x0008) == 0)) {
                                        cScore += 2;
                                        if (((m_Engine.m_byDKosumi & 8) != 0) ||
                                                ((m_Engine.m_wOKeima & 0x0020) != 0))
                                            cScore += 4;
                                    }
                                }
                            } else if ((m_Engine.m_byIKen & 0xfa) == 0x40) {
                                if (m_Engine.m_wKeima == 0) {
                                    if (((m_Engine.m_byNiKen & 2) == 0) &&
                                            ((m_Engine.m_wOKeima & 0x0020) == 0)){
                                        cScore += 2;
                                        if (((m_Engine.m_byDKosumi & 2) != 0) ||
                                                ((m_Engine.m_wOKeima & 0x0008) != 0))
                                            cScore += 4;
                                    }
                                } else if ((m_Engine.m_wKeima & 0xb3aa) == 0x0100)
                                    cScore += 10;
                                else if ((m_Engine.m_byKeima1 & 0xfe) == 0) {
                                    if (((m_Engine.m_byNiKen & 2) == 0) &&
                                            ((m_Engine.m_wOKeima & 0x0020) == 0)) {
                                        cScore += 2;
                                        if (((m_Engine.m_byDKosumi & 2) != 0) ||
                                                ((m_Engine.m_wOKeima & 0x0008) != 0))
                                            cScore += 4;
                                    }
                                }
                            } else if ((m_Engine.m_wKeima == 0x0100) ||
                                    (m_Engine.m_wKeima == 0x4000)) {
                                if (m_Engine.m_nPosCode >= 4)
                                    cScore += 2;
                            }

                            if (bPat1) {
                                bPat1 = false;
                                bContinue = true;
                            }
                        }
                    }
                }

                if ( bPat1 )
                {
                    bPat1 = false;
                    bPat2 = true;
                }
            }

            //------------------------------------------------------------------

//PATT2:	//------------------- PATT2 -----------------------------------------
            if ( bPat2 )
            {
                byParam[0] = cScore;
                short nRet = Pattern_0102(byParam);
                cScore = byParam[0];
                if (nRet == 0)
                {
                    if (((m_Engine.m_byIKen & 0x40) == 0) &&
                            (((m_Engine.m_byIKen & 0x80) != 0) ||
                                    ((m_Engine.m_byKeima2 & 0x80) != 0)) &&
                            (L1StrLibs() != 2))
                        cScore -= 2;
                    if (((m_Engine.m_byNiKen & 3) == 2) &&
                            ((m_Engine.m_byIKen & 3) == 0) &&
                            ((m_Engine.m_byKeima1 & 0x3c) == 0) &&
                            ((m_Engine.m_wOKeima & 0x003c) == 0))
                        cScore += 4;

                    bPat2 = false;
                    bContinue = true;
                }

                if ( bPat2 )
                {
                    byParam[0] = cScore;
                    nRet = Pattern_0402(byParam);
                    cScore = byParam[0];
                    if (nRet == 0)
                    {
                        if (((m_Engine.m_byIKen & 4) == 0) &&
                                (((m_Engine.m_byIKen & 8) != 0) ||
                                        ((m_Engine.m_byKeima2 & 2) != 0)) &&
                                (L1StrLibs() != 2))
                            cScore -= 2;
                        if (((m_Engine.m_byNiKen & 3) == 2) &&
                                ((m_Engine.m_byIKen & 3) == 0) &&
                                ((m_Engine.m_byKeima1 & 0x3c) == 0) &&
                                ((m_Engine.m_wOKeima & 0x003c) == 0))
                            cScore += 4;
                        bPat2 = false;
                        bContinue = true;
                    }

                    if ( bPat2 )
                    {
                        if ((m_Engine.m_wNearby & 1) != 0)
                        {
                            byTemp1 = 0;
                            if (((m_Engine.m_wNearby & 0x03c0) == 0) &&
                                    ((m_Engine.m_byIKen & 0xc0) == 0x40) &&
                                    ((m_Engine.m_byKeima1 & 1) != 0))
                            {
                                if ((m_Engine.m_byKeima1 & 8) != 0)
                                {
                                    if ((m_Engine.m_wNearby & 0x0028) != 0)
                                    {
                                        cScore += 7;
                                        byTemp1 = 2;
                                    }
                                    else if ((m_Engine.m_wNearby & 0x0014) != 0)
                                        byTemp1 = 1;
                                    else
                                    {
                                        if ((m_Engine.m_wNearby & 0x1000) != 0)
                                            cScore += 7;
                                        else cScore += 4;
                                        byTemp1 = 2;
                                    }
                                }
                                else if ((m_Engine.m_wNearby & 0x8000) != 0)
                                    byTemp1 = 2;
                            }

                            if ((byTemp1 == 0) &&
                                    (((m_Engine.m_wNearby & 0x0c0c) == 0) &&
                                            ((m_Engine.m_byIKen & 0x0c) == 4) &&
                                            ((m_Engine.m_byKeima1 & 0x40) != 0)))
                            {
                                if ((m_Engine.m_byKeima1 & 0x20) != 0)
                                {
                                    if ((m_Engine.m_wNearby & 0x00a0) != 0)
                                    {
                                        cScore += 7;
                                        byTemp1 = 3;
                                    }
                                    else if ((m_Engine.m_wNearby & 0x0050) != 0)
                                        byTemp1 = 1;
                                    else
                                    {
                                        if ((m_Engine.m_wNearby & 0x8000) != 0)
                                            cScore += 7;
                                        else cScore += 4;
                                        byTemp1 = 3;
                                    }
                                }
                                else if ((m_Engine.m_wNearby & 0x2000) != 0)
                                    byTemp1 = 3;
                            }

                            if (byTemp1 >= 2)
                            {
                                if (byTemp1 == 2)
                                {
                                    if ((m_Engine.m_wNearby & 0x080c) == 0)
                                        cScore += 4;
                                }
                                else
                                {
                                    if ((m_Engine.m_wNearby & 0x02c0) == 0)
                                        cScore += 4;
                                }
                                if ((m_Engine.m_byIKen & 2) != 0) cScore += 2;
                                if ((m_Engine.m_wNearby & 0x0020) != 0)
                                {
                                    if ((m_Engine.m_wNearby & 0x5000) == 0)
                                        cScore += 4;
                                    if ((m_Engine.m_wNearby & 0xa000) != 0)
                                        cScore += 2;
                                }

                                if ( bPat2 )
                                {
                                    bPat2 = false;
                                    bContinue = true;
                                }
                            }

                            if ( bPat2 )
                            {
                                if ((m_Engine.m_byIKen & 0x20) == 0)
                                {
                                    if ((((m_Engine.m_wNearby & 0x2000) != 0) &&
                                            ((m_Engine.m_wNearby & 0xcff4) == 0) &&
                                            ((m_Engine.m_byKeima2 & 0x10) != 0)) ||
                                            (((m_Engine.m_wNearby & 0x8000) != 0) &&
                                                    ((m_Engine.m_wNearby & 0x3f7c) == 0) &&
                                                    ((m_Engine.m_byKeima2 & 4) != 0)))
                                        cScore += 4;
                                }
                            }

                        }

                        if ( bPat2 )
                            bPat3 = true;
                    }
                }
            }
            //----------------------------------------------------------------------------

            //---------------- PATT3 -------------------------------------------------------
//PATT3:
            if ( bPat3 )
            {
                if ((m_Engine.m_wNearby & 0x33aa) == 0x2200)
                {
                    if ((m_Engine.m_wNearby & 0x4455) != 0)
                    {
                        if (m_Engine.m_byAttach == 0)
                            cScore += 4;
                        else if ((m_Engine.m_byAttach & 0x41) != 0x41)
                        {
                            if ((m_Engine.m_byAttach & 0x14) != 0x14)
                            {
                                if (((m_Engine.m_byAttach & 0x44) != 0x44) &&
                                        ((m_Engine.m_byAttach & 0x11) != 0x11))
                                    cScore += 4;
                                else
                                    cScore += 2;
                            }
                        }
                    }
                }
                else if ((m_Engine.m_wNearby & 0xc3ff) == 0x4008)
                {
                    if ((m_Engine.m_byIKen & 0xff) < 0xc0)
                    {
                        if ((m_Engine.m_byKeima1 & 2) != 0)
                            cScore -= 4;
                        else if (m_Engine.m_wNearby == 0x4008)
                        {
                            if (((m_Engine.m_byIKen & 3) != 0) ||
                                    ((m_Engine.m_byNiKen & 3) != 3))
                                cScore += 2;
                            else
                                cScore += 6;
                        }
                    }
                }
                else if ((m_Engine.m_wNearby & 0x3cff) == 0x1080)
                {
                    if ((m_Engine.m_byIKen & 0x0c) != 0x0c)
                    {
                        if ((m_Engine.m_byKeima1 & 0x80) != 0)
                            cScore -= 4;
                        else if (m_Engine.m_wNearby == 0x1080)
                        {
                            if (((m_Engine.m_byIKen & 3) != 0) ||
                                    ((m_Engine.m_byNiKen & 3) != 3))
                                cScore += 2;
                            else
                                cScore += 6;
                        }
                    }
                }
                else if ((m_Engine.m_byIKen & 0xff) < 0xc0)
                {
                    switch (m_Engine.m_wNearby & 0xc3fb)
                    {
                        case 0x0220:
                            if ((m_Engine.m_wNearby & 0x0400) != 0)
                                byTemp = (byte)0xFE;	//by Jong -2;
                            else if ((m_Engine.m_wNearby & 4) != 0)
                                byTemp = (byte)0xFF;	//by Jong -1;
                            else
                                byTemp = (byte)0xFD;	//by Jong	-3;
                            byTemp += RDCorner_U1White();
                            if ((byte)byTemp > 0)
                                cScore += (byTemp & 0xff);
                            break;
                        case 0x8002:
                            if ((m_Engine.m_wNearby & 0x1000) != 0)
                                byTemp = (byte)0xFE;	//by Jong	-2;
                            else if ((m_Engine.m_wNearby & 4) != 0)
                                byTemp = (byte)0xFF;	//by Jong	-1;
                            else
                                byTemp = (byte)0xFD;	//by Jong	-3;
                            byTemp += LDCorner_U1White();
                            if ((byte)byTemp > 0)
                                cScore += (byTemp & 0xff);
                    }
                }
                bContinue = true;
            }

            //---------------------------------------------------------------------------
            if ( bContinue )
            {
                RotatePattern();
                continue;
            }
        }
        return cScore;
    }


    short R2D2PosCode()
    {
        short	nPos = (short)(m_Engine.m_nMainPosi +
                m_Engine.m_cAroundTable[m_Engine.nAroundL2D2[m_Engine.m_nEntry - 1]]);

        if ((nPos < STARTPOS) || (nPos >= ENDPOS) || (m_Engine.m_byBoard[nPos] == INITVALUE))
            return 0;
        return	(short)(m_Engine.m_byPosBoard[nPos] & 0xff);
    }


    // Utility functions
    public static void OUTPUT(String strTitle, byte[] array, int nColCount)
    {
        //System.out.println("---" + strTitle + " : Start---");
        int nRowCount = array.length / nColCount;
        int r = array.length % nColCount;
        if ( r != 0 )
            nRowCount ++;

        int nIndex;
        String strValue;
        short nValue;

        for ( int i = 0; i < nRowCount; i ++ )
        {
            for ( int j = 0; j < nColCount; j ++ )
            {
                nIndex = i * nColCount + j;
                if ( nIndex >= array.length )
                    break;

                nValue = (short)(array[nIndex] & 0xff);
                strValue = Integer.toHexString(nValue);
                if ( nValue < 0x10 )
                    strValue = "0" + strValue;
                if ( j == (nColCount - 1) )
                    ;//System.out.println(strValue + " ");
                else
                    ;//System.out.print(strValue + " ");
            }
        }

        //System.out.println("---" + strTitle + " : End---");
    }

    public static void MEMSET(byte[] array, int value) {
        if (array == null)
            return;
        for (int i = 0; i < array.length; i++)
            array[i] = (byte) value;
    }

    public static void MEMSET(IGroup[] array, int value) {
        if (array == null)
            return;
        for (int i = 0; i < array.length; i++)
            array[i].setValue(value);
    }

    public static void MEMSET(byte[][] array, int value) {
        if (array == null)
            return;
        for (int i = 0; i < array.length; i++) {
            if (array[i] == null)
                continue;
            for (int j = 0; j < array[i].length; j++)
                array[i][j] = (byte) value;
        }
    }

    public static void MEMSET(short[] array, int value) {
        if (array == null)
            return;
        for (int i = 0; i < array.length; i++)
            array[i] = (short) value;
    }

    public static void MEMSET(int[] array, int value) {
        if (array == null)
            return;
        for (int i = 0; i < array.length; i++)
            array[i] = value;
    }

    public static void MEMCPY(Object dst, Object src, int length) {
        System.arraycopy(src, 0, dst, 0, length);
    }

    public static void MEMCPY(byte[][] dst, byte[][] src, int length)
    {
        // assert dst.length <= length : "Error: MEMCPY()- length is too large !"; // by KWJ : 2007-04-19

        for ( int i = 0; i < length; i ++ )
            for ( int j = 0; j < dst[i].length; j ++ )
            {
                dst[i][j] = src[i][j];
            }
    }

    public static void MEMCPY(short[][] dst, short[][] src, int length)
    {
        // assert dst.length <= length : "Error: MEMCPY()- length is too large !"; // by KWJ : 2007-04-19

        for ( int i = 0; i < length; i ++ )
            for ( int j = 0; j < dst[i].length; j ++ )
            {
                dst[i][j] = src[i][j];
            }
    }

    Random random = new Random();
    public int rand() {
        return random.nextInt();
    }

    boolean IsWhite(int A) {
        return ((A & 1) != 0);
    }

    byte rorb2(byte x) {
        //H.Joon-2007/03/07>>
        //byte bt = (byte) ( (x >> 2) & 0x3f);
        byte bt = (byte)((x & 0xff) >>> 2);
        //<<
        bt |= (x & 0xff) << 6;
        return bt;
    }

    short rolw2(short x) {
        short st = (short)((x & 0xffff) << 2);
        //H.Joon-2007/03/07>>
        //st |= (x >> 14) & 0x0003;
        st |= ((x & 0xffff) >>> 14);
        //<<
        return st;
    }

    short rorw4(short x) {
        //H.Joon-2007/03/07>>
        //short st = (short) ( (x >> 4) & 0x0fff);
        short st = (short)((x & 0xffff) >>> 4);
        //<<
        st |= ((x & 0xffff) << 12);
        return st;
    }

    byte rolb1(byte x) {
        byte bt = (byte)((x & 0xff) << 1);
        bt |= ((x & 0xff) >>> 7) & 0x01;
        return bt;
    }

    short rorw2(short x) {
        //H.Joon-2007/03/07>>
        //short st = (short) ( (x >> 2) & 0x3fff);
        short st = (short) ((x & 0xffff) >>> 2);
        //<<
        st |= ((x & 0xffff) << 14);
        return st;
    }

    byte rolb2(byte x) {
        byte bt = (byte) ((x & 0xff) << 2);
        //H.Joon-2007/03/07>>
        //bt |= (x >> 6) & 0x03;
        bt |= ((x & 0xff) >>> 6);
        //<<
        return bt;
    }

    short rolw4(short x) {
        short st = (short) ((x & 0xffff) << 4);
        //H.Joon-2007/03/07>>
        //st |= (x >> 12) & 0x000f;
        st |= ((x & 0xffff) >>> 12);
        //<<
        return st;
    }

    public static short LOWORD(int dwValue) {
        return (short) (dwValue & 0x0ffff);
    }

    public static short HIWORD(int dwValue) {
        //H.Joon-2007/03/07>>
        return (short) ( (dwValue >>> 16) & 0x0ffff);
        //return (short)((dwValue  & 0xffffffff) >>> 16);
        //<<
    }

    public static byte LOBYTE(short wValue) {
        return (byte) (wValue & 0x0ff);
    }

    public static byte HIBYTE(short wValue) {
        //H.Joon-2007/03/07>>
        //return (byte) ( (wValue >> 8) & 0x0ff);
        return (byte) ((wValue & 0xffff) >>> 8);
        //<<
    }

//    public static short MAKEWORD(byte bLow, byte bHigh) {
//        return (short) ((bHigh & 0xff) << 8 | bLow);
//    }

    public static short MAKEWORD(int bLow, int bHigh) {
        return (short) (bHigh << 8 | bLow);
    }

    class JPadukEngine {
        boolean m_bStop;
        boolean m_bFirstMove;
        short m_nMainPosition;
        byte m_byMask;
        short m_nOppScoreBoard[], m_nMyScoreBoard[];
        short m_wKeima;
        short m_wOKeima;
        short m_wNearby;
        short m_wIKenDKos;
        byte m_byAttach;
        byte m_byKosumi;
        byte m_byKeima1;
        byte m_byKeima2;
        byte m_byIKen;
        byte m_byNiKen;
        byte m_byDKosumi;
        short m_nMainPosi;
        short m_nPosCode;
        byte m_cBaseScore;
        short m_nEntry;
        byte m_byWhereCall;
        short m_nIniScore;
        short m_nRotCount;
        byte m_byPat[] = new byte[9];
        short m_nScoreBase;
        boolean g_bFlag;
        byte g_byTwoPat;
        short m_nPos1;
        short m_nPos2;
        short m_nPos3;
        short m_nNewTerritory;
        byte m_byExpressBoard[] = new byte[421];
        short m_nTurn;
        short m_nMan;
        short m_nGameStatus;
        short m_nBoardX, m_nBoardY;
        short m_nMainPos;
        short m_nTotal;
        short nEvaluCount;
        short nBoardScoreCtrl;
        short m_nGameLevel;
        short m_nComStoneColor;
        short m_nIniStoneCount;
        short m_nBlackDeadCount;
        short m_nWhiteDeadCount;
        boolean m_bFindMove;
        short m_wPreviousHumanStonePos;
        short m_wPreviousComputerStonePos;
        boolean m_bIsInControl;
        short m_nDeadStonePosBuf[] = new short[360];
        short m_nStoneCounter;
        short m_nStoreWeight;
        byte m_byBoard[] = new byte[421];
        byte m_byTempBoard[] = new byte[421];
        short m_nBlackStoneBoard[] = new short[421];
        short m_nWhiteStoneBoard[] = new short[421];
        byte m_byLiberties[] = new byte[MAX_STRINGCOUNT];
        byte m_byTempLiberties[] = new byte[MAX_STRINGCOUNT];
        //        byte m_byStoneCount[] = new byte[MAX_STRINGCOUNT];
        short m_nStoneCount[] = new short[MAX_STRINGCOUNT];
        //        byte m_byTempStoneCount[] = new byte[MAX_STRINGCOUNT];
        short m_nTempStoneCount[] = new short[MAX_STRINGCOUNT];
        short m_wStatus[] = new short[MAX_STRINGCOUNT];
        short m_wTempStatus[] = new short[MAX_STRINGCOUNT];
        byte m_byStoneColor;
        short m_nPaePos;
        short m_nTempPaePos;
        short m_nSavePaePos;
        short m_nBoardSize;
        short m_nTempBoardPos;
        byte m_byNewLiberties;
        short m_byStrNum;
        byte m_bySameBuf[] = new byte[4];
        byte m_bySameLiberties[] = new byte[4];
        byte m_byDifferBuf[] = new byte[4];
        byte m_byDifferLiberties[] = new byte[4];
        short m_nSCount;
        short m_nDCount;
        boolean m_bDataUpdate;
        byte m_byLocalPattern[][] = new byte[421][9];
        byte m_byTempLocalPattern[][] = new byte[421][9];
        boolean m_bLocalPatternUpdate;
        byte m_byPosBoard[] = new byte[421];
        int m_lBitBoard[] = new int[421];
        short m_nComStonePos;
        byte m_cWeightBoard[] = new byte[421];
        byte m_cTempWeightBoard[] = new byte[421];
        short m_nComStoneWeight1;
        short m_nComStoneWeight2;
        byte m_cAreaBoard[] = new byte[421];
        byte m_cTempAreaBoard[] = new byte[421];
        boolean m_bMoveFlag;
        byte m_byNewStringNumber;
        short m_wWhiteTSize;
        short m_wTempWhiteTSize;
        short m_wBlackTSize;
        short m_wTempBlackTSize;
        short m_nDifOfTerritory;
        short m_nTempDifOfTerritory;
        short m_nDifOfTwoT9;
        byte m_byGroupCount;
        byte m_byWhiteGroupCount;
        byte m_byTempWhiteGroupCount;
        byte m_byBlackGroupCount;
        byte m_byTempBlackGroupCount;
        short m_cWhiteCountChange;
        short m_cBlackCountChange;
        short m_nWhiteTChange;
        short m_nBlackTChange;
        short m_wWhiteTSize9;
        short m_wBlackTSize9;
        short m_nChangedTSize;
        short m_byPotentialWallPos[] = new short[56];
        short m_pTempArea[] = new short[SIMULMEMORYOFONESET + 0x400];
        short m_pResultArea[] = new short[MAXSIMULRESULTS + 1];
        short m_pSimulArea1[];
        short m_pSimulArea[] = new short[MAXSIMULDATAS];
        int m_nCurrUnit;
        short m_wMemOfSet, m_wSimulEnd, m_wPreSimulEnd, m_wCurrEnd,
                m_wResultCurr;
        short m_wResultInSecond[] = new short[MAX_STRINGCOUNT];
        short m_wResultInFirst[] = new short[MAX_STRINGCOUNT];
        short m_wSetInSecond[] = new short[MAX_STRINGCOUNT];
        short m_wSetInFirst[] = new short[MAX_STRINGCOUNT];
        short m_nDepthCrit, m_nMaxSimulPoints;
        byte m_byMarkedBoard[] = new byte[421];
        byte m_byLastLibs[] = new byte[MAX_STRINGCOUNT];
        //        byte m_byLastStns[] = new byte[MAX_STRINGCOUNT];
        short m_nLastStns[] = new short[MAX_STRINGCOUNT];
        short m_wBackPaePos;
        short m_nBackDeadStoneCount;
        byte m_byBackBoard[] = new byte[421];
        byte m_byBackLibs[] = new byte[MAX_STRINGCOUNT];
        //        byte m_byBackStns[] = new byte[MAX_STRINGCOUNT];
        short m_nBackStns[] = new short[MAX_STRINGCOUNT];
        short m_wBackStatus[] = new short[MAX_STRINGCOUNT];
        byte m_cGoodTimes[] = new byte[421];
        short m_nOutCall, m_nReflexMax, m_nMaxDepth;
        short m_wMoveDis;
        short m_wTrackSrc;
        byte m_cSimulStatus, m_cInfo;
        short m_wHuboPoint;
        short m_nHuboScore;
        short m_wOppPoint, m_wPoint1, m_wPoint2, m_wAttackPt, m_wDefensePt;
        short m_nOneLibStrs, m_nStnsOfRelStrs, m_nAttachedStrs, m_nProfitStrs;
        short m_nDepth, m_nLibsLimit;
        short m_wCurrLimit, m_wAssignLimit;
        byte m_byColor, m_byStr1, m_byStr2;
        byte m_byPeriStr[] = new byte[MAX_PERISTRS],
                m_byTemp[] = new byte[MAX_PERISTRS],
                m_byTemp1[] = new byte[MAX_PERISTRS];
        byte m_byAttachedStr[] = new byte[MAX_STRINGCOUNT];
        short m_wEmptyPoint[] = new short[MAX_LIBERTIES];
        short m_nNewLibs[] = new short[MAX_LIBERTIES];
        short m_nScoredPoints, m_nScore[] = new short[MAX_SCOREDPOINTS];
        byte m_byGroupBoard[] = new byte[421];
        byte m_byTempGroupBoard[] = new byte[421];
        short m_nTempGroupCount;
        byte m_byBitGroupRelInfo[] = new byte[800];
        byte m_byTempBitGroupRelInfo[] = new byte[800];
        GroupRelation m_stGroup[] = new GroupRelation[50];
        GroupRelation m_stTempGroup[] = new GroupRelation[50];
        byte m_byNewGroupNumber;
        short m_nTotalGroupCount;
        short m_wCorrectStatus[] = new short[MAX_STRINGCOUNT];
        byte m_nCorrectWeight[] = new byte[421];
        boolean m_bMoveDataFlag;
        boolean m_bInfo10Flag;
        short m_wDifBackUp;
        short m_nCount;
        short m_nAddPos[] = new short[0x20];
        byte m_byInfo5;
        byte m_byInfo9;
        byte m_byGrpNum;
        short m_nFoundPos[] = new short[0x20];
        byte m_byProp[] = new byte[0x20];
        byte m_byArea[] = new byte[0x20];
        byte m_byPos[] = new byte[0x20];
        short m_nCountOfFoundPos;
        short m_nFirstPos;
        short m_nLastPos;
        short m_nSumOfHomeCandiX;
        short m_nSumOfHomeCandiY;
        short m_nMaxOfHomeCandiX;
        short m_nMaxOfHomeCandiY;
        short m_nMinOfHomeCandiX;
        short m_nMinOfHomeCandiY;
        short m_nHomeCandiX[] = new short[0x20];
        short m_nHomeCandiY[] = new short[0x20];
        short m_nFuncControlFlag;
        byte m_byHIResult;
        byte m_byLOResult;
        short m_wCtrlGroupNum;
        byte m_byTotalInterrelCount;

        InterrelGroup m_stInterrelGroup[] = new InterrelGroup[25];

        //byte[] m_pbyTmpBitGroupRelAdr;
        int m_pbyTmpBitGroupRelAdr;
        byte m_bySurGroupNumber[] = new byte[8];
        byte m_bySurGrpOf11[] = new byte[0x8];
        short m_n11GrpCount;
        byte m_byBufForOtherSurG[] = new byte[0x500];

        short m_TempStringStateArea[] = new short[128];
        //        short m_TempWeightTableArea[] = new short[421];
        byte m_TempWeightTableArea[] = new byte[421];
        short m_nDifBackUp;

        DIST m_Dist[] = new DIST[] {new DIST(), new DIST(), new DIST(), new DIST()};
        byte[] m_pPattData;

        //const
        byte byStandardBoard[];
        byte AroundPointPosTable[];
        byte byInfo6_3[];
        byte byConstExtPoss[];
        short MulValue[];
        short m_wGIniStonePos[][];
        short nNeighbor[];
        short nStatusOrder[];
        short nScrOfPos0[];
        short nScrOfPos1[];
        short nScrOfPos2[];
        short nScrOfPos3[];
        short nScrOfPos4[];
        short nScrOfPos5[];
        short nScrOfPos6[];
        short nScrOfPos7[];
        short nScrOfPos8[];
        short nScrOfPos9[];
        short nScrOfPosa[];
        short nScrOfPosb[];
        short nScrOfPosc[];
        short nScrOfPosd[];
        short nScrOfPose[];
        short nScrOfPosf[];
        short nScrOfPos10[];
        short nScrOfPos11[];
        short nScrOfPos12[];
        short nScrOfPos13[];
        short nScrOfPos14[];
        short nScrOfPos15[];
        short nScrOfPos16[];
        short nScrOfPos17[];
        short nScrOfPos18[];
        short nScrOfPos19[];
        short nScrOfPos1a[];
        short nScrOfPos1b[];
        short nScrOfPos1c[];
        short nScrOfPos1d[];
        short nScrOfPos1e[];
        short nScrOfPos1f[];
        short nScrOfPos20[];
        short nScrOfPos21[];
        short nScrOfPos22[];
        short nScrOfPos23[];

        short nConstSurStonePos[];
        short[][] pnScreeningPoint; //[][36]
        short ConstStoneBoard[];
        byte byG_BCBoard[];
        byte byStandardBoard1[];
        byte byStandardWeightBoard[];
        byte m_cAroundTable[];
        short WhereCall;
        short nAroundL1[];
        short nAroundL2[];
        short nAroundL3[];
        short nAroundL1D1[];
        short nAroundL2D2[];
        short nAroundR1U2[];
        short nAroundL1U2[];
        ///////////////////
        short m_nBoardPos;
        byte m_byTurnColor;
        short m_nDeadStoneCount;
        short m_nDeadPosbufIndex;
        boolean m_bChangedGameStatus;

        CANDIDATA m_Candi[] = new CANDIDATA[MAXCANDINUM + 1];

        short m_nFindMoveStatus;
        short m_nPrevWeight;
        byte m_byControlFlag;
        byte m_cComAverageWeight;

        short m_nTempDeadStoneCount;
        short m_nOldDeadCount;
        short m_nComScore;
        byte m_cAverageWeight;
        boolean m_bReStart;
        short m_nProGameStatus;

        JPadukEngine() {
            /*
            m_nMainPosition = 0;
            m_byMask = 0;
            m_nOppScoreBoard = null;
            m_nMyScoreBoard = null;
            m_wKeima = 0;
            m_wOKeima = 0;
            m_wNearby = 0;
            m_wIKenDKos = 0;
            m_byAttach = 0;
            m_byKosumi = 0;
            m_byKeima1 = 0;
            m_byKeima2 = 0;
            m_byIKen = 0;
            m_byNiKen = 0;
            m_byDKosumi = 0;
            m_nMainPosi = 0;
            m_nPosCode = 0;
            m_cBaseScore = 0;
            m_nEntry = 0;
            m_byWhereCall = 0;
            m_nIniScore = 0;
            m_nRotCount = 0;
            MEMSET( m_byPat, 0 );
            m_nScoreBase = 0;
            g_bFlag = false;
            g_byTwoPat = 0;
            m_nPos1 = 0;
            m_nPos2 = 0;
            m_nPos3 = 0;
            m_nNewTerritory = 0;
            MEMSET( m_byExpressBoard, 0 );
            m_nTurn = 0;
            m_nMan = 0;
            m_nGameStatus = 0;
            m_nBoardX = 0; m_nBoardY = 0;
            m_nMainPos = 0;
            m_nTotal = 0;
            nEvaluCount = 0;
            nBoardScoreCtrl = 0;
            m_nGameLevel = 0;
            m_nComStoneColor = 0;
            m_nIniStoneCount = 0;
            m_nBlackDeadCount = 0;
            m_nWhiteDeadCount = 0;
            m_bFindMove = false;
            m_wPreviousHumanStonePos = 0;
            m_wPreviousComputerStonePos = 0;
            m_bIsInControl = false;
            MEMSET( m_nDeadStonePosBuf, 0 );
            m_nStoneCounter = 0;
            m_nStoreWeight = 0;
            MEMSET( m_byBoard, 0 );
            MEMSET( m_byTempBoard, 0 );
            MEMSET( m_nBlackStoneBoard, 0 );
            MEMSET( m_nWhiteStoneBoard, 0 );
            MEMSET( m_byLiberties, 0 );
            MEMSET( m_byTempLiberties, 0 );
            MEMSET( m_nStoneCount, 0 );
            MEMSET( m_byTempStoneCount, 0 );
            MEMSET( m_wStatus, 0 );
            MEMSET( m_wTempStatus, 0 );
            m_byStoneColor = 0;
            m_nPaePos = 0;
            m_nTempPaePos = 0;
            m_nSavePaePos = 0;
            m_nBoardSize = 0;
            m_nTempBoardPos = 0;
            m_byNewLiberties = 0;
            m_byStrNum = 0;
            MEMSET( m_bySameBuf, 0 );
            MEMSET( m_bySameLiberties, 0 );
            MEMSET( m_byDifferBuf, 0 );
            MEMSET( m_byDifferLiberties, 0 );
            m_nSCount = 0;
            m_nDCount = 0;
            m_bDataUpdate = false;
            MEMSET( m_byLocalPattern, 0 );
            MEMSET( m_byTempLocalPattern, 0 );
            m_bLocalPatternUpdate = false;
            MEMSET( m_byPosBoard, 0 );
            MEMSET( m_lBitBoard, 0 );
            m_nComStonePos = 0;
            MEMSET( m_cWeightBoard, 0 );
            MEMSET( m_cTempWeightBoard, 0 );
            m_nComStoneWeight1 = 0;
            m_nComStoneWeight2 = 0;
            MEMSET( m_cAreaBoard, 0 );
            MEMSET( m_cTempAreaBoard, 0 );
            m_bMoveFlag = false;
            m_byNewStringNumber = 0;
            m_wWhiteTSize = 0;
            m_wTempWhiteTSize = 0;
            m_wBlackTSize = 0;
            m_wTempBlackTSize = 0;
            m_nDifOfTerritory = 0;
            m_nTempDifOfTerritory = 0;
            m_nDifOfTwoT9 = 0;
            m_byGroupCount = 0;
            m_byWhiteGroupCount = 0;
            m_byTempWhiteGroupCount = 0;
            m_byBlackGroupCount = 0;
            m_byTempBlackGroupCount = 0;
            m_cWhiteCountChange = 0;
            m_cBlackCountChange = 0;
            m_nWhiteTChange = 0;
            m_nBlackTChange = 0;
            m_wWhiteTSize9 = 0;
            m_wBlackTSize9 = 0;
            m_nChangedTSize = 0;
            MEMSET( m_byPotentialWallPos, 0 );
            MEMSET( m_pTempArea, 0 );
            MEMSET( m_pResultArea, 0 );
            m_pSimulArea1 = 0;
            MEMSET( m_pSimulArea, 0 );
            m_nCurrUnit = 0;
            m_wMemOfSet = 0; m_wSimulEnd = 0; m_wPreSimulEnd = 0; m_wCurrEnd = 0;
            m_wResultCurr = 0;
            MEMSET( m_wResultInSecond, 0 );
            MEMSET( m_wResultInFirst, 0 );
            MEMSET( m_wSetInSecond, 0 );
            MEMSET( m_wSetInFirst, 0 );
            m_nDepthCrit = 0; m_nMaxSimulPoints = 0;
            MEMSET( m_byMarkedBoard, 0 );
            MEMSET( m_byLastLibs, 0 );
            MEMSET( m_nLastStns, 0 );
            m_wBackPaePos = 0;
            m_nBackDeadStoneCount = 0;
            MEMSET( m_byBackBoard, 0 );
            MEMSET( m_byBackLibs, 0 );
            MEMSET( m_byBackStns, 0 );
            MEMSET( m_wBackStatus, 0 );
            MEMSET( m_cGoodTimes, 0 );
            m_nOutCall = 0; m_nReflexMax = 0; m_nMaxDepth = 0;
            m_wMoveDis = 0;
            m_wTrackSrc = 0;
            m_cSimulStatus = 0; m_cInfo = 0;
            m_wHuboPoint = 0;
            m_nHuboScore = 0;
            m_wOppPoint = 0; m_wPoint1 = 0; m_wPoint2 = 0;
            m_wAttackPt = 0; m_wDefensePt = 0;
            m_nOneLibStrs = 0; m_nStnsOfRelStrs = 0;
            m_nAttachedStrs = 0; m_nProfitStrs = 0;
            m_nDepth = 0; m_nLibsLimit = 0;
            m_wCurrLimit = 0; m_wAssignLimit = 0;
            m_byColor = 0; m_byStr1 = 0; m_byStr2 = 0;
            MEMSET( m_byPeriStr, 0 );
            MEMSET( m_byTemp, 0 );
            MEMSET( m_byTemp1, 0 );
            MEMSET( m_byAttachedStr, 0 );
            MEMSET( m_wEmptyPoint, 0 );
            MEMSET( m_nNewLibs, 0 );
            m_nScoredPoints = 0;
            MEMSET( m_nScore, 0 );
            MEMSET( m_byGroupBoard, 0 );
            MEMSET( m_byTempGroupBoard, 0 );
            m_nTempGroupCount = 0;
            MEMSET( m_byBitGroupRelInfo, 0 );
            MEMSET( m_byTempBitGroupRelInfo, 0 );
            int i;
            for( i = 0 ; i < m_stGroup.length; i++ ) {
                m_stGroup[i] = new GroupRelation();
            }
            for( i = 0 ; i < m_stTempGroup.length; i++ ) {
                m_stTempGroup[i] = new GroupRelation();
            }
            m_byNewGroupNumber = 0;
            m_nTotalGroupCount = 0;
            MEMSET( m_wCorrectStatus, 0 );
            MEMSET( m_nCorrectWeight, 0 );
            m_bMoveDataFlag = false;
            m_bInfo10Flag = false;
            m_wDifBackUp = 0;
            m_nCount = 0;
            MEMSET( m_nAddPos, 0 );
            m_byInfo5 = 0;
            m_byInfo9 = 0;
            m_byGrpNum = 0;
            MEMSET( m_nFoundPos, 0 );
            MEMSET( m_byProp, 0 );
            MEMSET( m_byArea, 0 );
            MEMSET( m_byPos, 0 );
            m_nCountOfFoundPos = 0;
            m_nFirstPos = 0;
            m_nLastPos = 0;
            m_nSumOfHomeCandiX = 0;
            m_nSumOfHomeCandiY = 0;
            m_nMaxOfHomeCandiX = 0;
            m_nMaxOfHomeCandiY = 0;
            m_nMinOfHomeCandiX = 0;
            m_nMinOfHomeCandiY = 0;
            MEMSET( m_nHomeCandiX, 0 );
            MEMSET( m_nHomeCandiY, 0 );
            m_nFuncControlFlag = 0;
            m_byHIResult = 0;
            m_byLOResult = 0;
            m_wCtrlGroupNum = 0;
            m_byTotalInterrelCount = 0;

            for( i = 0 ; i < m_stInterrelGroup.length; i++ ) {
                m_stInterrelGroup[i] = new InterrelGroup();
            }

            //byte[] m_pbyTmpBitGroupRelAdr;
            m_pbyTmpBitGroupRelAdr = 0;
            MEMSET( m_bySurGroupNumber, 0 );
            MEMSET( m_bySurGrpOf11, 0 );
            m_n11GrpCount = 0;
            MEMSET( m_byBufForOtherSurG, 0 );

            MEMSET( m_TempStringStateArea, 0 );
            MEMSET( m_TempWeightTableArea, 0 );
            m_nDifBackUp = 0;

            m_pPattData = null;

//const
            byStandardBoard = null;
            AroundPointPosTable = null;
            byInfo6_3 = null;
            byConstExtPoss = null;
            MulValue = null;
            m_wGIniStonePos = null;
            nNeighbor = null;
            nStatusOrder = null;
            nScrOfPos0 = null;
            nScrOfPos1 = null;
            nScrOfPos2 = null;
            nScrOfPos3 = null;
            nScrOfPos4 = null;
            nScrOfPos5 = null;
            nScrOfPos6 = null;
            nScrOfPos7 = null;
            nScrOfPos8 = null;
            nScrOfPos9 = null;
            nScrOfPosa = null;
            nScrOfPosb = null;
            nScrOfPosc = null;
            nScrOfPosd = null;
            nScrOfPose = null;
            nScrOfPosf = null;
            nScrOfPos10 = null;
            nScrOfPos11 = null;
            nScrOfPos12 = null;
            nScrOfPos13 = null;
            nScrOfPos14 = null;
            nScrOfPos15 = null;
            nScrOfPos16 = null;
            nScrOfPos17 = null;
            nScrOfPos18 = null;
            nScrOfPos19 = null;
            nScrOfPos1a = null;
            nScrOfPos1b = null;
            nScrOfPos1c = null;
            nScrOfPos1d = null;
            nScrOfPos1e = null;
            nScrOfPos1f = null;
            nScrOfPos20 = null;
            nScrOfPos21 = null;
            nScrOfPos22 = null;
            nScrOfPos23 = null;

            nConstSurStonePos = null;
            pnScreeningPoint = null;
            ConstStoneBoard = null;
            byG_BCBoard = null;
            byStandardBoard1 = null;
            byStandardWeightBoard = null;
            m_cAroundTable = null;
            WhereCall = 0;
            nAroundL1 = null;
            nAroundL2 = null;
            nAroundL3 = null;
            nAroundL1D1 = null;
            nAroundL2D2 = null;
            nAroundR1U2 = null;
            nAroundL1U2 = null;
///////////////////
            m_nBoardPos = 0;
            m_byTurnColor = 0;
            m_nDeadStoneCount = 0;
            m_nDeadPosbufIndex = 0;
            m_bChangedGameStatus = false;

            for( i = 0 ; i < m_Candi.length ; i++ ) {
                m_Candi[i] = new CANDIDATA();
            }

            m_nFindMoveStatus = 0;
            m_nPrevWeight = 0;
            m_byControlFlag = 0;
            m_cComAverageWeight = 0;

            m_nTempDeadStoneCount = 0;
            m_nOldDeadCount = 0;
            m_nComScore = 0;
            m_cAverageWeight = 0;
            m_bReStart = false;
            m_nProGameStatus = 0;
            */
        }
    }

    public static final byte IS_BLACK = 2;
    public static final byte IS_WHITE = 1;
    public static final byte IS_INITIAL = 0;
    public static final byte IS_GAME = 1;
    public static final byte IS_PASS = 2;
    public static final byte IS_GAMEOVER = 3;
    public static final byte IS_NOTPLACE = -1;
    public static final byte IS_COUNTOVER = -2;
    public static final byte IS_OK = 0;
    public static final byte IS_OUTBOARD = -3;
    public static final byte IS_PRESTONE = -4;
    public static final byte IS_PAEPOS = -5;
    public static final byte IS_DANSU = -6;
    public static final byte IS_NOSTONE = -7;
    short IniStone0 = 0;
    public static final short M_PASS = 0x2000; // by KWJ : 2007-04-19

    final short STARTPOS = 21;
    final short ENDPOS = 400;
    final short MAX_STRINGCOUNT = 128;
    final short MAX_STONECOUNT = 127;
    final byte INITVALUE = -16; //0xf0

    final byte UP_MASK = 8;
    final byte DOWN_MASK = 4;
    final byte LEFT_MASK = 2;
    final byte RIGHT_MASK = 1;
    final byte IS_ATARI = -6;
    final byte SIZE9 = 9;
    final byte SIZE13 = 13;
    final byte SIZE19 = 19;
    final int MAXSIMULDATAS = 0xf000;
    final int MAXSIMULRESULTS = 0x100;
    final short SIMULMEMORYOFONESET = 0x2000;
    final int SIMULMEMORYOFONEUNIT = 0x200;
    final String PDK_MARK = "SilverPaduk";
    final String PDK_MARK20 = "SPaduk2.0";
    final byte BOARDSIZE9 = 9;
    final byte BOARDSIZE13 = 13;
    final byte BOARDSIZE19 = 19;
    final byte IS_HUMAN_HUMAN = 0;
    final byte MAX_GAMELEVEL = 9;
    final byte MIN_MARGIN = 2;
    final short MIN_X = 300;
    final short MIN_Y = 300;
    final byte STONE_R_MAX = 24;
    final byte R_DEC_COUNT = 1;
    final byte STONE_R_MIN = 5;
    final byte STONE_WIDTH = 64;
    final short ID_DB_TIMEDEAD = 526;
    final short MAX_BUFSIZE = 3000;
    final short M_BOARD = 0x2020;
    final int COLOR_MASK = 0x8000;
    final int DEAD_MASK = 0x0080;
    final int POS_MASK = 0x3f1f;
    final int DEAD_ID = 0xff00;
    final short ID_TIMER = 0x3fff;
    final short ELAPSE_TIME = 500;
    final byte IS_START = 1;
    final byte IS_MIDDLE = 2;
    final byte IS_END = 3;

    final byte IS_LOW = 6;
    final byte IS_MID = 7;
    final byte IS_HIGH = 8;
    final byte IS_HIGHEST = 9;

    final byte TK_MAIN = 0;
    final byte TK_SIMULADD = 1;
    final byte TK_SIMUL123 = 2;
    final byte TK_SIMUL456 = 3;
    final byte TK_GROUP = 4;
    final byte TK_POSSCORE = 5;
    final byte TK_PATTERN1 = 6;
    final byte TK_PATTERN2 = 7;

    final short BLACK = 2;
    final short WHITE = 1;
    final short PS_MINI = -2;
    final short PS_SEL = 0xfe;
    final short PS_POS = 0xff;
    final short PS_CRISIS = 0;
    final short PS_SIMUL = 1;

    final byte MAX_LIBERTIES = 8;
    final byte MAX_PERISTRS = 20;
    final byte MAX_SCOREDPOINTS = 16;
    final byte PARENT_BACKUP = 0;
    final byte CHILD_BACKUP = 1;
    final byte SIMUL_INSECOND_MANYSEP = 0;
    final byte SIMUL_INFIRST_ONESEP = 1;
    final byte SIMUL_INFIRST_MANYSEP = 2;
    final byte ONESEP_START = 0;
    final byte ONESEP_REFLEX = 1;
    final byte MANYSEP = 2;
    final byte IS_SECOND = 0;
    final byte IS_FIRST = 1;

    final int MAXCANDINUM = 6;
    final int IS_PAUSE_REQ = 0xfe;

    final byte FM_FINDMOVE = 1;

    final short M_STOP = 0x4040;

    final byte LIBERTIES = 0;
    final byte STATUS = 1;
    final byte STRDEAD = 2;
    final byte WHOSEINFLUENCE = 3;
    final byte INFLUENCE = 4;
    final byte LAYER = 5;
    final byte WHERECALL = 6;

    final byte SAME = 0;
    final byte NOSAME = 1;
    final byte BIG = 2;
    final byte SMALL = 3;

// PadukPro.h: CPadukPro
//
//////////////////////////////////////////////////////////////////////

    /*typedef enum tag_AROUNDPOINTPOS {
        L1, U1, R1, D1, L1D1, L1U1, R1U1, R1D1,
        L2, U2, R2, D2, L2D1, L2U1, L1U2, R1U2, R2U1, R2D1, R1D2, L1D2,
        L3, U3, R3, D3, L3D1, L3U1, L1U3, R1U3, R3U1, R3D1, R1D3, L1D3,
        L2D2, L2U2, R2U2, R2D2,
        L4, U4, R4, D4, L4D1, L4U1, L1U4, R1U4, R4U1, R4D1, R1D4, L1D4,
        L3D2, L3U2, L2U3, R2U3, R3U2, R3D2, R2D3, L2D3
       }
        AROUNDPOINTPOS;*/

    final byte L1 = 0;
    final byte U1 = 1;
    final byte R1 = 2;
    final byte D1 = 3;
    final byte L1D1 = 4;
    final byte L1U1 = 5;
    final byte R1U1 = 6;
    final byte R1D1 = 7;
    final byte L2 = 8;
    final byte U2 = 9;
    final byte R2 = 10;
    final byte D2 = 11;
    final byte L2D1 = 12;
    final byte L2U1 = 13;
    final byte L1U2 = 14;
    final byte R1U2 = 15;
    final byte R2U1 = 16;
    final byte R2D1 = 17;
    final byte R1D2 = 18;
    final byte L1D2 = 19;
    final byte L3 = 20;
    final byte U3 = 21;
    final byte R3 = 22;
    final byte D3 = 23;
    final byte L3D1 = 24;
    final byte L3U1 = 25;
    final byte L1U3 = 26;
    final byte R1U3 = 27;
    final byte R3U1 = 28;
    final byte R3D1 = 29;
    final byte R1D3 = 30;
    final byte L1D3 = 31;
    final byte L2D2 = 32;
    final byte L2U2 = 33;
    final byte R2U2 = 34;
    final byte R2D2 = 35;
    final byte L4 = 36;
    final byte U4 = 37;
    final byte R4 = 38;
    final byte D4 = 39;
    final byte L4D1 = 40;
    final byte L4U1 = 41;
    final byte L1U4 = 42;
    final byte R1U4 = 43;
    final byte R4U1 = 44;
    final byte R4D1 = 45;
    final byte R1D4 = 46;
    final byte L1D4 = 47;
    final byte L3D2 = 48;
    final byte L3U2 = 49;
    final byte L2U3 = 50;
    final byte R2U3 = 51;
    final byte R3U2 = 52;
    final byte R3D2 = 53;
    final byte R2D3 = 54;
    final byte L2D3 = 55;

    final byte c_byInvY[] = { //37
            0, 3, 2, 1, 4, 8, 7, 6, 5, 11, 10, 9, 12, 18, 17, 16, 15, 14, 13, 20, 19,
            23, 22, 21, 24, 30, 29, 28, 27, 26, 25, 32, 31, 36, 35, 34, 33
    };

    final byte c_byRot[] = { //Left  37
            0, 4, 1, 2, 3, 8, 5, 6, 7, 12, 9, 10, 11, 19, 20, 13, 14, 15, 16, 17, 18,
            24, 21, 22, 23, 31, 32, 25, 26, 27, 28, 29, 30, 36, 33, 34, 35
    };

    final byte c_byInvOperater[] = { //16
            0, 1, 3, 2, 4, 5, 6, 7, 15, 15, 15, 15, 15, 15, 15, 15
    };

    final byte c_ptAroundPos[] = { //56Points
        /*L1*/ -1, 0, /*U1*/ 0, -1, /*R1*/ 1, 0, /*D1*/ 0, 1,
        /*L1D1*/-1, 1, /*L1U1*/ -1, -1, /*R1U1*/ 1, -1, /*R1D1*/ 1, 1,
        /*L2*/-2, 0, /*U2*/ 0, -2, /*R2*/ 2, 0, /*D2*/ 0, 2,
        /*L2D1*/-2, 1, /*L2U1*/ -2, -1, /*L1U2*/ -1, -2, /*R1U2*/ 1, -2,
        /*R2U1*/2, -1, /*R2D1*/ 2, 1, /*R1D2*/ 1, 2, /*L1D2*/ -1, 2,
        /*L3*/-3, 0, /*U3*/ 0, -3, /*R3*/ 3, 0, /*D3*/ 0, 3,
        /*L3D1*/-3, 1, /*L3U1*/ -3, -1, /*L1U3*/ -1, -3, /*R1U3*/ 1, -3,
        /*R3U1*/3, -1, /*R3D1*/ 3, 1, /*R1D3*/ 1, 3, /*L1D3*/ -1, 3,
        /*L2D2*/-2, 2, /*L2U2*/ -2, -2, /*R2U2*/ 2, -2, /*R2D2*/ 2, 2,
        /*L4*/-4, 0, /*U4*/ 0, -4, /*R4*/ 4, 0, /*D4*/ 0, 4,
        /*L4D1*/-4, 1, /*L4U1*/ -4, -1, /*L1U4*/ -1, -4, /*R1U4*/ 1, -4,
        /*R4U1*/4, -1, /*R4D1*/ 4, 1, /*R1D4*/ 1, 4, /*L1D4*/ -1, 4,
        /*L3D2*/-3, 2, /*L3U2*/ -3, -2, /*L2U3*/ -2, -3, /*R2U3*/ 2, -3,
        /*R3U2*/3, -2, /*R3D2*/ 3, 2, /*R2D3*/ 2, 3, /*L2D3*/ -2, 3
    };

    //    final byte sizeofSIMULMOVE = 3;
    final byte sizeofSIMULMOVE = 4;
    final byte sizeofSIMULRESULT = 2;
    final byte sizeofSIMULSET = 4; //
    final byte sizeofSIMULUNIT = 6; //
    final byte sizeofSIMULPOINT = 4; //
    final byte sizeofPATTUNIT = 24;

    final byte sizeofWORD = 2;
    final byte sizeofDWORD = 4;

    //H.Joon-2007/03/05>>
    short RetractStone(short wPoint)
    {
        byte	byStrNum;
        short	nStones;
        short   nTemp,nCount,i;

        m_Engine.m_nBoardPos = GetBoardPos( wPoint );

//	m_ptheJongSokControl->BackStone(11111);

        byStrNum = m_Engine.m_byBoard [m_Engine.m_nBoardPos];
        if(byStrNum == 0) return IS_NOSTONE;

        //m_nStoneCounter --;
        m_Engine.m_byLiberties[byStrNum & 0xff] = 0;
        m_Engine.m_byBoard[m_Engine.m_nBoardPos] = 0;
        DelStoneForPattern();
        m_Engine.m_bDataUpdate = true;
        UpdateNeighbouringString( byStrNum );

        nStones = 0;
        --m_Engine.m_nStoneCount[byStrNum & 0xff];

        if( m_Engine.m_nStoneCount[byStrNum & 0xff] == 0 )
            m_Engine.m_wStatus[byStrNum & 0xff] = (short)0xff00;
        else
        {
//		SAVE_SPOINT;
            nTemp = m_Engine.m_nBoardPos;

            m_Engine.m_wStatus[byStrNum & 0xff] &= 0xff00;
            for( m_Engine.m_nBoardPos = STARTPOS; m_Engine.m_nBoardPos < ENDPOS; m_Engine.m_nBoardPos++ )
            {
                if( m_Engine.m_byBoard[m_Engine.m_nBoardPos] != byStrNum )
                    continue;
                m_Engine.m_byBoard[m_Engine.m_nBoardPos] = 0;
                m_Engine.m_nDeadStonePosBuf[nStones++] = m_Engine.m_nBoardPos;
                if( --m_Engine.m_nStoneCount[byStrNum & 0xff] == 0 )
                {
                    //goto $Adr1;
                    break;
                }
                UpdateNeighbouringString( byStrNum );
            }
//$Adr1:
//		assert( nStones >= 1 );
            m_Engine.m_nBoardPos = m_Engine.m_nDeadStonePosBuf[--nStones];
            m_Engine.m_byBoard[m_Engine.m_nBoardPos] = byStrNum;
            m_Engine.m_nStoneCount[byStrNum & 0xff] = 1;

            if( m_Engine.m_byBoard [m_Engine.m_nBoardPos - 1] == 0 )
                m_Engine.m_byLiberties[byStrNum & 0xff]++;
            if( m_Engine.m_byBoard[m_Engine.m_nBoardPos + 1] == 0 )
                m_Engine.m_byLiberties[byStrNum & 0xff]++;
            if( m_Engine.m_byBoard [m_Engine.m_nBoardPos - 20] == 0 )
                m_Engine.m_byLiberties[byStrNum & 0xff]++;
            if( m_Engine.m_byBoard [m_Engine.m_nBoardPos + 20] == 0 )
                m_Engine.m_byLiberties[byStrNum & 0xff]++;

            for( i = (short)(nStones - 1); i >= 0; i-- )
            {
                m_Engine.m_nBoardPos = m_Engine.m_nDeadStonePosBuf[i];
                SetStone3( (byte)(( ( byStrNum & 1 ) + 1 ) ^ 3));
            }

//		LOAD_SPOINT;
            m_Engine.m_nBoardPos = nTemp;
        }
        m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] = 0;
        m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = 0;
        nCount = 0;
        nCount = UpdateDifferBuf( (short)(m_Engine.m_nBoardPos - 20), nCount );
        nCount = UpdateDifferBuf( (short)(m_Engine.m_nBoardPos + 20), nCount );
        nCount = UpdateDifferBuf( (short)(m_Engine.m_nBoardPos - 1), nCount );
        nCount = UpdateDifferBuf( (short)(m_Engine.m_nBoardPos + 1), nCount );
        m_Engine.m_nPaePos = 0;
        LoadTempArea();
        SetBit0_1();
        ExpressTempArea();
        SaveTempArea();

        return IS_OK;
    }

    short SetStone3( byte byStoneColor )
    {
        short nRet;

        m_Engine.m_bDataUpdate = true;
        m_Engine.m_bLocalPatternUpdate = false;
        nRet = CheckSettable();
        if( nRet == IS_OK )
        {
            m_Engine.m_byStoneColor = byStoneColor;
            return( SetStone0() );
        }
        return( nRet );
    }

    short UpdateDifferBuf(short nPos, short nCount )
    {
        short i;

        byte byStrNum = m_Engine.m_byBoard[nPos];

        if( m_Engine.m_byBoard[nPos] == INITVALUE ) return nCount;

        if( byStrNum == 0 ) return nCount;

        i = nCount;
        do
        {
            --i;
            if( i < 0 )
            {
                m_Engine.m_byDifferBuf[nCount] = byStrNum;
                m_Engine.m_byDifferLiberties[nCount] = m_Engine.m_byLiberties[byStrNum & 0xff];
                ++(nCount);
                return nCount;
            }
        }while( m_Engine.m_byDifferBuf[i] != byStrNum );

        return nCount;
    }

    public void Kernel_DelStone( short wPos )
    {
        short wPoint;

        if (wPos != M_PASS)
        {
            m_Engine.m_nBoardX = (short)((LOBYTE(wPos) & 0xff) - 1);
            m_Engine.m_nBoardY = (short)((HIBYTE(wPos) & 0xff) - 1);
            wPoint = (short)(((m_Engine.m_nBoardX & 0xffff) << 8) | m_Engine.m_nBoardY);
        }
        else
            return; // by KWJ : 2007-04-19
        // wPoint = wPos;
        RetractStone( wPoint );
    }

    public int Kernel_GetBlackDeadCount()
    {
        return m_Engine.m_nBlackDeadCount;
    }

    public void Kernel_GetBoard( byte[][] pbyBoard )
    {
        short i;
        short j;
        for (i = 0 ; i < 19; i++)
        {
            for (j = 0; j < 19; j++)
            {
                byte byColor = m_Engine.m_byBoard[(i + 1) * 20 + j + 1];
                if ((byColor == (byte)0xf0) || (byColor == 0))
                    byColor = 0;
                else if ((byColor & 0x01) != 0)
                    byColor = WHITE;
                else
                    byColor = BLACK;
                pbyBoard[i][j] = byColor;
            }
        }
    }

    public void Kernel_GetDeadStonePos(short[] wListDeadPos, short nCount)
    {
        int i, x, y;
        for (i = 0; i < nCount; i++)
        {
            x = m_Engine.m_nDeadStonePosBuf[i] % 20;//-1+1
            y = m_Engine.m_nDeadStonePosBuf[i] / 20;//-1+1
              wListDeadPos[i] = MAKEWORD(x, y);
        }
    }

    public short Kernel_GetPaePos()
    {
        return m_Engine.m_nPaePos;
    }

    public int	Kernel_GetWhiteDeadCount()
    {
        return m_Engine.m_nWhiteDeadCount;
    }

    public void Kernel_RecoveryStone(short wPoint, short nStoneColor)
    {
        if (wPoint == M_PASS)
            return;
        m_Engine.m_nBoardPos = (short)((LOBYTE(wPoint) & 0xff) + (HIBYTE(wPoint) & 0xff) * 20);

        m_Engine.m_byStrNum = 0;

        SetStone2( (byte)nStoneColor );

//	m_ptheJongSokControl->SetStone( nStoneColor);
        m_Engine.m_nBlackStoneBoard[m_Engine.m_nBoardPos] =
                m_Engine.m_nWhiteStoneBoard[m_Engine.m_nBoardPos] = 0;
        m_Engine.m_lBitBoard [m_Engine.m_nBoardPos] = 0;
        CountUnDelStones( nStoneColor );
//	CalculateAllScore(11111);

        SetBit0_1();

        MarkInArea();
        ExpressTempArea();
        SaveTempArea();
    }

    public void Kernel_SetDeadCount(int nBDeadCount, int nWDeadCount)
    {
        m_Engine.m_nBlackDeadCount = (short)nBDeadCount;
        m_Engine.m_nWhiteDeadCount = (short)nWDeadCount;
    }

    public final static int LEVEL0 = 0;
    public final static int LEVEL1 = 1;
    public final static int LEVEL2 = 2;
    public final static int LEVEL3 = 3;
    public final static int LEVEL4 = 4;
    public void	Kernel_SetLevel(int nLevel)
    {
        if (nLevel < LEVEL0)
            nLevel = LEVEL0;
        if (nLevel > LEVEL4)
            nLevel = LEVEL4;
        switch(nLevel)
        {
            case LEVEL0:
                nLevel = 1;
                m_dwLimitTime = 1000; // by KWJ : 2007-04-30
                break;
            case LEVEL1:
                nLevel = 2;
                m_dwLimitTime = 2000; // by KWJ : 2007-04-30
                break;
            case LEVEL2:
                nLevel = 3;
                m_dwLimitTime = 3000; // by KWJ : 2007-04-30
                break;
            case LEVEL3:
                nLevel = 5;
                m_dwLimitTime = 6000; // 2009-03-30 //6000; // by KWJ : 2007-04-30
                break;
            case LEVEL4:
            default:
                nLevel = 6;
                m_dwLimitTime = 10000; // 2009-03-30 //10000; // by KWJ : 2007-04-30
                break;
        }
        SetGameLevel( (short)nLevel );
        //m_Engine.m_nGameLevel = (short)nLevel;
    }


    public void	Kernel_SetPaePos( short wPaePos )
    {
        m_Engine.m_nPaePos = wPaePos;
    }

    public short Kernel_ComPlay( int nCase ,int nFlag, short[] nScore )
/// nCase
//		0 - human ; human
//		1 - human : computer
//		2 - computer ; human
// nFlag
//		1 - Standard
//		2 - Hint
    {
        int nTempComColor, nTempTurn, nTempMan;

        if (( nCase != 0 )&&( nFlag == 1 ))
        {
            ComputerPlayStone();

            nScore[0] = m_Engine.m_nComScore;

            if( m_Engine.m_nBoardX == 0x20 )
                return 0x2000;
            else
                return ((short)((((m_Engine.m_nBoardY + 1) & 0xff) << 8 ) |
                        (((m_Engine.m_nBoardX + 1) & 0xff))));
        }

        nTempComColor = m_Engine.m_nComStoneColor;
        nTempTurn = m_Engine.m_nTurn;
        nTempMan = m_Engine.m_nMan;

        if(( nCase != 0 )&&( nFlag == 2 ))
        {
            if( nCase == 1 )
            {
                m_Engine.m_nComStoneColor = IS_BLACK;
                m_Engine.m_nTurn = IS_BLACK;
                m_Engine.m_nMan = IS_WHITE;
            }
            else
            {
                m_Engine.m_nComStoneColor = IS_WHITE;
                m_Engine.m_nTurn = IS_WHITE;
                m_Engine.m_nMan = IS_BLACK;
            }
        }
        else
        {
            if( nFlag == 2 )
            {
                m_Engine.m_nComStoneColor = IS_BLACK;
                m_Engine.m_nTurn = IS_BLACK;
                m_Engine.m_nMan = IS_WHITE;
            }
            else
            {
                m_Engine.m_nComStoneColor = IS_WHITE;
                m_Engine.m_nTurn = IS_WHITE;
                m_Engine.m_nMan = IS_BLACK;
            }
        }

        ComputerPlayStone();

        m_Engine.m_nComStoneColor = (short)nTempComColor;
        m_Engine.m_nTurn = (short)nTempTurn;
        m_Engine.m_nMan = (short)nTempMan;

        if( m_Engine.m_nBoardX == 0x20 )
            return 0x2000;
        else
            return ((short)((((m_Engine.m_nBoardY + 1) & 0xff) << 8) | (((m_Engine.m_nBoardX + 1) & 0xff))));
    }

    public void Kernel_DeadInfo( short[] nBlack, short[] nWhite )
    {
        nWhite[0] = m_Engine.m_nBlackDeadCount;
        nBlack[0] = m_Engine.m_nWhiteDeadCount;
    }

    void ScoreInCutCase()
    {
        int	nGroupNum;
        int	i;
        byte	byStrNoMain, byStrNoTemp;
        byte	byGroupNoMain, byGroupNoTemp;
        byte	by11Main, by12Main, by11Temp, by12Temp, by4Main, by4Temp;
        int     nTemp;
        byte	byTemp;

        nGroupNum = (int) m_Engine.m_nTempGroupCount;

        if( nGroupNum == 0 )
            return;

        nGroupNum = Math.max( nGroupNum, m_Engine.m_nTotalGroupCount );
        for( i = 1; i <= nGroupNum; i ++ )
        {
            m_Engine.m_stGroup[i].nOtherSit = m_Engine.m_stTempGroup[i].nOtherSit = 0;
            m_Engine.m_stGroup[i].nOtherSumImp = m_Engine.m_stTempGroup[i].nOtherSumImp = 0;
        }

        m_Engine.m_wWhiteTSize9 = m_Engine.m_wBlackTSize9 = 0;
//#ifdef UPDATE
        m_Engine.m_nNewTerritory = 0;
//#else
//	m_nNewTerritory = m_nDifOfTerritory - m_nTempDifOfTerritory;
//#endif

        for( i = STARTPOS; i < ENDPOS; i ++ )
        {
            byStrNoMain = m_Engine.m_byBoard[i];
            byGroupNoMain = m_Engine.m_byGroupBoard[i];

            if( ( byStrNoMain == 0 ) || ( byGroupNoMain == 0 ) || ( ((byStrNoMain ^ byGroupNoMain) & 1) != 0 ) )
                continue;

            byStrNoTemp = m_Engine.m_byTempBoard[i];
            byGroupNoTemp = m_Engine.m_byTempGroupBoard[i];

            if( ( byStrNoTemp == 0 ) || ( byGroupNoTemp == 0 ) || ( ((byStrNoTemp ^ byGroupNoTemp) & 1) != 0) )
                continue;

            if( ((byGroupNoMain ^ byGroupNoTemp) & 1) != 0 )
                continue;

            by12Main = (byte)m_Engine.m_stGroup[byGroupNoMain].nOtherSumImp;
            by12Temp = (byte)m_Engine.m_stTempGroup[byGroupNoTemp].nOtherSumImp;

            if( (by12Main != 0) && (by12Temp != 0 ) )
                continue;

            by11Main = (byte)m_Engine.m_stGroup[byGroupNoMain & 0xff].nOtherSit;
            by11Temp = (byte)m_Engine.m_stTempGroup[byGroupNoTemp & 0xff].nOtherSit;
            by4Main = (byte)m_Engine.m_stGroup[byGroupNoMain & 0xff].nSituation;
            by4Temp = (byte)m_Engine.m_stTempGroup[byGroupNoTemp & 0xff].nSituation;

            if( by12Main != 0 )
            {
                nTemp = QuarterOfMul( by11Main, by12Main );
                byTemp = GetbyInfo10( byGroupNoMain, byGroupNoTemp, by12Main );
                nTemp = MulAndGetOf11A12( byGroupNoMain, byGroupNoTemp, by11Main, by4Temp, byTemp ) - nTemp;
            }
            else if( by12Temp != 0 )
            {
                nTemp = QuarterOfMul( by11Temp, by12Temp );
                byTemp = GetbyInfo10( byGroupNoMain, byGroupNoTemp, by12Temp );
                nTemp = MAGOf11A12InTemp( byGroupNoMain, byGroupNoTemp, by4Main, by11Temp, byTemp ) - nTemp;
            }
            else
            {
                if( ( by4Main == 0 ) && ( by4Temp == 0 ) )
                {
                    m_Engine.m_stGroup[byGroupNoMain & 0xff].nOtherSumImp =
                            m_Engine.m_stTempGroup[byGroupNoTemp & 0xff].nOtherSumImp = 0x80;
                    continue;
                }
                else
                {
                    byTemp = GetbyInfo10( byGroupNoMain, byGroupNoTemp, (byte)0 );
                    nTemp = MAGOf11A12InPlus( byGroupNoMain, byGroupNoTemp, by4Main, by4Temp, byTemp );
                }
            }
            ScoreSum( byGroupNoMain, nTemp );
        }

        nGroupNum = m_Engine.m_nTempGroupCount;

        for( i = 1; i <= nGroupNum; i ++ )
        {
            by4Temp = (byte)m_Engine.m_stTempGroup[i].nSituation;
            by12Temp = (byte)m_Engine.m_stTempGroup[i].nOtherSumImp;

            if( (by4Temp == 0) || (by12Temp != 0) )
                continue;

            m_Engine.m_stTempGroup[i].nOtherSumImp = 0x98;
            m_Engine.m_stTempGroup[i].nOtherSit = (short)(by4Temp & 0xff);
            ScoreSum( (byte)i, QuarterOfMul((byte)(-by4Temp), (byte)0x98) );
        }

        for( i = STARTPOS; i < ENDPOS; i ++ )
        {
            byStrNoMain = m_Engine.m_byBoard[i];
            byStrNoTemp = m_Engine.m_byTempBoard[i];

            if( (byStrNoTemp != 0) && ( (m_Engine.m_wTempStatus[byStrNoTemp & 0xff] & 0x08) != 0 ) )
            {
                if( byStrNoMain != 0 )
                {
                    byte byTempGrp;
                    if( (m_Engine.m_wStatus[byStrNoMain & 0xff] & 0x08) != 0 )
                        continue;

                    byTempGrp =  m_Engine.m_byGroupBoard[i];
                    by12Main = (byte)(m_Engine.m_stGroup[ byTempGrp & 0xff ].nOtherSumImp & 0x7f);

                    if( (by12Main & 0xff) > 0x18 )
                    {
                        ScoreSum( byStrNoTemp, - ( by12Main >>> 1 ) );
                        continue;
                    }
                }
                ScoreSum( byStrNoTemp, -12 );
                continue;
            }
            else
            {
                if( ( m_Engine.m_wStatus[byStrNoMain & 0xff] & 0x08 ) == 0 )
                    continue;

                by12Temp = (byte)(m_Engine.m_stTempGroup[m_Engine.m_byTempGroupBoard[i] & 0xff].nOtherSumImp & 0x7f);

                if( (by12Temp & 0xff) > 0x18 )
                    ScoreSum( byStrNoMain, by12Temp >>> 1 );
                else
                    ScoreSum( byStrNoMain, 12 );
            }
        }

        GetbyStonePos( m_Engine.m_nPos3 );
        GetbyStonePos( m_Engine.m_nPos2 );
        GetbyStonePos( m_Engine.m_nPos1 );

        if( ( m_Engine.m_byTurnColor & 1 ) == 0 )
            m_Engine.m_nNewTerritory = (short)- m_Engine.m_nNewTerritory;

        m_Engine.m_nNewTerritory += 0x12 * m_Engine.m_nDeadStoneCount;
    }

    void GetbyStonePos( short nPos )
    {
        byte	byTemp;
        byte	byTemp1;

        if( nPos == (short)0xffff )
            return;

        byTemp = m_Engine.m_byBoard[nPos];
        if( ( byTemp == 0 ) || ( (m_Engine.m_wStatus[byTemp] & 0x08) != 0 ) )
            return;

        byTemp = m_Engine.m_byGroupBoard[nPos];

        if( ( byTemp == 0 ) || (m_Engine.m_stGroup[byTemp & 0xff].nOtherSumImp != 0) )
            return;
        m_Engine.m_stGroup[byTemp & 0xff].nOtherSit = m_Engine.m_stGroup[byTemp & 0xff].nSituation;
        byTemp1 = (byte)m_Engine.m_stGroup[byTemp & 0xff].nOtherSit;

        m_Engine.m_stGroup[byTemp & 0xff].nOtherSumImp = 0x98;

        ScoreSum( byTemp, QuarterOfMul( byTemp1, (byte)0x98 ) );
    }

    int QuarterOfMul( byte by1, byte by2 )
    {
        int n = ( (byte)by1 * ( by2 & 0x7f ) ) >>> 1;

        if( n >= 0 )
            n ++;
        n >>= 1;

        return n;
    }

    byte GetbyInfo10( byte GroupNoMain, byte GroupNoTemp, byte byInput )
    {
        byte by10 = (byte)(( m_Engine.m_stGroup[GroupNoMain].nSumImport >=
                m_Engine.m_stTempGroup[GroupNoTemp].nSumImport )
                ? m_Engine.m_stGroup[GroupNoMain].nSumImport
                : m_Engine.m_stTempGroup[GroupNoTemp].nSumImport);

        if( ( GroupNoMain == m_Engine.m_byNewGroupNumber ) &&
                ( m_Engine.m_stGroup[GroupNoMain].nTotalSize <=
                        m_Engine.m_stTempGroup[GroupNoTemp].nTotalSize ) )
        {
            by10 += 4;
            if( ( (byte)m_Engine.WhereCall >= 0 ) || ( ((m_Engine.m_nComStoneColor ^ GroupNoMain) & 1) == 0 ) )
                by10 += 4;
        }
        by10 |= 0x80;

        if( (by10 & 0xff) < (byInput & 0xff) )
            by10 = byInput;

        return by10;
    }

    int MulAndGetOf11A12( byte GroupNoMain, byte GroupNoTemp, byte by11Main, byte by4Temp, byte byGet10 )
    {
        if( (byte)by11Main < 0 )
        {
            boolean bFlag= true;
            byte c11Main= by11Main;
            byte c4Temp= by4Temp;
            if (c11Main < c4Temp)
                bFlag= false;

            if(bFlag || ((by11Main & 0xff) < (by4Temp & 0xff)))
                return Get11And12( GroupNoMain, GroupNoTemp, (byte)0x80, byGet10 );
            else
                return Get11And12( GroupNoMain, GroupNoTemp, (byte)((by11Main & 0xff) - (by4Temp & 0xff)), byGet10 );
        }

        return MAGOf11A12InPlus( GroupNoMain, GroupNoTemp, by11Main, by4Temp, byGet10 );
    }

    int Get11And12( byte GroupNoMain, byte GroupNoTemp, byte byGetNew, byte byGet10 )
    {
        m_Engine.m_stGroup[GroupNoMain & 0xff].nOtherSit =
                m_Engine.m_stTempGroup[GroupNoTemp & 0xff].nOtherSit = (short)(byGetNew & 0xff);

        byGet10 |= 0x80;

        m_Engine.m_stGroup[GroupNoMain & 0xff].nOtherSumImp =
                m_Engine.m_stTempGroup[GroupNoTemp & 0xff].nOtherSumImp = (short)(byGet10 & 0xff);

        return QuarterOfMul( byGetNew, byGet10 );
    }

    int MAGOf11A12InTemp( byte GroupNoMain, byte GroupNoTemp, byte by4Main, byte by11Temp, byte byGet10 )
    {
        boolean	bFlag = false;
        byte c4Main = by4Main;
        byte c11Temp = by11Temp;
        byte cSum= (byte)((by4Main & 0xff) + (by11Temp & 0xff));
        if (c4Main < c11Temp)
            bFlag= true;

        if( c11Temp < 0 )
        {
            by11Temp = (byte)(- by11Temp);
            if( (by4Main & 0xff) >= (by11Temp & 0xff) )
            {
                if( bFlag )
                    return Get11And12( GroupNoMain, GroupNoTemp, (byte)0x7f, byGet10 );
                else
                    return Get11And12( GroupNoMain, GroupNoTemp, (byte)((by4Main & 0xff) - (by11Temp & 0xff)), byGet10 );
            }
            else
            {
                if( bFlag )
                    return Get11And12( GroupNoMain, GroupNoTemp, (byte)((by4Main & 0xff) - (by11Temp & 0xff)), byGet10 );
                else
                    return Get11And12( GroupNoMain, GroupNoTemp, (byte)0x80, byGet10 );
            }
        }
        if( cSum/*(char) ( by4Main + by11Temp )*/ < 0 )
            return Get11And12( GroupNoMain, GroupNoTemp, (byte)0x7f, byGet10 );
        else
            return Get11And12( GroupNoMain, GroupNoTemp, (byte)((by4Main & 0xff) + (by11Temp & 0xff)), byGet10 );
    }

    int MAGOf11A12InPlus( byte GroupNoMain, byte GroupNoTemp, byte byMain, byte by4Temp, byte byGet10 )
    {
        boolean	bFlag = true;
        byte cMain = byMain;
        byte c4Temp = by4Temp;

        if (cMain < c4Temp)
            bFlag = false;

        if( (byMain & 0xff) >= (by4Temp & 0xff) )
        {
            if( ( (byGet10 & 0xff) > 0x98 ) && ( ((m_Engine.m_byTurnColor ^ GroupNoMain) & 1) == 0 ) )
                byGet10 = (byte)0x98;

            if( !bFlag )
                return Get11And12( GroupNoMain, GroupNoTemp, (byte)0x80, byGet10 );
            else
                return Get11And12( GroupNoMain, GroupNoTemp, (byte)((byMain & 0xff) - (by4Temp & 0xff)), byGet10 );
        }
        else
        {
            if( bFlag )
                return Get11And12( GroupNoMain, GroupNoTemp, (byte)0x80, byGet10 );
            else
                return Get11And12( GroupNoMain, GroupNoTemp, (byte)((byMain & 0xff) - (by4Temp & 0xff)), byGet10 );
        }
    }

    void ScoreSum( byte GroupNo, int Score )
    {
        if( (GroupNo & 1) != 0 )
        {
            m_Engine.m_wWhiteTSize9 -= Score;
            Score = - Score;
        }
        else
            m_Engine.m_wBlackTSize9 -= Score;

        m_Engine.m_nNewTerritory += Score;
    }

    void Info12Sum(short nSurGrpNumber )
    {
        if( m_Engine.m_stGroup[nSurGrpNumber].nOtherSumImp != 0 )
        {
            m_Engine.m_byHIResult++;
            m_Engine.m_byLOResult += (m_Engine.m_stGroup[nSurGrpNumber].nOtherSumImp & 0xff);
        }
    }

    void UpdateInfo9()
    {
        byte byGrpNum;

        short nStrNum,nOldGrpNum ,nStones;
        byte bySEPs;
        byte byInfo7,byInfo9;

        if((byte)m_Engine.m_byNewStringNumber > 0 )
        {
            byGrpNum = (byte)m_Engine.m_nTempGroupCount;//m_nTempTotalGroupCount
            if( (byGrpNum & 0xff) > 0 )
            {
                while( (byGrpNum & 0xff) > 0 )
                    m_Engine.m_stTempGroup[(byGrpNum--) & 0xff].nOtherSumImp = 0;
            }
        }

        for( m_Engine.m_nMainPosition = STARTPOS; m_Engine.m_nMainPosition < ENDPOS; m_Engine.m_nMainPosition ++ )
        {
            if( m_Engine.m_byBoard[m_Engine.m_nMainPosition] == (byte)0xF0 )
                continue;

            nStrNum = (short)(m_Engine.m_byBoard[m_Engine.m_nMainPosition] & 0xff);
            if( nStrNum == 0 )
                continue;
            byGrpNum = m_Engine.m_byGroupBoard[m_Engine.m_nMainPosition];
            if( byGrpNum == 0 )
                continue;

            if( byGrpNum == m_Engine.m_byNewGroupNumber )
            {
                nOldGrpNum = (short)(m_Engine.m_byTempGroupBoard[m_Engine.m_nMainPosition] & 0xff);
                if( nOldGrpNum != 0 )
                {
                    if((( nOldGrpNum ^ byGrpNum ) & 1 ) == 0 )//Equal Color
                    {
                        if( m_Engine.m_stTempGroup[nOldGrpNum].nOtherSumImp == 0 )
                            m_Engine.m_stTempGroup[nOldGrpNum].nOtherSumImp = (short)(byGrpNum & 0xff);
                    }
                }
            }

            bySEPs = m_Engine.m_byLiberties[nStrNum];
            if(( bySEPs & 0x80 ) == 0x80 )
                continue;

            if( nStrNum <= 0x7a )
                m_Engine.m_byLiberties[nStrNum] |= 0x80;

            nStones = m_Engine.m_nStoneCount[nStrNum];
            if( m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth == 0xff )
                continue;

            if(( nStrNum & 0x01 ) == ( byGrpNum & 0x01 ))
            {
                byInfo7 = (byte)(m_Engine.m_stGroup[byGrpNum].nBattleGain & 0xff);
                if( (bySEPs & 0xff) > (byInfo7 & 0xff) )
                {
                    if( (byInfo7 & 0xff) > 2 )
                        //byInfo7 += ( bySEPs - 2 );
                        byInfo7 = (byte)((byInfo7 & 0xff) + ((bySEPs & 0xff) - 2));
                    else
                        byInfo7 = bySEPs;
                }
                else
                {
                    if( (bySEPs & 0xff) > 2 )
                        //byInfo7 += ( bySEPs - 2 );
                        byInfo7 = (byte)((byInfo7 & 0xff) + ((bySEPs & 0xff) - 2));
                }
                m_Engine.m_stGroup[byGrpNum & 0xff].nBattleGain = (short)(byInfo7 & 0xff);

                byInfo9 = (byte)(m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth & 0xff);
                if( (bySEPs & 0xff) > (byInfo9 & 0xff) )
                {
                    if( (byInfo9 & 0xff) > 3 )
                        //byInfo9 += ( bySEPs - 3 );
                        byInfo9 = (byte)((byInfo9 & 0xff) + ((bySEPs & 0xff) - 3));
                    else
                        byInfo9 = bySEPs;
                }
                else
                {
                    if( (bySEPs & 0xff) > 3 )
                        byInfo9 = (byte)((byInfo9 & 0xff) + ((bySEPs & 0xff) - 3));
                }
                m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth = (short)(byInfo9 & 0xff);
            }
            else
                m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth += GetDeadStoneInfo9(bySEPs,nStones);
        }

        for( nStrNum = 1;nStrNum < MAX_STRINGCOUNT; nStrNum ++ )
        {
            m_Engine.m_byLiberties[nStrNum] &= 0x7f;
        }
        for( byGrpNum = 1;(byGrpNum & 0xff) <= m_Engine.m_nTotalGroupCount; byGrpNum ++ )
        {
            if( ( m_Engine.m_stGroup[byGrpNum & 0xff].nTotalSize != 0 )&&
                    ( m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth != 0xff ) )
            {
                byInfo7 = (byte)(m_Engine.m_stGroup[byGrpNum & 0xff].nBattleGain & 0xff);
                if( 0xff-(short)(byInfo7 & 0xff) >= m_Engine.m_stGroup[byGrpNum & 0xff].nExtendSize )
                {
                    //byInfo7 += (byte)m_Engine.m_stGroup[byGrpNum].nExtendSize;
                    byInfo7 = (byte)((byInfo7 & 0xff) + m_Engine.m_stGroup[byGrpNum & 0xff].nExtendSize);
                    if( 0xff-m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth >= (short)(byInfo7 & 0xff) )
                        m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth += (short)(byInfo7 & 0xff);
                    else
                        m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth = 0xff;
                }
                else
                    m_Engine.m_stGroup[byGrpNum & 0xff].nImGirth = 0xff;
            }
            m_Engine.m_stGroup[byGrpNum & 0xff].nBattleGain = 0;
        }
    }

    //H.Joon<<
}

interface IGroup {
    public void setValue(int value);
}

class SIMULRESULT {
    byte byCount;
    byte byRelStr;
};

class SIMULMOVE {
    short wPoint;
    byte cStatus;
};

class SIMULSET {
    short wNext;
    byte byStr;
    byte byColor;
};

class SIMULUNIT {
    short wParent;
    byte cStatus;
    byte byCandis;
    byte byChecked;
};

class SIMULPOINT extends IDist {
    short wPoint;
    short wChildUnit;

    public int getData(byte[] byteData, int index) {
        int pos = index;
        wPoint = getShort(byteData, pos);
        pos += 2;
        wChildUnit = getShort(byteData, pos);
        pos += 2;
        return pos;
    }

    public int getData(short[] byteData, int index) {
        int pos = index;
        wPoint = getShort(byteData, pos);
        pos += 2;
        wChildUnit = getShort(byteData, pos);
        pos += 2;
        return pos;
    }

    public byte[] getBytes() {
        byte[] btArray = new byte[4];
        btArray[0] = (byte) (wPoint & 0xff);
        btArray[1] = (byte) (((wPoint & 0xff00) >> 8) & 0xff);
        btArray[2] = (byte) (wChildUnit & 0xff);
        btArray[3] = (byte) (((wChildUnit & 0xff00) >> 8) & 0xff);
        return btArray;
    }

    public short[] getShorts() {
        short[] btArray = new short[4];
        btArray[0] = (byte) (wPoint & 0xff);
        btArray[1] = (byte) (((wPoint & 0xff00) >> 8) & 0xff);
        btArray[2] = (byte) (wChildUnit & 0xff);
        btArray[3] = (byte) (((wChildUnit & 0xff00) >> 8) & 0xff);
        return btArray;
    }
}

class CANDIDATA {
    short nPos;
    short Weight1;
    byte Weight2;
    byte Prop;

    CANDIDATA() {
        nPos = 0;
        Weight1 = 0;
        Weight2 = 0;
        Prop = 0;
    }
};

class InterrelGroup implements IGroup {
    byte byGroupNumber1;
    byte byGroupNumber2;
    short nPos;

    InterrelGroup() {
        byGroupNumber1 = 0;
        byGroupNumber2 = 0;
        nPos = 0;
    }

    public void setValue(int value) {
        byGroupNumber1 = (byte) value;
        byGroupNumber2 = (byte) value;
        nPos = (short) value;
    }
    public void copy(InterrelGroup ig)
    {
        byGroupNumber1 = ig.byGroupNumber1;
        byGroupNumber2 = ig.byGroupNumber2;
        nPos = ig.nPos;
    }
};

class GroupRelation implements IGroup {
    short nBattleGain;
    short nImGirth;

    short nExtendSize;
    short nAliveDead;
    short nHomeSize;
    short nTotalSize;
    short nSituation;

    short nCompetition;

    short nImportance;

    short nOtherSit;	//	byGroupInfo11;
    short nOtherSumImp;	//	byGroupInfo12;
    short nSumImport;	//	byGroupInfo10;

    GroupRelation() {
        super();

        nBattleGain = 0;
        nImGirth = 0;
        nExtendSize = 0;
        nAliveDead = 0;
        nHomeSize = 0;
        nTotalSize = 0;
        nSituation = 0;
        nCompetition = 0;
        nImportance = 0;
        nOtherSit = 0;	//	byGroupInfo11;
        nOtherSumImp = 0; //	byGroupInfo12;
        nSumImport = 0; //	byGroupInfo10;
    }

    public void setValue(int value) {
        nBattleGain = (short) value;
        nImGirth = (short) value;

        nExtendSize = (short) value;
        nAliveDead = (short) value;
        nHomeSize = (short) value;
        nTotalSize = (short) value;
        nSituation = (short) value;

        nCompetition = (short) value;

        nImportance = (short) value;
        nOtherSit = (short) value;	//	byGroupInfo11;
        nOtherSumImp = (short) value; //	byGroupInfo12;
        nSumImport = (short) value; //	byGroupInfo10;

    }

};

class PDK_FORMAT {
    byte szMark[] = new byte[12];
    short nComStoneColor;
    short nBoardSize;
    short nGameLevel;
    short nIniStoneCount;
    short wBufSize;
    short nStoneCounter;
    short wEditBoardFlag;
    byte reserved[] = new byte[6];
};

class EXTJONGSOK_HEADER {
    byte szMark[] = new byte[12];
    int dwIndex;
    byte reserved[] = new byte[16];
}

abstract class IDist {
    public static byte getByte(byte[] byteData, int index) {
        if (byteData == null)
            return 0;
        if ( (index < 0) || (index > byteData.length))
            return 0;
        return (byteData[index]);
    }

    public static short getShort(byte[] byteData, int index) {
        return (short) ((getByte(byteData, index) & 0xff) |
                (((getByte(byteData, index + 1) & 0xff) << 8)));
    }

    public static int getInt(byte[] byteData, int index) {
        return (int) ((getShort(byteData, index) & 0x0ffff) |
                (((getShort(byteData, index + 2) & 0xffff) << 16)));
    }

    public static byte getByte(short[] byteData, int index) {
        if (byteData == null)
            return 0;
        if ( (index < 0) || (index > byteData.length))
            return 0;
        return (byte) (byteData[index] & 0xff);
    }

    public static short getShort(short[] byteData, int index) {
        return (short) ((getByte(byteData, index) & 0xff) |
                (((getByte(byteData, index + 1) & 0xff) << 8)));
    }

    public static int getInt(short[] byteData, int index) {
        return (int) ((getShort(byteData, index) & 0x0ffff) |
                (((getShort(byteData, index + 2) & 0xffff) << 16)));
    }

    abstract public int getData(byte[] byteData, int index);
}

class DISTRIBUTION extends IDist {
    int dwNearby;
    int dwKeima;
    int dwIkenDKos;
    int dwOKeima;
    short wNiken;

    public int getData(byte[] byteData, int index) {
        int pos = index;
        dwNearby = getInt(byteData, pos);
        pos += 4;
        dwKeima = getInt(byteData, pos);
        pos += 4;
        dwIkenDKos = getInt(byteData, pos);
        pos += 4;
        dwOKeima = getInt(byteData, pos);
        pos += 4;
        wNiken = getShort(byteData, pos);
        pos += 2;
        return pos;
    }
};

class DIST {
    short wNearby;
    short wKeima;
    short wIkenDKos;
    short wOKeima;
    byte byNiken;

    DIST() {
        wNearby = 0;
        wKeima = 0;
        wIkenDKos = 0;
        wOKeima = 0;
        byNiken = 0;
    }
};

class PATTUNIT extends IDist {
    short wOption;
    DISTRIBUTION dist = new DISTRIBUTION();
    int dwPropOffset;

    public int getData(byte[] byteData, int index) {
        int pos = index;
        wOption = getShort(byteData, pos);
        pos += 2;
        pos = dist.getData(byteData, pos);
        dwPropOffset = getInt(byteData, pos);
        if (dwPropOffset < 0)
            dwPropOffset = 0;
        pos += 4;
        return pos;
    }

    public PATTUNIT creatUnit(byte[] byteData, int index) {
        PATTUNIT newInst = new PATTUNIT();
        newInst.getData(byteData, index);
        return newInst;
    }
}
